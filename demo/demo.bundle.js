// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

let extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s)=>s ? parseInt(s, 36) : 1
);
for(let i = 1; i < extend.length; i++)extend[i] += extend[i - 1];
function isExtendingChar(code1) {
    for(let i11 = 1; i11 < extend.length; i11 += 2)if (extend[i11] > code1) return extend[i11 - 1] <= code1;
    return false;
}
function isRegionalIndicator(code2) {
    return code2 >= 127462 && code2 <= 127487;
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length) return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while(pos < str.length){
        let next = codePointAt(str, pos);
        if (prev == 8205 || next == 8205 || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        } else if (isRegionalIndicator(next)) {
            let countBefore = 0, i21 = pos - 2;
            while(i21 >= 0 && isRegionalIndicator(codePointAt(str, i21))){
                countBefore++;
                i21 -= 2;
            }
            if (countBefore % 2 == 0) break;
            else pos += 2;
        } else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
    while(pos > 0){
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos) return found;
        pos--;
    }
    return 0;
}
function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1)) return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code3) {
    if (code3 <= 65535) return String.fromCharCode(code3);
    code3 -= 65536;
    return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
}
function codePointSize(code4) {
    return code4 < 65536 ? 1 : 2;
}
function countColumn(string1, tabSize, to = string1.length) {
    let n = 0;
    for(let i5 = 0; i5 < to;){
        if (string1.charCodeAt(i5) == 9) {
            n += tabSize - n % tabSize;
            i5++;
        } else {
            n++;
            i5 = findClusterBreak(string1, i5);
        }
    }
    return n;
}
function findColumn(string2, col, tabSize, strict) {
    for(let i6 = 0, n = 0;;){
        if (n >= col) return i6;
        if (i6 == string2.length) break;
        n += string2.charCodeAt(i6) == 9 ? tabSize - n % tabSize : 1;
        i6 = findClusterBreak(string2, i6);
    }
    return strict === true ? -1 : string2.length;
}
var Tree;
(function(Tree2) {
    Tree2[Tree2["BranchShift"] = 5] = "BranchShift";
    Tree2[Tree2["Branch"] = 1 << Tree2.BranchShift] = "Branch";
})(Tree || (Tree = {}));
var Open;
(function(Open2) {
    Open2[Open2["From"] = 1] = "From";
    Open2[Open2["To"] = 2] = "To";
})(Open || (Open = {}));
class Text {
    length;
    lines;
    lineAt(pos) {
        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
        let parts = [];
        this.decompose(0, from, parts, Open.To);
        if (text.length) text.decompose(0, text.length, parts, Open.From | Open.To);
        this.decompose(to, this.length, parts, Open.From);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    eq(other) {
        if (other == this) return true;
        if (other.length != this.length || other.lines != this.lines) return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for(let skip = start, pos = start;;){
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
            pos += a.value.length;
            if (a.done || pos >= end) return true;
        }
    }
    iter(dir = 1) {
        return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
        return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        } else {
            if (to == null) to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    toString() {
        return this.sliceString(0);
    }
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    constructor(){}
    children;
    [Symbol.iterator];
    static of(text) {
        if (text.length == 0) throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0]) return Text.empty;
        return text.length <= Tree.Branch ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
    static empty;
}
class TextLeaf extends Text {
    text;
    length;
    constructor(text, length = textLength(text)){
        super();
        this.text = text;
        this.length = length;
    }
    get lines() {
        return this.text.length;
    }
    get children() {
        return null;
    }
    lineInner(target, isLine, line, offset) {
        for(let i7 = 0;; i7++){
            let string3 = this.text[i7], end = offset + string3.length;
            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string3);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & Open.From) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= Tree.Branch) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            } else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        } else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= Tree.Branch) return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for(let pos = 0, i8 = 0; pos <= to && i8 < this.text.length; i8++){
            let line = this.text[i8], end = pos + line.length;
            if (pos > from && i8) result += lineSep;
            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)target.push(line);
    }
    scanIdentical() {
        return 0;
    }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text){
            part.push(line);
            len += line.length + 1;
            if (part.length == Tree.Branch) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1) target.push(new TextLeaf(part, len));
        return target;
    }
}
class TextNode extends Text {
    children;
    length;
    lines = 0;
    constructor(children, length){
        super();
        this.children = children;
        this.length = length;
        for (let child of children)this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for(let i9 = 0;; i9++){
            let child = this.children[i9], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for(let i10 = 0, pos = 0; pos <= to && i10 < this.children.length; i10++){
            let child = this.children[i10], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? Open.From : 0) | (end >= to ? Open.To : 0));
                if (pos >= from && end <= to && !childOpen) target.push(child);
                else child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        if (text.lines < this.lines) for(let i12 = 0, pos = 0; i12 < this.children.length; i12++){
            let child = this.children[i12], end = pos + child.length;
            if (from >= pos && to <= end) {
                let updated = child.replace(from - pos, to - pos, text);
                let totalLines = this.lines - child.lines + updated.lines;
                if (updated.lines < totalLines >> Tree.BranchShift - 1 && updated.lines > totalLines >> Tree.BranchShift + 1) {
                    let copy1 = this.children.slice();
                    copy1[i12] = updated;
                    return new TextNode(copy1, this.length - (to - from) + text.length);
                }
                return super.replace(pos, end, updated);
            }
            pos = end + 1;
        }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for(let i13 = 0, pos = 0; i13 < this.children.length && pos <= to; i13++){
            let child = this.children[i13], end = pos + child.length;
            if (pos > from && i13) result += lineSep;
            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode)) return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [
            0,
            0,
            this.children.length,
            other.children.length
        ] : [
            this.children.length - 1,
            other.children.length - 1,
            -1,
            -1
        ];
        for(;; iA += dir, iB += dir){
            if (iA == eA || iB == eB) return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB) return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1
    , -1)) {
        let lines = 0;
        for (let ch of children)lines += ch.lines;
        if (lines < Tree.Branch) {
            let flat = [];
            for (let ch of children)ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(Tree.Branch, lines >> Tree.BranchShift), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add1(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)add1(node);
            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= Tree.Branch) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            } else {
                if (currentLines + child.lines > chunk) flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0) return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child1 of children)add1(child1);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = new TextLeaf([
    ""
], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1000000000) {
    for(let pos = 0, i14 = 0, first = true; i14 < text.length && pos <= to; i14++){
        let line = text[i14], end = pos + line.length;
        if (end >= from) {
            if (end > to) line = line.slice(0, to - pos);
            if (pos < from) line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            } else target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [
        ""
    ], from, to);
}
class RawTextCursor {
    dir;
    done = false;
    lineBreak = false;
    value = "";
    nodes;
    offsets;
    constructor(text, dir = 1){
        this.dir = dir;
        this.nodes = [
            text
        ];
        this.offsets = [
            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1
        ];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for(;;){
            let last = this.nodes.length - 1;
            let top1 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top1 instanceof TextLeaf ? top1.text.length : top1.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0) this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            } else if (top1 instanceof TextLeaf) {
                let next = top1.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            } else {
                let next = top1.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                } else {
                    if (dir < 0) this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, -this.dir);
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
    [Symbol.iterator];
}
class PartialTextCursor {
    cursor;
    value = "";
    pos;
    from;
    to;
    done = false;
    constructor(text, start, end){
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit) skip = limit;
        limit -= skip;
        let { value  } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0) skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
        return this.cursor.lineBreak && this.value != "";
    }
    [Symbol.iterator];
}
class LineCursor {
    inner;
    afterBreak = true;
    value = "";
    done = false;
    constructor(inner){
        this.inner = inner;
    }
    next(skip = 0) {
        let { done , lineBreak , value  } = this.inner.next(skip);
        if (done) {
            this.done = true;
            this.value = "";
        } else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            } else {
                this.afterBreak = true;
                this.next();
            }
        } else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() {
        return false;
    }
    [Symbol.iterator];
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
        return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
        return this;
    };
}
class Line {
    from;
    to;
    number;
    text;
    constructor(from, to, number1, text){
        this.from = from;
        this.to = to;
        this.number = number1;
        this.text = text;
    }
    get length() {
        return this.to - this.from;
    }
}
const DefaultSplit = /\r\n?|\n/;
var MapMode;
(function(MapMode1) {
    MapMode1[MapMode1["Simple"] = 0] = "Simple";
    MapMode1[MapMode1["TrackDel"] = 1] = "TrackDel";
    MapMode1[MapMode1["TrackBefore"] = 2] = "TrackBefore";
    MapMode1[MapMode1["TrackAfter"] = 3] = "TrackAfter";
})(MapMode || (MapMode = {}));
class ChangeDesc {
    sections;
    constructor(sections){
        this.sections = sections;
    }
    get length() {
        let result = 0;
        for(let i15 = 0; i15 < this.sections.length; i15 += 2)result += this.sections[i15];
        return result;
    }
    get newLength() {
        let result = 0;
        for(let i16 = 0; i16 < this.sections.length; i16 += 2){
            let ins = this.sections[i16 + 1];
            result += ins < 0 ? this.sections[i16] : ins;
        }
        return result;
    }
    get empty() {
        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
        for(let i17 = 0, posA = 0, posB = 0; i17 < this.sections.length;){
            let len = this.sections[i17++], ins = this.sections[i17++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            } else {
                posB += ins;
            }
            posA += len;
        }
    }
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    get invertedDesc() {
        let sections = [];
        for(let i18 = 0; i18 < this.sections.length;){
            let len = this.sections[i18++], ins = this.sections[i18++];
            if (ins < 0) sections.push(len, ins);
            else sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    composeDesc(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
        return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for(let i19 = 0; i19 < this.sections.length;){
            let len = this.sections[i19++], ins = this.sections[i19++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos) return posB + (pos - posA);
                posB += len;
            } else {
                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    touchesRange(from, to = from) {
        for(let i20 = 0, pos = 0; i20 < this.sections.length && pos <= to;){
            let len = this.sections[i20++], ins = this.sections[i20++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    toString() {
        let result = "";
        for(let i22 = 0; i22 < this.sections.length;){
            let len = this.sections[i22++], ins = this.sections[i22++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    toJSON() {
        return this.sections;
    }
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != "number"
        )) throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
}
class ChangeSet extends ChangeDesc {
    inserted;
    constructor(sections, inserted){
        super(sections);
        this.inserted = inserted;
    }
    apply(doc1) {
        if (this.length != doc1.length) throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc1 = doc1.replace(fromB, fromB + (toA - fromA), text)
        , false);
        return doc1;
    }
    mapDesc(other, before = false) {
        return mapSet(this, other, before, true);
    }
    invert(doc2) {
        let sections = this.sections.slice(), inserted = [];
        for(let i23 = 0, pos = 0; i23 < sections.length; i23 += 2){
            let len = sections[i23], ins = sections[i23 + 1];
            if (ins >= 0) {
                sections[i23] = ins;
                sections[i23 + 1] = len;
                let index = i23 >> 1;
                while(inserted.length < index)inserted.push(Text.empty);
                inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    compose(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
        return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    get desc() {
        return new ChangeDesc(this.sections);
    }
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for(let i24 = 0, pos = 0;;){
            let next = i24 == ranges.length ? 1000000000 : ranges[i24++];
            while(pos < next || pos == next && iter.len == 0){
                if (iter.done) break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i24++];
            while(pos < end){
                if (iter.done) break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return {
            changes: new ChangeSet(resultSections, resultInserted),
            filtered: new ChangeDesc(filteredSections)
        };
    }
    toJSON() {
        let parts = [];
        for(let i25 = 0; i25 < this.sections.length; i25 += 2){
            let len = this.sections[i25], ins = this.sections[i25 + 1];
            if (ins < 0) parts.push(len);
            else if (ins == 0) parts.push([
                len
            ]);
            else parts.push([
                len
            ].concat(this.inserted[i25 >> 1].toJSON()));
        }
        return parts;
    }
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length) return;
            if (pos < length) addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process1(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)process1(sub);
            } else if (spec instanceof ChangeSet) {
                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            } else {
                let { from , to =from , insert: insert1  } = spec;
                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert1 ? Text.empty : typeof insert1 == "string" ? Text.of(insert1.split(lineSep || DefaultSplit)) : insert1;
                let insLen = insText.length;
                if (from == to && insLen == 0) return;
                if (from < pos) flush();
                if (from > pos) addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process1(changes);
        flush(!total);
        return total;
    }
    static empty(length) {
        return new ChangeSet(length ? [
            length,
            -1
        ] : [], []);
    }
    static fromJSON(json) {
        if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for(let i110 = 0; i110 < json.length; i110++){
            let part = json[i110];
            if (typeof part == "number") {
                sections.push(part, -1);
            } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i26)=>i26 && typeof e != "string"
            )) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            } else if (part.length == 1) {
                sections.push(part[0], 0);
            } else {
                while(inserted.length < i110)inserted.push(Text.empty);
                inserted[i110] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i110].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0) return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;
    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    } else sections.push(len, ins);
}
function addInsert(values1, sections, value) {
    if (value.length == 0) return;
    let index = sections.length - 2 >> 1;
    if (index < values1.length) {
        values1[values1.length - 1] = values1[values1.length - 1].append(value);
    } else {
        while(values1.length < index)values1.push(Text.empty);
        values1.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for(let posA = 0, posB = 0, i27 = 0; i27 < desc.sections.length;){
        let len = desc.sections[i27++], ins = desc.sections[i27++];
        if (ins < 0) {
            posA += len;
            posB += len;
        } else {
            let endA = posA, endB = posB, text = Text.empty;
            for(;;){
                endA += len;
                endB += ins;
                if (ins && inserted) text = text.append(inserted[i27 - 2 >> 1]);
                if (individual || i27 == desc.sections.length || desc.sections[i27 + 1] < 0) break;
                len = desc.sections[i27++];
                ins = desc.sections[i27++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for(let posA = 0, posB = 0;;){
        if (a.ins == -1) {
            posA += a.len;
            a.next();
        } else if (b.ins == -1 && posB < posA) {
            let skip = Math.min(b.len, posA - posB);
            b.forward(skip);
            addSection(sections, skip, -1);
            posB += skip;
        } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
            addSection(sections, b.ins, -1);
            while(posA > posB && !a.done && posA + a.len < posB + b.len){
                posA += a.len;
                a.next();
            }
            posB += b.len;
            b.next();
        } else if (a.ins >= 0) {
            let len = 0, end = posA + a.len;
            for(;;){
                if (b.ins >= 0 && posB > posA && posB + b.len < end) {
                    len += b.ins;
                    posB += b.len;
                    b.next();
                } else if (b.ins == -1 && posB < end) {
                    let skip = Math.min(b.len, end - posB);
                    len += skip;
                    b.forward(skip);
                    posB += skip;
                } else {
                    break;
                }
            }
            addSection(sections, len, a.ins);
            if (insert2) addInsert(insert2, sections, a.text);
            posA = end;
            a.next();
        } else if (a.done && b.done) {
            return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
        } else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert3 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for(let open = false;;){
        if (a.done && b.done) {
            return insert3 ? new ChangeSet(sections, insert3) : new ChangeDesc(sections);
        } else if (a.ins == 0) {
            addSection(sections, a.len, 0, open);
            a.next();
        } else if (b.len == 0 && !b.done) {
            addSection(sections, 0, b.ins, open);
            if (insert3) addInsert(insert3, sections, b.text);
            b.next();
        } else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        } else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert3 && insB) addInsert(insert3, sections, b.text);
            } else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert3) addInsert(insert3, sections, a.textBit(len));
            } else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert3 && !b.off) addInsert(insert3, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    set;
    i = 0;
    len;
    off;
    ins;
    constructor(set){
        this.set = set;
        this.next();
    }
    next() {
        let { sections  } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        } else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() {
        return this.ins == -2;
    }
    get len2() {
        return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
        let { inserted  } = this.set, index = this.i - 2 >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted  } = this.set, index = this.i - 2 >> 1;
        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len) this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1) this.forward(len);
        else if (len == this.ins) this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}
var RangeFlag;
(function(RangeFlag1) {
    RangeFlag1[RangeFlag1["BidiLevelMask"] = 3] = "BidiLevelMask";
    RangeFlag1[RangeFlag1["AssocBefore"] = 4] = "AssocBefore";
    RangeFlag1[RangeFlag1["AssocAfter"] = 8] = "AssocAfter";
    RangeFlag1[RangeFlag1["Inverted"] = 16] = "Inverted";
    RangeFlag1[RangeFlag1["GoalColumnOffset"] = 5] = "GoalColumnOffset";
    RangeFlag1[RangeFlag1["NoGoalColumn"] = 33554431] = "NoGoalColumn";
})(RangeFlag || (RangeFlag = {}));
class SelectionRange {
    from;
    to;
    flags;
    constructor(from, to, flags){
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    get anchor() {
        return this.flags & RangeFlag.Inverted ? this.to : this.from;
    }
    get head() {
        return this.flags & RangeFlag.Inverted ? this.from : this.to;
    }
    get empty() {
        return this.from == this.to;
    }
    get assoc() {
        return this.flags & RangeFlag.AssocBefore ? -1 : this.flags & RangeFlag.AssocAfter ? 1 : 0;
    }
    get bidiLevel() {
        let level = this.flags & RangeFlag.BidiLevelMask;
        return level == 3 ? null : level;
    }
    get goalColumn() {
        let value = this.flags >> RangeFlag.GoalColumnOffset;
        return value == RangeFlag.NoGoalColumn ? undefined : value;
    }
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        } else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
        return {
            anchor: this.anchor,
            head: this.head
        };
    }
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
}
class EditorSelection {
    ranges;
    mainIndex;
    constructor(ranges, mainIndex = 0){
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
        if (change.empty) return this;
        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)
        ), this.mainIndex);
    }
    eq(other) {
        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
        for(let i28 = 0; i28 < this.ranges.length; i28++)if (!this.ranges[i28].eq(other.ranges[i28])) return false;
        return true;
    }
    get main() {
        return this.ranges[this.mainIndex];
    }
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([
            this.main
        ]);
    }
    addRange(range, main = true) {
        return EditorSelection.create([
            range
        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
        return {
            ranges: this.ranges.map((r)=>r.toJSON()
            ),
            main: this.mainIndex
        };
    }
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)
        ), json.main);
    }
    static single(anchor, head = anchor) {
        return new EditorSelection([
            EditorSelection.range(anchor, head)
        ], 0);
    }
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
        for(let pos = 0, i29 = 0; i29 < ranges.length; i29++){
            let range = ranges[i29];
            if (range.empty ? range.from <= pos : range.from < pos) return normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? RangeFlag.AssocBefore : RangeFlag.AssocAfter) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn ?? RangeFlag.NoGoalColumn) << RangeFlag.GoalColumnOffset);
    }
    static range(anchor, head, goalColumn) {
        let goal = (goalColumn ?? RangeFlag.NoGoalColumn) << RangeFlag.GoalColumnOffset;
        return head < anchor ? new SelectionRange(head, anchor, RangeFlag.Inverted | goal | RangeFlag.AssocAfter) : new SelectionRange(anchor, head, goal | (head > anchor ? RangeFlag.AssocBefore : 0));
    }
}
function normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b)=>a.from - b.from
    );
    mainIndex = ranges.indexOf(main);
    for(let i30 = 1; i30 < ranges.length; i30++){
        let range = ranges[i30], prev = ranges[i30 - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from = prev.from, to = Math.max(range.to, prev.to);
            if (i30 <= mainIndex) mainIndex--;
            ranges.splice(--i30, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
    }
    return new EditorSelection(ranges, mainIndex);
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
    combine;
    compareInput;
    compare;
    isStatic;
    extensions;
    id = nextID++;
    default;
    constructor(combine, compareInput, compare1, isStatic, extensions){
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare1;
        this.isStatic = isStatic;
        this.extensions = extensions;
        this.default = combine([]);
    }
    static define(config1 = {}) {
        return new Facet(config1.combine || ((a)=>a
        ), config1.compareInput || ((a, b)=>a === b
        ), config1.compare || (!config1.combine ? sameArray : (a, b)=>a === b
        ), !!config1.static, config1.enables);
    }
    of(value) {
        return new FacetProvider([], this, Provider.Static, value);
    }
    compute(deps, get1) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, Provider.Single, get1);
    }
    computeN(deps, get2) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, Provider.Multi, get2);
    }
    from(field, get3) {
        if (!get3) get3 = (x)=>x
        ;
        return this.compute([
            field
        ], (state2)=>get3(state2.field(field))
        );
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i31)=>e === b[i31]
    );
}
var Provider;
(function(Provider1) {
    Provider1[Provider1["Static"] = 0] = "Static";
    Provider1[Provider1["Single"] = 1] = "Single";
    Provider1[Provider1["Multi"] = 2] = "Multi";
})(Provider || (Provider = {}));
class FacetProvider {
    dependencies;
    facet;
    type;
    value;
    id = nextID++;
    extension;
    constructor(dependencies, facet, type, value){
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
    }
    dynamicSlot(addresses) {
        let getter = this.value;
        let compare2 = this.facet.compareInput;
        let id1 = this.id, idx = addresses[id1] >> 1, multi = this.type == Provider.Multi;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies){
            if (dep == "doc") depDoc = true;
            else if (dep == "selection") depSel = true;
            else if (((addresses[dep.id] ?? 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
        }
        return {
            create (state3) {
                state3.values[idx] = getter(state3);
                return SlotStatus.Changed;
            },
            update (state4, tr) {
                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some((addr)=>(ensureAddr(state4, addr) & SlotStatus.Changed) > 0
                )) {
                    let newVal = getter(state4);
                    if (multi ? !compareArray(newVal, state4.values[idx], compare2) : !compare2(newVal, state4.values[idx])) {
                        state4.values[idx] = newVal;
                        return SlotStatus.Changed;
                    }
                }
                return 0;
            },
            reconfigure (state5, oldState) {
                let newVal = getter(state5);
                let oldAddr = oldState.config.address[id1];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal)) {
                        state5.values[idx] = oldVal;
                        return 0;
                    }
                }
                state5.values[idx] = newVal;
                return SlotStatus.Changed;
            }
        };
    }
}
function compareArray(a, b, compare3) {
    if (a.length != b.length) return false;
    for(let i32 = 0; i32 < a.length; i32++)if (!compare3(a[i32], b[i32])) return false;
    return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p1)=>addresses[p1.id]
    );
    let providerTypes = providers.map((p2)=>p2.type
    );
    let dynamic = providerAddrs.filter((p3)=>!(p3 & 1)
    );
    let idx = addresses[facet.id] >> 1;
    function get4(state6) {
        let values2 = [];
        for(let i33 = 0; i33 < providerAddrs.length; i33++){
            let value = getAddr(state6, providerAddrs[i33]);
            if (providerTypes[i33] == Provider.Multi) for (let val of value)values2.push(val);
            else values2.push(value);
        }
        return facet.combine(values2);
    }
    return {
        create (state7) {
            for (let addr of providerAddrs)ensureAddr(state7, addr);
            state7.values[idx] = get4(state7);
            return SlotStatus.Changed;
        },
        update (state8, tr) {
            if (!dynamic.some((dynAddr)=>ensureAddr(state8, dynAddr) & SlotStatus.Changed
            )) return 0;
            let value = get4(state8);
            if (facet.compare(value, state8.values[idx])) return 0;
            state8.values[idx] = value;
            return SlotStatus.Changed;
        },
        reconfigure (state9, oldState) {
            let depChanged = providerAddrs.some((addr)=>ensureAddr(state9, addr) & SlotStatus.Changed
            );
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state9.values[idx] = oldValue;
                return 0;
            }
            let value = get4(state9);
            if (facet.compare(value, oldValue)) {
                state9.values[idx] = oldValue;
                return 0;
            }
            state9.values[idx] = value;
            return SlotStatus.Changed;
        }
    };
}
const initField = Facet.define({
    static: true
});
class StateField {
    id;
    createF;
    updateF;
    compareF;
    spec;
    provides = undefined;
    constructor(id2, createF, updateF, compareF, spec){
        this.id = id2;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
    }
    static define(config2) {
        let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b)=>a === b
        ), config2);
        if (config2.provide) field.provides = config2.provide(field);
        return field;
    }
    create(state10) {
        let init = state10.facet(initField).find((i34)=>i34.field == this
        );
        return (init?.create || this.createF)(state10);
    }
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state11)=>{
                state11.values[idx] = this.create(state11);
                return SlotStatus.Changed;
            },
            update: (state12, tr)=>{
                let oldVal = state12.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value)) return 0;
                state12.values[idx] = value;
                return SlotStatus.Changed;
            },
            reconfigure: (state13, oldState)=>{
                if (oldState.config.address[this.id] != null) {
                    state13.values[idx] = oldState.field(this);
                    return 0;
                }
                state13.values[idx] = this.create(state13);
                return SlotStatus.Changed;
            }
        };
    }
    init(create) {
        return [
            this,
            initField.of({
                field: this,
                create
            })
        ];
    }
    get extension() {
        return this;
    }
}
const Prec_ = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0
};
function prec(value) {
    return (ext)=>new PrecExtension(ext, value)
    ;
}
const Prec = {
    lowest: prec(Prec_.lowest),
    low: prec(Prec_.low),
    default: prec(Prec_.default),
    high: prec(Prec_.high),
    highest: prec(Prec_.highest),
    fallback: prec(Prec_.lowest),
    extend: prec(Prec_.high),
    override: prec(Prec_.highest)
};
class PrecExtension {
    inner;
    prec;
    constructor(inner, prec1){
        this.inner = inner;
        this.prec = prec1;
    }
    extension;
}
class Compartment {
    of(ext) {
        return new CompartmentInstance(this, ext);
    }
    reconfigure(content1) {
        return Compartment.reconfigure.of({
            compartment: this,
            extension: content1
        });
    }
    get(state14) {
        return state14.config.compartments.get(this);
    }
    static reconfigure;
}
class CompartmentInstance {
    compartment;
    inner;
    constructor(compartment, inner){
        this.compartment = compartment;
        this.inner = inner;
    }
    extension;
}
class Configuration {
    base;
    compartments;
    dynamicSlots;
    address;
    staticValues;
    facets;
    statusTemplate = [];
    constructor(base1, compartments, dynamicSlots, address, staticValues, facets){
        this.base = base1;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(SlotStatus.Unresolved);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base2, compartments, newCompartments)){
            if (ext instanceof StateField) fields.push(ext);
            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields){
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a)=>field.slot(a)
            );
        }
        let oldFacets = oldState?.config.facets;
        for(let id3 in facets){
            let providers = facets[id3], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id3] || [];
            if (providers.every((p4)=>p4.type == Provider.Static
            )) {
                address[facet.id] = staticValues.length << 1 | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                } else {
                    let value = facet.combine(providers.map((p5)=>p5.value
                    ));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            } else {
                for (let p6 of providers){
                    if (p6.type == Provider.Static) {
                        address[p6.id] = staticValues.length << 1 | 1;
                        staticValues.push(p6.value);
                    } else {
                        address[p6.id] = dynamicSlots.length << 1;
                        dynamicSlots.push((a)=>p6.dynamicSlot(a)
                        );
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers)
                );
            }
        }
        let dynamic = dynamicSlots.map((f)=>f(address)
        );
        return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [
        [],
        [],
        [],
        [],
        []
    ];
    let seen = new Map();
    function inner(ext, prec2) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec2) return;
            let found = result[known].indexOf(ext);
            if (found > -1) result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec2);
        if (Array.isArray(ext)) {
            for (let e of ext)inner(e, prec2);
        } else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);
            let content2 = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content2);
            inner(content2, prec2);
        } else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        } else if (ext instanceof StateField) {
            result[prec2].push(ext);
            if (ext.provides) inner(ext.provides, prec2);
        } else if (ext instanceof FacetProvider) {
            result[prec2].push(ext);
            if (ext.facet.extensions) inner(ext.facet.extensions, prec2);
        } else {
            let content3 = ext.extension;
            if (!content3) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content3, prec2);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b)=>a.concat(b)
    );
}
var SlotStatus;
(function(SlotStatus1) {
    SlotStatus1[SlotStatus1["Unresolved"] = 0] = "Unresolved";
    SlotStatus1[SlotStatus1["Changed"] = 1] = "Changed";
    SlotStatus1[SlotStatus1["Computed"] = 2] = "Computed";
    SlotStatus1[SlotStatus1["Computing"] = 4] = "Computing";
})(SlotStatus || (SlotStatus = {}));
function ensureAddr(state15, addr) {
    if (addr & 1) return SlotStatus.Computed;
    let idx = addr >> 1;
    let status = state15.status[idx];
    if (status == SlotStatus.Computing) throw new Error("Cyclic dependency between fields and/or facets");
    if (status & SlotStatus.Computed) return status;
    state15.status[idx] = SlotStatus.Computing;
    let changed = state15.computeSlot(state15, state15.config.dynamicSlots[idx]);
    return state15.status[idx] = SlotStatus.Computed | changed;
}
function getAddr(state16, addr) {
    return addr & 1 ? state16.config.staticValues[addr >> 1] : state16.values[addr >> 1];
}
const languageData = Facet.define();
const allowMultipleSelections = Facet.define({
    combine: (values3)=>values3.some((v)=>v
        )
    ,
    static: true
});
const lineSeparator = Facet.define({
    combine: (values4)=>values4.length ? values4[0] : undefined
    ,
    static: true
});
const changeFilter = Facet.define();
const transactionFilter = Facet.define();
const transactionExtender = Facet.define();
const readOnly = Facet.define({
    combine: (values5)=>values5.length ? values5[0] : false
});
class Annotation {
    type;
    value;
    constructor(type, value){
        this.type = type;
        this.value = value;
    }
    static define() {
        return new AnnotationType();
    }
    _isAnnotation;
}
class AnnotationType {
    of(value) {
        return new Annotation(this, value);
    }
}
class StateEffectType {
    map;
    constructor(map){
        this.map = map;
    }
    of(value) {
        return new StateEffect(this, value);
    }
}
class StateEffect {
    type;
    value;
    constructor(type, value){
        this.type = type;
        this.value = value;
    }
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
        return this.type == type;
    }
    static define(spec = {}) {
        return new StateEffectType(spec.map || ((v)=>v
        ));
    }
    static mapEffects(effects, mapping) {
        if (!effects.length) return effects;
        let result = [];
        for (let effect of effects){
            let mapped = effect.map(mapping);
            if (mapped) result.push(mapped);
        }
        return result;
    }
    static reconfigure = StateEffect.define();
    static appendConfig = StateEffect.define();
}
class Transaction {
    startState;
    changes;
    selection;
    effects;
    annotations;
    scrollIntoView;
    _doc = null;
    _state = null;
    constructor(startState, changes, selection, effects, annotations, scrollIntoView2){
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView2;
        if (selection) checkSelection(selection, changes.newLength);
        if (!annotations.some((a)=>a.type == Transaction.time
        )) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
        if (!this._state) this.startState.applyTransaction(this);
        return this._state;
    }
    annotation(type) {
        for (let ann of this.annotations)if (ann.type == type) return ann.value;
        return undefined;
    }
    get docChanged() {
        return !this.changes.empty;
    }
    get reconfigured() {
        return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
    static time = Annotation.define();
    static userEvent = Annotation.define();
    static addToHistory = Annotation.define();
    static remote = Annotation.define();
}
function joinRanges(a, b) {
    let result = [];
    for(let iA = 0, iB = 0;;){
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        } else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        } else return result;
        if (!result.length || result[result.length - 1] < from) result.push(from, to);
        else if (result[result.length - 1] < to) result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    } else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : a.selection?.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state17, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state17.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state18, specs, filter) {
    let s = resolveTransactionInner(state18, specs.length ? specs[0] : {}, state18.doc.length);
    if (specs.length && specs[0].filter === false) filter = false;
    for(let i35 = 1; i35 < specs.length; i35++){
        if (specs[i35].filter === false) filter = false;
        let seq = !!specs[i35].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state18, specs[i35], seq ? s.changes.newLength : state18.doc.length), seq);
    }
    let tr = new Transaction(state18, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
    let state19 = tr.startState;
    let result = true;
    for (let filter of state19.facet(changeFilter)){
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state19.doc.length);
        } else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.invertedDesc;
        }
        tr = new Transaction(state19, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state19.facet(transactionFilter);
    for(let i36 = filters.length - 1; i36 >= 0; i36--){
        let filtered = filters[i36](tr);
        if (filtered instanceof Transaction) tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];
        else tr = resolveTransaction(state19, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state20 = tr.startState, extenders = state20.facet(transactionExtender), spec = tr;
    for(let i37 = extenders.length - 1; i37 >= 0; i37--){
        let extension = extenders[i37](tr);
        if (extension && Object.keys(extension).length) spec = mergeTransaction(tr, resolveTransactionInner(state20, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : new Transaction(state20, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [
        value
    ];
}
var CharCategory;
(function(CharCategory1) {
    CharCategory1[CharCategory1["Word"] = 0] = "Word";
    CharCategory1[CharCategory1["Space"] = 1] = "Space";
    CharCategory1[CharCategory1["Other"] = 2] = "Other";
})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {}
function hasWordChar(str) {
    if (wordChar) return wordChar.test(str);
    for(let i38 = 0; i38 < str.length; i38++){
        let ch = str[i38];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (__char)=>{
        if (!/\S/.test(__char)) return CharCategory.Space;
        if (hasWordChar(__char)) return CharCategory.Word;
        for(let i39 = 0; i39 < wordChars.length; i39++)if (__char.indexOf(wordChars[i39]) > -1) return CharCategory.Word;
        return CharCategory.Other;
    };
}
class EditorState {
    config;
    doc;
    selection;
    values;
    status;
    computeSlot;
    constructor(config3, doc3, selection, values6, computeSlot, tr){
        this.config = config3;
        this.doc = doc3;
        this.selection = selection;
        this.values = values6;
        this.status = config3.statusTemplate.slice();
        this.computeSlot = computeSlot;
        if (tr) tr._state = this;
        for(let i40 = 0; i40 < this.config.dynamicSlots.length; i40++)ensureAddr(this, i40 << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require) throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
        let conf = this.config, { base: base3 , compartments  } = conf;
        for (let effect of tr.effects){
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key)=>compartments.set(key, val)
                    );
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            } else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base3 = effect.value;
            } else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base3 = asArray(base3).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base3, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null
            ), (state21, slot)=>slot.reconfigure(state21, this)
            , null);
            startValues = intermediateState.values;
        } else {
            startValues = tr.startState.values.slice();
        }
        new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state22, slot)=>slot.update(state22, tr)
        , tr);
    }
    replaceSelection(text) {
        if (typeof text == "string") text = this.toText(text);
        return this.changeByRange((range)=>({
                changes: {
                    from: range.from,
                    to: range.to,
                    insert: text
                },
                range: EditorSelection.cursor(range.from + text.length)
            })
        );
    }
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [
            result1.range
        ];
        let effects = asArray(result1.effects);
        for(let i41 = 1; i41 < sel.ranges.length; i41++){
            let result = f(sel.ranges[i41]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for(let j = 0; j < i41; j++)ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    changes(spec = []) {
        if (spec instanceof ChangeSet) return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string4) {
        return Text.of(string4.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null) return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields) for(let prop in fields){
            let value = fields[prop];
            if (value instanceof StateField) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
        return result;
    }
    static fromJSON(json, config4 = {}, fields) {
        if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields) for(let prop in fields){
            let field = fields[prop], value = json[prop];
            fieldInit.push(field.init((state23)=>field.spec.fromJSON(value, state23)
            ));
        }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config4.extensions ? fieldInit.concat([
                config4.extensions
            ]) : fieldInit
        });
    }
    static create(config5 = {}) {
        let configuration = Configuration.resolve(config5.extensions || [], new Map);
        let doc4 = config5.doc instanceof Text ? config5.doc : Text.of((config5.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config5.selection ? EditorSelection.single(0) : config5.selection instanceof EditorSelection ? config5.selection : EditorSelection.single(config5.selection.anchor, config5.selection.head);
        checkSelection(selection, doc4.length);
        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
        return new EditorState(configuration, doc4, selection, configuration.dynamicSlots.map(()=>null
        ), (state24, slot)=>slot.create(state24)
        , null);
    }
    static allowMultipleSelections = allowMultipleSelections;
    static tabSize = Facet.define({
        combine: (values7)=>values7.length ? values7[0] : 4
    });
    get tabSize() {
        return this.facet(EditorState.tabSize);
    }
    static lineSeparator = lineSeparator;
    get lineBreak() {
        return this.facet(EditorState.lineSeparator) || "\n";
    }
    static readOnly = readOnly;
    get readOnly() {
        return this.facet(readOnly);
    }
    static phrases = Facet.define();
    phrase(phrase1) {
        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase1)) return map[phrase1];
        return phrase1;
    }
    static languageData = languageData;
    languageDataAt(name2, pos, side = -1) {
        let values8 = [];
        for (let provider of this.facet(languageData)){
            for (let result of provider(this, pos, side)){
                if (Object.prototype.hasOwnProperty.call(result, name2)) values8.push(result[name2]);
            }
        }
        return values8;
    }
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
        let { text , from , length  } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while(start > 0){
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != CharCategory.Word) break;
            start = prev;
        }
        while(end < length){
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != CharCategory.Word) break;
            end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
    }
    static changeFilter = changeFilter;
    static transactionFilter = transactionFilter;
    static transactionExtender = transactionExtender;
}
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
    let result = {};
    for (let config6 of configs)for (let key of Object.keys(config6)){
        let value = config6[key], current = result[key];
        if (current === undefined) result[key] = value;
        else if (current === value || value === undefined) {} else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);
        else throw new Error("Config merge conflict for field " + key);
    }
    for(let key1 in defaults2)if (result[key1] === undefined) result[key1] = defaults2[key1];
    return result;
}
class RangeValue {
    eq(other) {
        return this == other;
    }
    startSide;
    endSide;
    mapMode;
    point;
    range(from, to = from) {
        return new Range(from, to, this);
    }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range {
    from;
    to;
    value;
    constructor(from, to, value){
        this.from = from;
        this.to = to;
        this.value = value;
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
var C;
(function(C4) {
    C4[C4["ChunkSize"] = 250] = "ChunkSize";
    C4[C4["Far"] = 1000000000] = "Far";
})(C || (C = {}));
class Chunk {
    from;
    to;
    value;
    maxPoint;
    constructor(from, to, value, maxPoint){
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() {
        return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for(let lo = startAt, hi = arr.length;;){
            if (lo == hi) return lo;
            let mid = lo + hi >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo) return diff >= 0 ? lo : hi;
            if (diff >= 0) hi = mid;
            else lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for(let i42 = this.findIndex(from, -C.Far, true), e = this.findIndex(to, C.Far, false, i42); i42 < e; i42++)if (f(this.from[i42] + offset, this.to[i42] + offset, this.value[i42]) === false) return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for(let i43 = 0; i43 < this.value.length; i43++){
            let val = this.value[i43], curFrom = this.from[i43] + offset, curTo = this.to[i43] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null) continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom) continue;
                }
            } else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
            if (newPos < 0) newPos = newFrom;
            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return {
            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
            pos: newPos
        };
    }
}
class RangeSet {
    chunkPos;
    chunk;
    nextLayer;
    maxPoint;
    constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint){
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
        if (this.isEmpty) return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)size += chunk.value.length;
        return size;
    }
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
        let { add: add2 = [] , sort =false , filterFrom =0 , filterTo =this.length  } = updateSpec;
        let filter = updateSpec.filter;
        if (add2.length == 0 && !filter) return this;
        if (sort) add2 = add2.slice().sort(cmpRange);
        if (this.isEmpty) return add2.length ? RangeSet.of(add2) : this;
        let cur1 = new LayerCursor(this, null, -1).goto(0), i44 = 0, spill = [];
        let builder = new RangeSetBuilder();
        while(cur1.value || i44 < add2.length){
            if (i44 < add2.length && (cur1.from - add2[i44].from || cur1.startSide - add2[i44].value.startSide) >= 0) {
                let range = add2[i44++];
                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
            } else if (cur1.rangeIndex == 1 && cur1.chunkIndex < this.chunk.length && (i44 == add2.length || this.chunkEnd(cur1.chunkIndex) < add2[i44].from) && (!filter || filterFrom > this.chunkEnd(cur1.chunkIndex) || filterTo < this.chunkPos[cur1.chunkIndex]) && builder.addChunk(this.chunkPos[cur1.chunkIndex], this.chunk[cur1.chunkIndex])) {
                cur1.nextChunk();
            } else {
                if (!filter || filterFrom > cur1.to || filterTo < cur1.from || filter(cur1.from, cur1.to, cur1.value)) {
                    if (!builder.addInner(cur1.from, cur1.to, cur1.value)) spill.push(new Range(cur1.from, cur1.to, cur1.value));
                }
                cur1.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
            add: spill,
            filter,
            filterFrom,
            filterTo
        }));
    }
    map(changes) {
        if (changes.empty || this.isEmpty) return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for(let i45 = 0; i45 < this.chunk.length; i45++){
            let start = this.chunkPos[i45], chunk = this.chunk[i45];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            } else if (touch === true) {
                let { mapped , pos  } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
    }
    between(from, to, f) {
        if (this.isEmpty) return;
        for(let i46 = 0; i46 < this.chunk.length; i46++){
            let start = this.chunkPos[i46], chunk = this.chunk[i46];
            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
        }
        this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
        return HeapCursor.from([
            this
        ]).goto(from);
    }
    get isEmpty() {
        return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize
        );
        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize
        );
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator)
        );
        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null) to = C.Far;
        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0
        );
        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0
        );
        if (a.length != b.length) return false;
        if (!a.length) return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for(;;){
            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
            if (sideA.to > to) return true;
            sideA.next();
            sideB.next();
        }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize, iterator.filterPoint?.bind(iterator)).goto(from), pos = from;
        let open = cursor.openStart;
        for(;;){
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
            } else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, open);
                open = cursor.openEnd(curTo);
            }
            if (cursor.to > to) break;
            pos = cursor.to;
            cursor.next();
        }
        return open;
    }
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [
            ranges
        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);
        return build.finish();
    }
    static empty = new RangeSet([], [], null, -1);
}
function lazySort(ranges) {
    if (ranges.length > 1) for(let prev = ranges[0], i47 = 1; i47 < ranges.length; i47++){
        let cur2 = ranges[i47];
        if (cmpRange(prev, cur2) > 0) return ranges.slice().sort(cmpRange);
        prev = cur2;
    }
    return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
    chunks = [];
    chunkPos = [];
    chunkStart = -1;
    last = null;
    lastFrom = -C.Far;
    lastTo = -C.Far;
    from = [];
    to = [];
    value = [];
    maxPoint = -1;
    setMaxPoint = -1;
    nextLayer = null;
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    constructor(){}
    add(from, to, value) {
        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0) return false;
        if (this.from.length == C.ChunkSize) this.finishChunk(true);
        if (this.chunkStart < 0) this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
        if (this.from.length) this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    finish() {
        return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
        if (this.from.length) this.finishChunk(false);
        if (this.chunks.length == 0) return next;
        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null;
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)for(let i48 = 0; i48 < set.chunk.length; i48++)if (set.chunk[i48].maxPoint <= 0) inA.set(set.chunk[i48], set.chunkPos[i48]);
    let shared = new Set();
    for (let set1 of b)for(let i111 = 0; i111 < set1.chunk.length; i111++){
        let known = inA.get(set1.chunk[i111]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set1.chunkPos[i111] && !textDiff?.touchesRange(known, known + set1.chunk[i111].length)) shared.add(set1.chunk[i111]);
    }
    return shared;
}
class LayerCursor {
    layer;
    skip;
    minPoint;
    rank;
    from;
    to;
    value;
    chunkIndex;
    rangeIndex;
    constructor(layer, skip, minPoint, rank = 0){
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() {
        return this.value ? this.value.startSide : 0;
    }
    get endSide() {
        return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -C.Far) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while(this.chunkIndex < this.layer.chunk.length){
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
    }
    next() {
        for(;;){
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = C.Far;
                this.value = null;
                break;
            } else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;
            }
            this.rangeIndex = 0;
        } else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    heap;
    from;
    to;
    value;
    rank;
    constructor(heap){
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for(let i49 = 0; i49 < sets.length; i49++){
            for(let cur3 = sets[i49]; !cur3.isEmpty; cur3 = cur3.nextLayer){
                if (cur3.maxPoint >= minPoint) heap.push(new LayerCursor(cur3, skip, minPoint, i49));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
        return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -C.Far) {
        for (let cur4 of this.heap)cur4.goto(pos, side);
        for(let i50 = this.heap.length >> 1; i50 >= 0; i50--)heapBubble(this.heap, i50);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur5 of this.heap)cur5.forward(pos, side);
        for(let i51 = this.heap.length >> 1; i51 >= 0; i51--)heapBubble(this.heap, i51);
        if ((this.to - pos || this.value.endSide - side) < 0) this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = C.Far;
            this.value = null;
            this.rank = -1;
        } else {
            let top2 = this.heap[0];
            this.from = top2.from;
            this.to = top2.to;
            this.value = top2.value;
            this.rank = top2.rank;
            if (top2.value) top2.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for(let cur6 = heap[index];;){
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length) break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur6.compare(child) < 0) break;
        heap[childIndex] = cur6;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    minPoint;
    filterPoint;
    cursor;
    active = [];
    activeTo = [];
    activeRank = [];
    minActive = -1;
    point = null;
    pointFrom = 0;
    pointRank = 0;
    to = -C.Far;
    endSide = 0;
    openStart = -1;
    constructor(sets, skip, minPoint, filterPoint = ()=>true
    ){
        this.minPoint = minPoint;
        this.filterPoint = filterPoint;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -C.Far) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i52 = 0, { value , to , rank  } = this.cursor;
        while(i52 < this.activeRank.length && this.activeRank[i52] <= rank)i52++;
        insert(this.active, i52, value);
        insert(this.activeTo, i52, to);
        insert(this.activeRank, i52, rank);
        if (trackOpen) insert(trackOpen, i52, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
        for(;;){
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen) remove(trackOpen, a);
            } else if (!this.cursor.value) {
                this.to = this.endSide = C.Far;
                break;
            } else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            } else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) {
                    this.addActive(trackOpen);
                    this.cursor.next();
                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    this.cursor.next();
                } else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {
                    this.cursor.next();
                } else {
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    if (this.cursor.from < from) trackExtra = 1;
                    this.cursor.next();
                    if (this.to > from) this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            let openStart = 0;
            while(openStart < trackOpen.length && trackOpen[openStart] < from)openStart++;
            this.openStart = openStart + trackExtra;
        }
    }
    activeForPoint(to) {
        if (!this.active.length) return this.active;
        let active = [];
        for(let i53 = this.active.length - 1; i53 >= 0; i53--){
            if (this.activeRank[i53] < this.pointRank) break;
            if (this.activeTo[i53] > to || this.activeTo[i53] == to && this.active[i53].endSide >= this.point.endSide) active.push(this.active[i53]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for(let i54 = this.activeTo.length - 1; i54 >= 0 && this.activeTo[i54] > to; i54--)open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for(;;){
        let diff = a.to + dPos - b.to || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
        } else {
            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB) break;
        pos = end;
        if (diff <= 0) a.next();
        if (diff >= 0) b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length) return false;
    for(let i55 = 0; i55 < a.length; i55++)if (a[i55] != b[i55] && !a[i55].eq(b[i55])) return false;
    return true;
}
function remove(array, index) {
    for(let i56 = index, e = array.length - 1; i56 < e; i56++)array[i56] = array[i56 + 1];
    array.pop();
}
function insert(array, index, value) {
    for(let i57 = array.length - 1; i57 >= index; i57--)array[i57 + 1] = array[i57];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = C.Far;
    for(let i58 = 0; i58 < array.length; i58++)if ((array[i58] - foundPos || value[i58].endSide - value[found].endSide) < 0) {
        found = i58;
        foundPos = array[i58];
    }
    return found;
}
function combineAttrs(source, target) {
    for(let name3 in source){
        if (name3 == "class" && target.class) target.class += " " + source.class;
        else if (name3 == "style" && target.style) target.style += ";" + source.style;
        else target[name3] = source[name3];
    }
    return target;
}
function attrsEq(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length) return false;
    for (let key of keysA){
        if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    if (prev) {
        for(let name4 in prev)if (!(attrs && name4 in attrs)) dom.removeAttribute(name4);
    }
    if (attrs) {
        for(let name5 in attrs)if (!(prev && prev[name5] == attrs[name5])) dom.setAttribute(name5, attrs[name5]);
    }
}
class WidgetType {
    eq(_widget) {
        return false;
    }
    updateDOM(_dom) {
        return false;
    }
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
        return -1;
    }
    ignoreEvent(_event) {
        return true;
    }
    get customView() {
        return null;
    }
    destroy(_dom) {}
}
var Side;
(function(Side2) {
    Side2[Side2["NonIncEnd"] = -600000000] = "NonIncEnd";
    Side2[Side2["BlockBefore"] = -500000000] = "BlockBefore";
    Side2[Side2["GapStart"] = -400000000] = "GapStart";
    Side2[Side2["BlockIncStart"] = -300000000] = "BlockIncStart";
    Side2[Side2["Line"] = -200000000] = "Line";
    Side2[Side2["InlineBefore"] = -100000000] = "InlineBefore";
    Side2[Side2["InlineIncStart"] = -1] = "InlineIncStart";
    Side2[Side2["InlineIncEnd"] = 1] = "InlineIncEnd";
    Side2[Side2["InlineAfter"] = 100000000] = "InlineAfter";
    Side2[Side2["BlockIncEnd"] = 200000000] = "BlockIncEnd";
    Side2[Side2["GapEnd"] = 300000000] = "GapEnd";
    Side2[Side2["BlockAfter"] = 400000000] = "BlockAfter";
    Side2[Side2["NonIncStart"] = 500000000] = "NonIncStart";
})(Side || (Side = {}));
var BlockType;
(function(BlockType1) {
    BlockType1[BlockType1["Text"] = 0] = "Text";
    BlockType1[BlockType1["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType1[BlockType1["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType1[BlockType1["WidgetRange"] = 3] = "WidgetRange";
})(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
    startSide;
    endSide;
    widget;
    spec;
    constructor(startSide, endSide, widget, spec){
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    get heightRelevant() {
        return false;
    }
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    static widget(spec) {
        let side = spec.side || 0, block = !!spec.block;
        side += block ? side > 0 ? Side.BlockAfter : Side.BlockBefore : side > 0 ? Side.InlineAfter : Side.InlineBefore;
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = Side.GapStart;
            endSide = Side.GapEnd;
        } else {
            let { start , end  } = getInclusive(spec, block);
            startSide = (start ? block ? Side.BlockIncStart : Side.InlineIncStart : Side.NonIncStart) - 1;
            endSide = (end ? block ? Side.BlockIncEnd : Side.InlineIncEnd : Side.NonIncEnd) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
        return new LineDecoration(spec);
    }
    static set(of, sort = false) {
        return RangeSet.of(of, sort);
    }
    static none = RangeSet.empty;
    hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
}
class MarkDecoration extends Decoration {
    tagName;
    class;
    attrs;
    constructor(spec){
        let { start , end  } = getInclusive(spec);
        super(start ? Side.InlineIncStart : Side.NonIncStart, end ? Side.InlineIncEnd : Side.NonIncEnd, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
        if (from >= to) throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec){
        super(Side.Line, Side.Line, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    block;
    isReplace;
    constructor(spec, startSide, endSide, block, widget, isReplace){
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
        return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start , inclusiveEnd: end  } = spec;
    if (start == null) start = spec.inclusive;
    if (end == null) end = spec.inclusive;
    return {
        start: start ?? block,
        end: end ?? block
    };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);
    else ranges.push(from, to);
}
var Direction;
(function(Direction1) {
    Direction1[Direction1["LTR"] = 0] = "LTR";
    Direction1[Direction1["RTL"] = 1] = "RTL";
})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
var T;
(function(T2) {
    T2[T2["L"] = 1] = "L";
    T2[T2["R"] = 2] = "R";
    T2[T2["AL"] = 4] = "AL";
    T2[T2["EN"] = 8] = "EN";
    T2[T2["AN"] = 16] = "AN";
    T2[T2["ET"] = 64] = "ET";
    T2[T2["CS"] = 128] = "CS";
    T2[T2["NI"] = 256] = "NI";
    T2[T2["NSM"] = 512] = "NSM";
    T2[T2["Strong"] = T2.L | T2.R | T2.AL] = "Strong";
    T2[T2["Num"] = T2.EN | T2.AN] = "Num";
})(T || (T = {}));
function dec(str) {
    let result = [];
    for(let i59 = 0; i59 < str.length; i59++)result.push(1 << +str[i59]);
    return result;
}
const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = Object.create(null), BracketStack = [];
for (let p of [
    "()",
    "[]",
    "{}"
]){
    let l = p.charCodeAt(0), r = p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
var Bracketed;
(function(Bracketed1) {
    Bracketed1[Bracketed1["OppositeBefore"] = 1] = "OppositeBefore";
    Bracketed1[Bracketed1["EmbedInside"] = 2] = "EmbedInside";
    Bracketed1[Bracketed1["OppositeInside"] = 4] = "OppositeInside";
    Bracketed1[Bracketed1["MaxDepth"] = 189] = "MaxDepth";
})(Bracketed || (Bracketed = {}));
function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? T.R : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? T.AL : 8192 <= ch && ch <= 8203 ? T.NI : ch == 8204 ? T.NI : T.L;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
class BidiSpan {
    from;
    to;
    level;
    constructor(from, to, level){
        this.from = from;
        this.to = to;
        this.level = level;
    }
    get dir() {
        return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
        return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
        let maybe = -1;
        for(let i60 = 0; i60 < order.length; i60++){
            let span1 = order[i60];
            if (span1.from <= index && span1.to >= index) {
                if (span1.level == level) return i60;
                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span1.from < index : span1.to > index : order[maybe].level > span1.level)) maybe = i60;
            }
        }
        if (maybe < 0) throw new RangeError("Index out of range");
        return maybe;
    }
}
const types = [];
function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? T.L : T.R, oppositeType = direction == LTR ? T.R : T.L;
    if (!line || outerType == T.L && !BidiRE.test(line)) return trivialOrder(len);
    for(let i61 = 0, prev = outerType, prevStrong = outerType; i61 < len; i61++){
        let type = charType(line.charCodeAt(i61));
        if (type == T.NSM) type = prev;
        else if (type == T.EN && prevStrong == T.AL) type = T.AN;
        types[i61] = type == T.AL ? T.R : type;
        if (type & T.Strong) prevStrong = type;
        prev = type;
    }
    for(let i112 = 0, prev1 = outerType, prevStrong1 = outerType; i112 < len; i112++){
        let type = types[i112];
        if (type == T.CS) {
            if (i112 < len - 1 && prev1 == types[i112 + 1] && prev1 & T.Num) type = types[i112] = prev1;
            else types[i112] = T.NI;
        } else if (type == T.ET) {
            let end = i112 + 1;
            while(end < len && types[end] == T.ET)end++;
            let replace = i112 && prev1 == T.EN || end < len && types[end] == T.EN ? prevStrong1 == T.L ? T.L : T.EN : T.NI;
            for(let j = i112; j < end; j++)types[j] = replace;
            i112 = end - 1;
        } else if (type == T.EN && prevStrong1 == T.L) {
            types[i112] = T.L;
        }
        prev1 = type;
        if (type & T.Strong) prevStrong1 = type;
    }
    for(let i210 = 0, sI = 0, context = 0, ch, br, type; i210 < len; i210++){
        if (br = Brackets[ch = line.charCodeAt(i210)]) {
            if (br < 0) {
                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){
                    if (BracketStack[sJ + 1] == -br) {
                        let flags = BracketStack[sJ + 2];
                        let type = flags & Bracketed.EmbedInside ? outerType : !(flags & Bracketed.OppositeInside) ? 0 : flags & Bracketed.OppositeBefore ? oppositeType : outerType;
                        if (type) types[i210] = types[BracketStack[sJ]] = type;
                        sI = sJ;
                        break;
                    }
                }
            } else if (BracketStack.length == Bracketed.MaxDepth) {
                break;
            } else {
                BracketStack[sI++] = i210;
                BracketStack[sI++] = ch;
                BracketStack[sI++] = context;
            }
        } else if ((type = types[i210]) == T.R || type == T.L) {
            let embed = type == outerType;
            context = embed ? 0 : Bracketed.OppositeBefore;
            for(let sJ = sI - 3; sJ >= 0; sJ -= 3){
                let cur7 = BracketStack[sJ + 2];
                if (cur7 & Bracketed.EmbedInside) break;
                if (embed) {
                    BracketStack[sJ + 2] |= Bracketed.EmbedInside;
                } else {
                    if (cur7 & Bracketed.OppositeInside) break;
                    BracketStack[sJ + 2] |= Bracketed.OppositeInside;
                }
            }
        }
    }
    for(let i3 = 0; i3 < len; i3++){
        if (types[i3] == T.NI) {
            let end = i3 + 1;
            while(end < len && types[end] == T.NI)end++;
            let beforeL = (i3 ? types[i3 - 1] : outerType) == T.L;
            let afterL = (end < len ? types[end] : outerType) == T.L;
            let replace = beforeL == afterL ? beforeL ? T.L : T.R : outerType;
            for(let j = i3; j < end; j++)types[j] = replace;
            i3 = end - 1;
        }
    }
    let order = [];
    if (outerType == T.L) {
        for(let i62 = 0; i62 < len;){
            let start = i62, rtl = types[i62++] != T.L;
            while(i62 < len && rtl == (types[i62] != T.L))i62++;
            if (rtl) {
                for(let j = i62; j > start;){
                    let end = j, l = types[--j] != T.R;
                    while(j > start && l == (types[j - 1] != T.R))j--;
                    order.push(new BidiSpan(j, end, l ? 2 : 1));
                }
            } else {
                order.push(new BidiSpan(start, i62, 0));
            }
        }
    } else {
        for(let i63 = 0; i63 < len;){
            let start = i63, rtl = types[i63++] == T.R;
            while(i63 < len && rtl == (types[i63] == T.R))i63++;
            order.push(new BidiSpan(start, i63, rtl ? 1 : 2));
        }
    }
    return order;
}
function trivialOrder(length) {
    return [
        new BidiSpan(0, length, 0)
    ];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
        if (!forward || !line.length) return null;
        if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
        }
    } else if (startIndex == line.length) {
        if (forward) return null;
        let last = order[order.length - 1];
        if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
        }
    }
    if (spanI < 0) spanI = BidiSpan.find(order, startIndex, start.bidiLevel ?? -1, start.assoc);
    let span2 = order[spanI];
    if (startIndex == span2.side(forward, dir)) {
        span2 = order[spanI += forward ? 1 : -1];
        startIndex = span2.side(!forward, dir);
    }
    let indexForward = forward == (span2.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span2.side(forward, dir)) return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span2.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span2.level != dir) return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span2.level) return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span2.level);
}
const wrappingWhiteSpace = [
    "pre-wrap",
    "normal",
    "pre-line",
    "break-spaces"
];
class HeightOracle {
    doc = Text.empty;
    lineWrapping = false;
    direction = Direction.LTR;
    heightSamples = {};
    lineHeight = 14;
    charWidth = 7;
    lineLength = 30;
    heightChanged = false;
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping) return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc5) {
        this.doc = doc5;
        return this;
    }
    mustRefreshForStyle(whiteSpace, direction) {
        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for(let i64 = 0; i64 < lineHeights.length; i64++){
            let h = lineHeights[i64];
            if (h < 0) {
                i64++;
            } else if (!this.heightSamples[Math.floor(h * 10)]) {
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
        this.lineWrapping = lineWrapping;
        this.direction = direction;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for(let i65 = 0; i65 < knownHeights.length; i65++){
                let h = knownHeights[i65];
                if (h < 0) i65++;
                else this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
class MeasuredHeights {
    from;
    heights;
    index = 0;
    constructor(from, heights){
        this.from = from;
        this.heights = heights;
    }
    get more() {
        return this.index < this.heights.length;
    }
}
class BlockInfo {
    from;
    length;
    top;
    height;
    type;
    constructor(from, length, top3, height, type){
        this.from = from;
        this.length = length;
        this.top = top3;
        this.height = height;
        this.type = type;
    }
    get to() {
        return this.from + this.length;
    }
    get bottom() {
        return this.top + this.height;
    }
    join(other) {
        let detail = (Array.isArray(this.type) ? this.type : [
            this
        ]).concat(Array.isArray(other.type) ? other.type : [
            other
        ]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
    moveY(offset) {
        return !offset ? this : new BlockInfo(this.from, this.length, this.top + offset, this.height, Array.isArray(this.type) ? this.type.map((b)=>b.moveY(offset)
        ) : this.type);
    }
}
var QueryType;
(function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
})(QueryType || (QueryType = {}));
var Flag;
(function(Flag1) {
    Flag1[Flag1["Break"] = 1] = "Break";
    Flag1[Flag1["Outdated"] = 2] = "Outdated";
    Flag1[Flag1["SingleLine"] = 4] = "SingleLine";
})(Flag || (Flag = {}));
const Epsilon = 0.001;
class HeightMap {
    length;
    height;
    flags;
    constructor(length, height, flags = Flag.Outdated){
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    size;
    get outdated() {
        return (this.flags & Flag.Outdated) > 0;
    }
    set outdated(value) {
        this.flags = (value ? Flag.Outdated : 0) | this.flags & ~Flag.Outdated;
    }
    setHeight(oracle, height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > 0.001) oracle.heightChanged = true;
            this.height = height;
        }
    }
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
        result.push(this);
    }
    decomposeRight(_from, result) {
        result.push(this);
    }
    applyChanges(decorations1, oldDoc, oracle, changes) {
        let me = this;
        for(let i66 = changes.length - 1; i66 >= 0; i66--){
            let { fromA , toA , fromB , toB  } = changes[i66];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while(i66 > 0 && start.from <= changes[i66 - 1].toA){
                fromA = changes[i66 - 1].fromA;
                fromB = changes[i66 - 1].fromB;
                i66--;
                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle, decorations1, fromB, toB);
            me = me.replace(fromA, toA, nodes);
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() {
        return new HeightMapText(0, 0);
    }
    static of(nodes) {
        if (nodes.length == 1) return nodes[0];
        let i67 = 0, j = nodes.length, before = 0, after = 0;
        for(;;){
            if (i67 == j) {
                if (before > after * 2) {
                    let split = nodes[i67 - 1];
                    if (split.break) nodes.splice(--i67, 1, split.left, null, split.right);
                    else nodes.splice(--i67, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                } else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);
                    else nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                } else {
                    break;
                }
            } else if (before < after) {
                let next = nodes[i67++];
                if (next) before += next.size;
            } else {
                let next = nodes[--j];
                if (next) after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i67 - 1] == null) {
            brk = 1;
            i67--;
        } else if (nodes[i67] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i67)), brk, HeightMap.of(nodes.slice(j)));
    }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    type;
    constructor(length, height, type){
        super(length, height);
        this.type = type;
    }
    blockAt(_height, _doc, top4, offset) {
        return new BlockInfo(offset, this.length, top4, this.height, this.type);
    }
    lineAt(_value, _type, doc6, top5, offset) {
        return this.blockAt(0, doc6, top5, offset);
    }
    forEachLine(_from, _to, doc7, top6, offset, f) {
        f(this.blockAt(0, doc7, top6, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() {
        return `block(${this.length})`;
    }
}
class HeightMapText extends HeightMapBlock {
    collapsed = 0;
    widgetHeight = 0;
    constructor(length, height){
        super(length, height, BlockType.Text);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & Flag.SingleLine) && Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);
            else node.height = this.height;
            if (!this.outdated) node.outdated = false;
            return node;
        } else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);
        else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length){
        super(length, 0);
    }
    lines(doc8, offset) {
        let firstLine = doc8.lineAt(offset).number, lastLine = doc8.lineAt(offset + this.length).number;
        return {
            firstLine,
            lastLine,
            lineHeight: this.height / (lastLine - firstLine + 1)
        };
    }
    blockAt(height, doc9, top7, offset) {
        let { firstLine , lastLine , lineHeight  } = this.lines(doc9, offset);
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top7) / lineHeight)));
        let { from , length  } = doc9.line(firstLine + line);
        return new BlockInfo(from, length, top7 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc10, top8, offset) {
        if (type == QueryType.ByHeight) return this.blockAt(value, doc10, top8, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from , to  } = doc10.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
        }
        let { firstLine , lineHeight  } = this.lines(doc10, offset);
        let { from , length , number: number2  } = doc10.lineAt(value);
        return new BlockInfo(from, length, top8 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc11, top9, offset, f) {
        let { firstLine , lineHeight  } = this.lines(doc11, offset);
        for(let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;){
            let line = doc11.lineAt(pos);
            if (pos == from) top9 += lineHeight * (line.number - firstLine);
            f(new BlockInfo(line.from, line.length, top9, lineHeight, BlockType.Text));
            top9 += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);
            else nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            let wasChanged = oracle.heightChanged;
            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while(pos <= end && measured.more){
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length) nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1) singleHeight = height;
                else if (Math.abs(height - singleHeight) >= 0.001) singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
            return result;
        } else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() {
        return `gap(${this.length})`;
    }
}
class HeightMapBranch extends HeightMap {
    left;
    right;
    size;
    constructor(left, brk, right){
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? Flag.Outdated : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() {
        return this.flags & Flag.Break;
    }
    blockAt(height, doc12, top10, offset) {
        let mid = top10 + this.left.height;
        return height < mid ? this.left.blockAt(height, doc12, top10, offset) : this.right.blockAt(height, doc12, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc13, top11, offset) {
        let rightTop = top11 + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base4 = left ? this.left.lineAt(value, type, doc13, top11, offset) : this.right.lineAt(value, type, doc13, rightTop, rightOffset);
        if (this.break || (left ? base4.to < rightOffset : base4.from > rightOffset)) return base4;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left) return base4.join(this.right.lineAt(rightOffset, subQuery, doc13, rightTop, rightOffset));
        else return this.left.lineAt(rightOffset, subQuery, doc13, top11, offset).join(base4);
    }
    forEachLine(from, to, doc14, top12, offset, f) {
        let rightTop = top12 + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset) this.left.forEachLine(from, to, doc14, top12, offset, f);
            if (to >= rightOffset) this.right.forEachLine(from, to, doc14, rightTop, rightOffset, f);
        } else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc14, top12, offset);
            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc14, top12, offset, f);
            if (mid.to >= from && mid.from <= to) f(mid);
            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc14, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0) this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)result.push(node);
        if (from > 0) mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left) return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left) result.push(null);
        }
        if (to > left) this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right) return this.right.decomposeRight(from - right, result);
        if (from < left) this.left.decomposeRight(from, result);
        if (this.break && from < right) result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [
            left,
            null,
            right
        ] : [
            left,
            right
        ]);
        this.left = left;
        this.right = right;
        this.height = left.height + right.height;
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left , right  } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else right.updateHeight(oracle, rightStart, force);
        if (rebalance) return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() {
        return this.left + (this.break ? " " : "-") + this.right;
    }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
class NodeBuilder {
    pos;
    oracle;
    nodes = [];
    writtenTo;
    lineStart = -1;
    lineEnd = -1;
    covering = null;
    constructor(pos, oracle){
        this.pos = pos;
        this.oracle = oracle;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText) last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            if (height < 0) height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco.type));
            } else if (len || height >= 5) {
                this.addLineDeco(height, len);
            }
        } else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1) return;
        let { from , to  } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= Flag.SingleLine;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText) return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (block.type != BlockType.WidgetBefore) this.covering = block;
    }
    addLineDeco(height, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes){
            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
        let builder = new NodeBuilder(from, oracle);
        RangeSet.spans(decorations2, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    changes = [];
    compareRange() {}
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);
    }
}
const none1 = [];
const clickAddsSelectionRange = Facet.define();
const dragMovesSelection = Facet.define();
const mouseSelectionStyle = Facet.define();
const exceptionSink = Facet.define();
const updateListener = Facet.define();
const inputHandler = Facet.define();
const scrollTo = StateEffect.define({
    map: (range, changes)=>range.map(changes)
});
const centerOn = StateEffect.define({
    map: (range, changes)=>range.map(changes)
});
class ScrollTarget {
    range;
    y;
    x;
    yMargin;
    xMargin;
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5){
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
    }
    map(changes) {
        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
}
const scrollIntoView = StateEffect.define({
    map: (t1, ch)=>t1.map(ch)
});
function logException(state25, exception, context) {
    let handler = state25.facet(exceptionSink);
    if (handler.length) handler[0](exception);
    else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context) console.error(context + ":", exception);
    else console.error(exception);
}
const editable = Facet.define({
    combine: (values9)=>values9.length ? values9[0] : true
});
class PluginFieldProvider {
    field;
    get;
    constructor(field, get5){
        this.field = field;
        this.get = get5;
    }
}
class PluginField {
    from(get6) {
        return new PluginFieldProvider(this, get6);
    }
    static define() {
        return new PluginField();
    }
    static decorations = PluginField.define();
    static atomicRanges = PluginField.define();
    static scrollMargins = PluginField.define();
}
let nextPluginID = 0;
const viewPlugin = Facet.define();
class ViewPlugin {
    id;
    create;
    fields;
    extension;
    constructor(id4, create, fields){
        this.id = id4;
        this.create = create;
        this.fields = fields;
        this.extension = viewPlugin.of(this);
    }
    static define(create, spec) {
        let { eventHandlers , provide , decorations: decorations1  } = spec || {};
        let fields = [];
        if (provide) for (let provider of Array.isArray(provide) ? provide : [
            provide
        ])fields.push(provider);
        if (eventHandlers) fields.push(domEventHandlers.from((value)=>({
                plugin: value,
                handlers: eventHandlers
            })
        ));
        if (decorations1) fields.push(PluginField.decorations.from(decorations1));
        return new ViewPlugin(nextPluginID++, create, fields);
    }
    static fromClass(cls, spec) {
        return ViewPlugin.define((view)=>new cls(view)
        , spec);
    }
}
const domEventHandlers = PluginField.define();
class PluginInstance {
    spec;
    mustUpdate = null;
    value = null;
    constructor(spec){
        this.spec = spec;
    }
    takeField(type, target) {
        if (this.spec) {
            for (let { field , get: get7  } of this.spec.fields)if (field == type) target.push(get7(this.value));
        }
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                } catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        } else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                } catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy) try {
                        this.value.destroy();
                    } catch (_) {}
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        if (this.value?.destroy) {
            try {
                this.value.destroy();
            } catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = Facet.define();
const contentAttributes = Facet.define();
const decorations = Facet.define();
const styleModule = Facet.define();
var UpdateFlag;
(function(UpdateFlag1) {
    UpdateFlag1[UpdateFlag1["Focus"] = 1] = "Focus";
    UpdateFlag1[UpdateFlag1["Height"] = 2] = "Height";
    UpdateFlag1[UpdateFlag1["Viewport"] = 4] = "Viewport";
    UpdateFlag1[UpdateFlag1["Geometry"] = 8] = "Geometry";
})(UpdateFlag || (UpdateFlag = {}));
class ChangedRange {
    fromA;
    toA;
    fromB;
    toB;
    constructor(fromA, toA, fromB, toB){
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i68 = set.length, me = this;
        for(; i68 > 0; i68--){
            let range = set[i68 - 1];
            if (range.fromA > me.toA) continue;
            if (range.toA < me.fromA) break;
            me = me.join(range);
            set.splice(i68 - 1, 1);
        }
        set.splice(i68, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0) return diff;
        let result = [];
        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1000000000;
            while(rI < ranges.length && ranges[rI] < end){
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end) break;
                else rI += 2;
            }
            if (!next) return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
class ViewUpdate {
    view;
    state;
    transactions;
    changes;
    startState;
    flags = 0;
    changedRanges;
    constructor(view, state26, transactions = none1){
        this.view = view;
        this.state = state26;
        this.transactions = transactions;
        this.startState = view.state;
        this.changes = ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB))
        );
        this.changedRanges = changedRanges;
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            view.inputState.notifiedFocused = focus;
            this.flags |= UpdateFlag.Focus;
        }
    }
    get viewportChanged() {
        return (this.flags & UpdateFlag.Viewport) > 0;
    }
    get heightChanged() {
        return (this.flags & UpdateFlag.Height) > 0;
    }
    get geometryChanged() {
        return this.docChanged || (this.flags & (UpdateFlag.Geometry | UpdateFlag.Height)) > 0;
    }
    get focusChanged() {
        return (this.flags & UpdateFlag.Focus) > 0;
    }
    get docChanged() {
        return !this.changes.empty;
    }
    get selectionSet() {
        return this.transactions.some((tr)=>tr.selection
        );
    }
    get empty() {
        return this.flags == 0 && this.transactions.length == 0;
    }
}
const C1 = "\u037c";
const COUNT = typeof Symbol == "undefined" ? "__" + C1 : Symbol.for(C1);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 100000000) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
    constructor(spec1, options){
        this.rules = [];
        let { finish: finish1  } = options || {};
        function splitSelector(selector) {
            return /^@/.test(selector) ? [
                selector
            ] : selector.split(/,\s*/);
        }
        function render(selectors, spec, target, isKeyframes) {
            let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
            if (isAt && spec == null) return target.push(selectors[0] + ";");
            for(let prop in spec){
                let value = spec[prop];
                if (/&/.test(prop)) {
                    render(prop.split(/,\s*/).map((part)=>selectors.map((sel)=>part.replace(/&/, sel)
                        )
                    ).reduce((a, b)=>a.concat(b)
                    ), value, target);
                } else if (value && typeof value == "object") {
                    if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
                    render(splitSelector(prop), value, local, keyframes);
                } else if (value != null) {
                    local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l)=>"-" + l.toLowerCase()
                    ) + ": " + value + ";");
                }
            }
            if (local.length || keyframes) {
                target.push((finish1 && !isAt && !isKeyframes ? selectors.map(finish1) : selectors).join(", ") + " {" + local.join(" ") + "}");
            }
        }
        for(let prop1 in spec1)render(splitSelector(prop1), spec1[prop1], this.rules);
    }
    getRules() {
        return this.rules.join("\n");
    }
    static newName() {
        let id5 = top[COUNT] || 1;
        top[COUNT] = id5 + 1;
        return C1 + id5.toString(36);
    }
    static mount(root, modules1) {
        (root[SET] || new StyleSet(root)).mount(Array.isArray(modules1) ? modules1 : [
            modules1
        ]);
    }
}
let adoptedSet = null;
class StyleSet {
    constructor(root){
        if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
            if (adoptedSet) {
                root.adoptedStyleSheets = [
                    adoptedSet.sheet
                ].concat(root.adoptedStyleSheets);
                return root[SET] = adoptedSet;
            }
            this.sheet = new CSSStyleSheet;
            root.adoptedStyleSheets = [
                this.sheet
            ].concat(root.adoptedStyleSheets);
            adoptedSet = this;
        } else {
            this.styleTag = (root.ownerDocument || root).createElement("style");
            let target = root.head || root;
            target.insertBefore(this.styleTag, target.firstChild);
        }
        this.modules = [];
        root[SET] = this;
    }
    mount(modules2) {
        let sheet = this.sheet;
        let pos = 0, j = 0;
        for(let i69 = 0; i69 < modules2.length; i69++){
            let mod49 = modules2[i69], index = this.modules.indexOf(mod49);
            if (index < j && index > -1) {
                this.modules.splice(index, 1);
                j--;
                index = -1;
            }
            if (index == -1) {
                this.modules.splice(j++, 0, mod49);
                if (sheet) for(let k = 0; k < mod49.rules.length; k++)sheet.insertRule(mod49.rules[k], pos++);
            } else {
                while(j < index)pos += this.modules[j++].rules.length;
                pos += mod49.rules.length;
                j++;
            }
        }
        if (!sheet) {
            let text = "";
            for(let i70 = 0; i70 < this.modules.length; i70++)text += this.modules[i70].getRules() + "\n";
            this.styleTag.textContent = text;
        }
    }
}
function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
        target = root.getSelection ? root : root.ownerDocument;
    } else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement() {
    let elt1 = document.activeElement;
    while(elt1 && elt1.shadowRoot)elt1 = elt1.shadowRoot.activeElement;
    return elt1;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode) return false;
    try {
        return contains(dom, selection.anchorNode);
    } catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1) return dom.getClientRects();
    else return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
    for(var index = 0;; index++){
        node = node.previousSibling;
        if (!node) return index;
    }
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for(;;){
        if (node == targetNode && off == targetOff) return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV") return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1) return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        } else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false") return false;
            off = dir < 0 ? maxOffset(node) : 0;
        } else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
const Rect0 = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
};
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return {
        left: x,
        right: x,
        top: rect.top,
        bottom: rect.bottom
    };
}
function windowRect(win) {
    return {
        left: 0,
        right: win.innerWidth,
        top: 0,
        bottom: win.innerHeight
    };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc15 = dom.ownerDocument, win = doc15.defaultView;
    for(let cur8 = dom; cur8;){
        if (cur8.nodeType == 1) {
            let bounding, top13 = cur8 == doc15.body;
            if (top13) {
                bounding = windowRect(win);
            } else {
                if (cur8.scrollHeight <= cur8.clientHeight && cur8.scrollWidth <= cur8.clientWidth) {
                    cur8 = cur8.parentNode;
                    continue;
                }
                let rect = cur8.getBoundingClientRect();
                bounding = {
                    left: rect.left,
                    right: rect.left + cur8.clientWidth,
                    top: rect.top,
                    bottom: rect.top + cur8.clientHeight
                };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = -(bounding.top - rect.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                } else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);
                }
            } else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = -(bounding.left - rect.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;
                } else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);
                }
            } else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top13) {
                    win.scrollBy(moveX, moveY);
                } else {
                    if (moveY) {
                        let start = cur8.scrollTop;
                        cur8.scrollTop += moveY;
                        moveY = cur8.scrollTop - start;
                    }
                    if (moveX) {
                        let start = cur8.scrollLeft;
                        cur8.scrollLeft += moveX;
                        moveX = cur8.scrollLeft - start;
                    }
                    rect = {
                        left: rect.left - moveX,
                        top: rect.top - moveY,
                        right: rect.right - moveX,
                        bottom: rect.bottom - moveY
                    };
                }
            }
            if (top13) break;
            cur8 = cur8.assignedSlot || cur8.parentNode;
            x = y = "nearest";
        } else if (cur8.nodeType == 11) {
            cur8 = cur8.host;
        } else {
            break;
        }
    }
}
class DOMSelectionState {
    anchorNode = null;
    anchorOffset = 0;
    focusNode = null;
    focusOffset = 0;
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
    if (dom.setActive) return dom.setActive();
    if (preventScrollSupported) return dom.focus(preventScrollSupported);
    let stack = [];
    for(let cur9 = dom; cur9; cur9 = cur9.parentNode){
        stack.push(cur9, cur9.scrollTop, cur9.scrollLeft);
        if (cur9 == cur9.ownerDocument) break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll () {
            preventScrollSupported = {
                preventScroll: true
            };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for(let i71 = 0; i71 < stack.length;){
            let elt2 = stack[i71++], top14 = stack[i71++], left = stack[i71++];
            if (elt2.scrollTop != top14) elt2.scrollTop = top14;
            if (elt2.scrollLeft != left) elt2.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt3, name6, code5) {
    let options = {
        key: name6,
        code: name6,
        keyCode: code5,
        which: code5,
        cancelable: true
    };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt3.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt3.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while(node){
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);
}
var Dirty;
(function(Dirty1) {
    Dirty1[Dirty1["Not"] = 0] = "Not";
    Dirty1[Dirty1["Child"] = 1] = "Child";
    Dirty1[Dirty1["Node"] = 2] = "Node";
    Dirty1[Dirty1["Attrs"] = 4] = "Attrs";
})(Dirty || (Dirty = {}));
class DOMPos {
    node;
    offset;
    precise;
    constructor(node, offset, precise = true){
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
}
const noChildren = [];
class ContentView {
    parent = null;
    dom = null;
    dirty = Dirty.Node;
    length;
    children;
    breakAfter;
    get editorView() {
        if (!this.parent) throw new Error("Accessing view in orphan content view");
        return this.parent.editorView;
    }
    get overrideDOMText() {
        return null;
    }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children){
            if (child == view) return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
        return null;
    }
    sync(track) {
        if (this.dirty & Dirty.Node) {
            let parent = this.dom;
            let pos = parent.firstChild;
            for (let child of this.children){
                if (child.dirty) {
                    if (!child.dom && pos) {
                        let contentView = ContentView.get(pos);
                        if (!contentView || !contentView.parent && contentView.constructor == child.constructor) child.reuseDOM(pos);
                    }
                    child.sync(track);
                    child.dirty = Dirty.Not;
                }
                if (track && !track.written && track.node == parent && pos != child.dom) track.written = true;
                if (child.dom.parentNode == parent) {
                    while(pos && pos != child.dom)pos = rm(pos);
                    pos = child.dom.nextSibling;
                } else {
                    parent.insertBefore(child.dom, pos);
                }
            }
            if (pos && track && track.node == parent) track.written = true;
            while(pos)pos = rm(pos);
        } else if (this.dirty & Dirty.Child) {
            for (let child of this.children)if (child.dirty) {
                child.sync(track);
                child.dirty = Dirty.Not;
            }
        }
    }
    reuseDOM(_dom) {}
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        } else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for(;;){
                let parent = node.parentNode;
                if (parent == this.dom) break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild) bias = -1;
                    else bias = 1;
                }
                node = parent;
            }
            if (bias < 0) after = node;
            else after = node.nextSibling;
        }
        if (after == this.dom.firstChild) return 0;
        while(after && !ContentView.get(after))after = after.nextSibling;
        if (!after) return this.length;
        for(let i72 = 0, pos = 0;; i72++){
            let child = this.children[i72];
            if (child.dom == after) return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for(let i73 = 0, pos = offset, prevEnd = offset; i73 < this.children.length; i73++){
            let child = this.children[i73], end = pos + child.length;
            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i73;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i73;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return {
            from: fromStart,
            to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
        };
    }
    markDirty(andParent = false) {
        this.dirty |= Dirty.Node;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for(let parent = this.parent; parent; parent = parent.parent){
            if (childList) parent.dirty |= Dirty.Node;
            if (parent.dirty & Dirty.Child) return;
            parent.dirty |= Dirty.Child;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.dirty) this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom) this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for(let v = this;;){
            let parent = v.parent;
            if (!parent) return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for(let i74 = from; i74 < to; i74++){
            let child = this.children[i74];
            if (child.parent == this) child.destroy();
        }
        this.children.splice(from, to - from, ...children);
        for(let i113 = 0; i113 < children.length; i113++)children[i113].setParent(this);
    }
    ignoreMutation(_rec) {
        return false;
    }
    ignoreEvent(_event) {
        return false;
    }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name7 = this.constructor.name.replace("View", "");
        return name7 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name7 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
        return node.cmView;
    }
    get isEditable() {
        return true;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) {
        return false;
    }
    getSide() {
        return 0;
    }
    destroy() {
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    children;
    pos;
    i;
    off = 0;
    constructor(children, pos, i75){
        this.children = children;
        this.pos = pos;
        this.i = i75;
    }
    findPos(pos, bias = 1) {
        for(;;){
            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert4, breakAtStart, openStart, openEnd) {
    let { children  } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert4.length ? insert4[insert4.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert4.length < 2 && before.merge(fromOff, toOff, insert4.length ? last : null, fromOff == 0, openStart, openEnd)) return;
    if (toI < children.length) {
        let after = children[toI];
        if (after && toOff < after.length) {
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert4[insert4.length - 1] = after;
            } else {
                if (toOff) after.merge(0, toOff, null, false, 0, openEnd);
                insert4.push(after);
            }
        } else if (after?.breakAfter) {
            if (last) last.breakAfter = 1;
            else breakAtStart = 1;
        }
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert4.length && before.merge(fromOff, before.length, insert4[0], false, openStart, 0)) {
                before.breakAfter = insert4.shift().breakAfter;
            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    while(fromI < toI && insert4.length){
        if (children[toI - 1].become(insert4[insert4.length - 1])) {
            toI--;
            insert4.pop();
            openEnd = insert4.length ? 0 : openStart;
        } else if (children[fromI].become(insert4[0])) {
            fromI++;
            insert4.shift();
            openStart = insert4.length ? 0 : openEnd;
        } else {
            break;
        }
    }
    if (!insert4.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;
    if (fromI < toI || insert4.length) parent.replaceChildren(fromI, toI, insert4);
}
function mergeChildrenInto(parent, from, to, insert5, openStart, openEnd) {
    let cur10 = parent.childCursor();
    let { i: toI , off: toOff  } = cur10.findPos(to, 1);
    let { i: fromI , off: fromOff  } = cur10.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert5)dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert5, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
};
let doc = typeof document != "undefined" ? document : {
    documentElement: {
        style: {}
    }
};
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /MSIE \d/.test(nav.userAgent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
const __default = {
    mac: ios || /Mac/.test(nav.platform),
    windows: /Win/.test(nav.platform),
    linux: /Linux|X11/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [
        0,
        0
    ])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [
        0,
        0
    ])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
class TextView extends ContentView {
    text;
    children;
    constructor(text){
        super();
        this.text = text;
    }
    get length() {
        return this.text.length;
    }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
        if (!this.dom) this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom) track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3) this.createDOM(dom);
    }
    merge(from, to, source) {
        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > 256)) return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
        return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
        return {
            from: offset,
            to: offset + this.length,
            startDOM: this.dom,
            endDOM: this.dom.nextSibling
        };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    mark;
    children;
    length;
    constructor(mark, children = [], length = 0){
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class) dom.className = this.mark.class;
        if (this.mark.attrs) for(let name8 in this.mark.attrs)dom.setAttribute(name8, this.mark.attrs[name8]);
        return dom;
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.dirty |= Dirty.Attrs | Dirty.Node;
        }
    }
    sync(track) {
        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.dirty & Dirty.Attrs) this.setAttrs(this.dom);
        super.sync(track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i76 = 0;
        for (let elt4 of this.children){
            let end = off + elt4.length;
            if (end > from) result.push(off < from ? elt4.split(from - off) : elt4);
            if (detachFrom < 0 && off >= from) detachFrom = i76;
            off = end;
            i76++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this.dom, this.children, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length) pos = length;
    let from = pos, to = pos, flatten1 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(__default.chrome || __default.gecko)) {
            if (pos) {
                from--;
                flatten1 = 1;
            } else {
                to++;
                flatten1 = -1;
            }
        }
    } else {
        if (side < 0) from--;
        else to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length) return Rect0;
    let rect = rects[(flatten1 ? flatten1 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (__default.safari && !flatten1 && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width
    ) || rect;
    return flatten1 ? flattenRect(rect, flatten1 < 0) : rect || null;
}
class WidgetView extends ContentView {
    widget;
    length;
    side;
    children;
    prevWidget = null;
    static create(widget, length, side) {
        return new (widget.customView || WidgetView)(widget, length, side);
    }
    constructor(widget, length, side){
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    getSide() {
        return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
            if (this.widget.constructor == other.widget.constructor) {
                if (!this.widget.eq(other.widget)) this.markDirty(true);
                if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
                this.widget = other.widget;
                return true;
            }
        }
        return false;
    }
    ignoreMutation() {
        return true;
    }
    ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
        if (this.length == 0) return Text.empty;
        let top15 = this;
        while(top15.parent)top15 = top15.parent;
        let view = top15.editorView, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
        return null;
    }
    coordsAt(pos, side) {
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length) return Rect0;
        for(let i77 = pos > 0 ? rects.length - 1 : 0;; i77 += pos > 0 ? -1 : 1){
            rect = rects[i77];
            if (pos > 0 ? i77 == 0 : i77 == rects.length - 1 || rect.top < rect.bottom) break;
        }
        return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
    }
    get isEditable() {
        return false;
    }
    destroy() {
        super.destroy();
        if (this.dom) this.widget.destroy(this.dom);
    }
}
class CompositionView extends WidgetView {
    domAtPos(pos) {
        let { topView  } = this.widget;
        if (!topView) return new DOMPos(this.widget.text, Math.min(pos, this.widget.text.nodeValue.length));
        return posInCompositionTree(pos, topView, this.widget.text);
    }
    sync() {
        this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
        return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
    }
    ignoreMutation() {
        return false;
    }
    get overrideDOMText() {
        return null;
    }
    coordsAt(pos, side) {
        return textCoords(this.widget.text, pos, side);
    }
    destroy() {
        super.destroy();
        this.widget.topView?.destroy();
    }
    get isEditable() {
        return true;
    }
}
function posInCompositionTree(pos, view, text) {
    if (view instanceof MarkView) {
        for (let child of view.children){
            let hasComp = child.dom == text || child.dom.contains(text.parentNode);
            let len = hasComp ? text.nodeValue.length : child.length;
            if (pos < len || pos == len && child.getSide() <= 0) return hasComp ? posInCompositionTree(pos, child, text) : child.domAtPos(pos);
            pos -= len;
        }
        return view.domAtPos(view.length);
    } else if (view.dom == text) {
        return new DOMPos(text, Math.min(pos, text.nodeValue.length));
    } else {
        return view.domAtPos(pos);
    }
}
class WidgetBufferView extends ContentView {
    side;
    children;
    constructor(side){
        super();
        this.side = side;
    }
    get length() {
        return 0;
    }
    merge() {
        return false;
    }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
        return new WidgetBufferView(this.side);
    }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            this.setDOM(dom);
        }
    }
    getSide() {
        return this.side;
    }
    domAtPos(pos) {
        return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
        return 0;
    }
    domBoundsAround() {
        return null;
    }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return Text.empty;
    }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(dom, children, pos) {
    let i78 = 0;
    for(let off = 0; i78 < children.length; i78++){
        let child = children[i78], end = off + child.length;
        if (end == off && child.getSide() <= 0) continue;
        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
        if (pos <= off) break;
        off = end;
    }
    for(; i78 > 0; i78--){
        let before = children[i78 - 1].dom;
        if (before.parentNode == dom) return DOMPos.after(before);
    }
    return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
    let last, { children  } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    } else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    for(let off = 0, i79 = 0; i79 < view.children.length; i79++){
        let child = view.children[i79], end = off + child.length, next;
        if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i79 + 1 == view.children.length || (next = view.children[i79 + 1]).length || next.getSide() > 0)) {
            let flatten2 = 0;
            if (end == off) {
                if (child.getSide() <= 0) continue;
                flatten2 = side = -child.getSide();
            }
            let rect = child.coordsAt(Math.max(0, pos - off), side);
            return flatten2 && rect ? flattenRect(rect, side < 0) : rect;
        }
        off = end;
    }
    let last = view.dom.lastChild;
    if (!last) return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}
class LineView extends ContentView {
    children = [];
    length = 0;
    prevAttrs = undefined;
    attrs = null;
    breakAfter = 0;
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView)) return false;
            if (!this.dom) source.transferDOM(this);
        }
        if (hasStart) this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0) return end;
        let { i: i80 , off  } = this.childPos(at);
        if (off) {
            end.append(this.children[i80].split(off), 0);
            this.children[i80].merge(off, this.children[i80].length, null, false, 0, 0);
            i80++;
        }
        for(let j = i80; j < this.children.length; j++)end.append(this.children[j], 0);
        while(i80 > 0 && this.children[i80 - 1].length == 0)this.children[--i80].destroy();
        this.children.length = i80;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom) return;
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls) this.attrs = combineAttrs({
            class: cls
        }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this.dom, this.children, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.dirty |= Dirty.Attrs | Dirty.Node;
        }
    }
    sync(track) {
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        } else if (this.dirty & Dirty.Attrs) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(track);
        let last = this.dom.lastChild;
        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;
        if (!last || last.nodeName != "BR" && ContentView.get(last)?.isEditable == false && (!__default.ios || !this.children.some((ch)=>ch instanceof TextView
        ))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20) return null;
        let totalWidth = 0;
        for (let child of this.children){
            if (!(child instanceof TextView)) return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1) return null;
            totalWidth += rects[0].width;
        }
        return {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length
        };
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
    become(_other) {
        return false;
    }
    get type() {
        return BlockType.Text;
    }
    static find(docView, pos) {
        for(let i81 = 0, off = 0; i81 < docView.children.length; i81++){
            let block = docView.children[i81], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView) return block;
                if (end > pos) break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    widget;
    length;
    type;
    breakAfter = 0;
    prevWidget = null;
    constructor(widget, length, type){
        super();
        this.widget = widget;
        this.length = length;
        this.type = type;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.type);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() {
        return noChildren;
    }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
        return null;
    }
    become(other) {
        if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
            if (!other.widget.eq(this.widget)) this.markDirty(true);
            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() {
        return true;
    }
    ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
    }
    destroy() {
        super.destroy();
        if (this.dom) this.widget.destroy(this.dom);
    }
}
var T1;
(function(T3) {
    T3[T3["Chunk"] = 512] = "Chunk";
})(T1 || (T1 = {}));
var Buf;
(function(Buf1) {
    Buf1[Buf1["No"] = 0] = "No";
    Buf1[Buf1["Yes"] = 1] = "Yes";
    Buf1[Buf1["IfCursor"] = 2] = "IfCursor";
})(Buf || (Buf = {}));
class ContentBuilder {
    doc;
    pos;
    end;
    disallowBlockEffectsBelow;
    content = [];
    curLine = null;
    breakAtStart = 0;
    pendingBuffer = Buf.No;
    atCursorPos = true;
    openStart = -1;
    openEnd = -1;
    cursor;
    text = "";
    skip;
    textOff = 0;
    constructor(doc16, pos, end, disallowBlockEffectsBelow){
        this.doc = doc16;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsBelow = disallowBlockEffectsBelow;
        this.cursor = doc16.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = Buf.No;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer([]);
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (!openEnd) this.flushBuffer([]);
        else this.pendingBuffer = Buf.No;
        if (!this.posCovered()) this.getLine();
    }
    buildText(length, active, openStart) {
        while(length > 0){
            if (this.textOff == this.text.length) {
                let { value , lineBreak , done  } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done) throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered()) this.getLine();
                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;
                    else this.breakAtStart = 1;
                    this.flushBuffer([]);
                    this.curLine = null;
                    length--;
                    continue;
                } else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, T1.Chunk);
            this.flushBuffer(active.slice(0, openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0) this.openStart = openStart;
    }
    point(from, to, deco, active, openStart) {
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                let { type  } = deco;
                if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
            } else {
                let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == Buf.IfCursor && !cursorBefore) this.pendingBuffer = Buf.No;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? Buf.No : from < to ? Buf.Yes : Buf.IfCursor;
            }
        } else if (this.doc.lineAt(this.pos).from == this.pos) {
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            } else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0) this.openStart = openStart;
    }
    filterPoint(from, to, value, index) {
        if (index < this.disallowBlockEffectsBelow && value instanceof PointDecoration) {
            if (value.block) throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        return true;
    }
    static build(text, from, to, decorations3, pluginDecorationLength) {
        let builder = new ContentBuilder(text, from, to, pluginDecorationLength);
        builder.openEnd = RangeSet.spans(decorations3, from, to, builder);
        if (builder.openStart < 0) builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)view = new MarkView(mark, [
        view
    ], view.length);
    return view;
}
class NullWidget extends WidgetType {
    tag;
    constructor(tag){
        super();
        this.tag = tag;
    }
    eq(other) {
        return other.tag == this.tag;
    }
    toDOM() {
        return document.createElement(this.tag);
    }
    updateDOM(elt5) {
        return elt5.nodeName.toLowerCase() == this.tag;
    }
}
const LineBreakPlaceholder = "\uffff";
class DOMReader {
    points;
    text = "";
    lineSeparator;
    constructor(points, state27){
        this.points = points;
        this.lineSeparator = state27.facet(EditorState.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start) return this;
        let parent = start.parentNode;
        for(let cur11 = start;;){
            this.findPointBefore(parent, cur11);
            this.readNode(cur11);
            let next = cur11.nextSibling;
            if (next == end) break;
            let view = ContentView.get(cur11), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur11)) || isBlockElement(next) && (cur11.nodeName != "BR" || cur11.cmIgnore)) this.lineBreak();
            cur11 = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);
        for(let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;){
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            } else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0) break;
            this.lineBreak();
            if (breakSize > 1) {
                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;
            }
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore) return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for(let i82 = fromView.iter(); !i82.next().done;){
                if (i82.lineBreak) this.lineBreak();
                else this.append(i82.value);
            }
        } else if (node.nodeType == 3) {
            this.readTextNode(node);
        } else if (node.nodeName == "BR") {
            if (node.nextSibling) this.lineBreak();
        } else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
class DOMPoint {
    node;
    offset;
    pos = -1;
    constructor(node, offset){
        this.node = node;
        this.offset = offset;
    }
}
class DocView extends ContentView {
    view;
    children;
    compositionDeco = Decoration.none;
    decorations = [];
    pluginDecorationLength = 0;
    minWidth = 0;
    minWidthFrom = 0;
    minWidthTo = 0;
    impreciseAnchor = null;
    impreciseHead = null;
    forceSelection = false;
    lastUpdate = Date.now();
    get root() {
        return this.view.root;
    }
    get editorView() {
        return this.view;
    }
    get length() {
        return this.view.state.doc.length;
    }
    constructor(view){
        super();
        this.view = view;
        this.setDOM(view.contentDOM);
        this.children = [
            new LineView
        ];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([
            new ChangedRange(0, 0, 0, view.state.doc.length)
        ], 0);
    }
    update(update) {
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA , toA  })=>toA < this.minWidthFrom || fromA > this.minWidthTo
            )) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            } else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none;
        else if (update.transactions.length || this.dirty) this.compositionDeco = computeCompositionDeco(this.view, update.changes);
        if ((__default.ie || __default.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (this.dirty == Dirty.Not && changedRanges.length == 0) {
            return false;
        } else {
            this.updateInner(changedRanges, update.startState.doc.length);
            if (update.transactions.length) this.lastUpdate = Date.now();
            return true;
        }
    }
    updateInner(changes, oldLength) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength);
        let { observer  } = this.view;
        observer.ignore(()=>{
            this.dom.style.height = this.view.viewState.contentHeight + "px";
            this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
            let track = __default.chrome || __default.ios ? {
                node: observer.selectionRange.focusNode,
                written: false
            } : undefined;
            this.sync(track);
            this.dirty = Dirty.Not;
            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;
            this.dom.style.height = "";
        });
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
        }
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
        let cursor = this.childCursor(oldLength);
        for(let i83 = changes.length - 1;; i83--){
            let next = i83 >= 0 ? changes[i83] : null;
            if (!next) break;
            let { fromA , toA , fromB , toB  } = next;
            let { content: content4 , breakAtStart , openStart , openEnd  } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.pluginDecorationLength);
            let { i: toI , off: toOff  } = cursor.findPos(toA, 1);
            let { i: fromI , off: fromOff  } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content4, breakAtStart, openStart, openEnd);
        }
    }
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead) this.view.observer.readSelectionRange();
        if (!(fromPointer || this.mayControlSelection()) || __default.ios && this.view.inputState.rapidCompositionStart) return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.domAtPos(main.anchor);
        let head = main.empty ? anchor : this.domAtPos(main.head);
        if (__default.gecko && main.empty && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null)
            );
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(()=>{
                if (__default.android && __default.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({
                        preventScroll: true
                    });
                }
                let rawSel = getSelection(this.root);
                if (main.empty) {
                    if (__default.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (NextTo.Before | NextTo.After)) {
                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == NextTo.Before ? 1 : -1);
                            if (text) anchor = new DOMPos(text, nextTo == NextTo.Before ? 0 : text.nodeValue.length);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;
                } else if (rawSel.extend) {
                    rawSel.collapse(anchor.node, anchor.offset);
                    rawSel.extend(head.node, head.offset);
                } else {
                    let range = document.createRange();
                    if (main.anchor > main.head) [anchor, head] = [
                        head,
                        anchor
                    ];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
        if (this.compositionDeco.size) return;
        let cursor = this.view.state.selection.main;
        let sel = getSelection(this.root);
        if (!cursor.empty || !cursor.assoc || !sel.modify) return;
        let line = LineView.find(this, cursor.head);
        if (!line) return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top) return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
        return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
    }
    nearest(dom) {
        for(let cur12 = dom; cur12;){
            let domView = ContentView.get(cur12);
            if (domView && domView.rootView == this) return domView;
            cur12 = cur12.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i: i84 , off  } = this.childCursor().findPos(pos, -1);
        for(; i84 < this.children.length - 1;){
            let child = this.children[i84];
            if (off < child.length || child instanceof LineView) break;
            i84++;
            off = 0;
        }
        return this.children[i84].domAtPos(off);
    }
    coordsAt(pos, side) {
        for(let off = this.length, i85 = this.children.length - 1;; i85--){
            let child = this.children[i85], start = off - child.breakAfter - child.length;
            if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i85 || side == 2 || this.children[i85 - 1].breakAfter || this.children[i85 - 1].type == BlockType.WidgetBefore && side > -2)) return child.coordsAt(pos - start, side);
            off = start;
        }
    }
    measureVisibleLineHeights() {
        let result = [], { from , to  } = this.view.viewState.viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1;
        for(let pos = 0, i86 = 0; i86 < this.children.length; i86++){
            let child = this.children[i86], end = pos + child.length;
            if (end > to) break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = this.view.textDirection == Direction.LTR ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    measureTextSize() {
        for (let child of this.children){
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure) return measure;
            }
        }
        let dummy = document.createElement("div"), lineHeight, charWidth;
        dummy.className = "cm-line";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(()=>{
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            dummy.remove();
        });
        return {
            lineHeight,
            charWidth
        };
    }
    childCursor(pos = this.length) {
        let i87 = this.children.length;
        if (i87) pos -= this.children[--i87].length;
        return new ChildCursor(this.children, pos, i87);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for(let pos = 0, i88 = 0;; i88++){
            let next = i88 == vs.viewports.length ? null : vs.viewports[i88];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true
                }).range(pos, end));
            }
            if (!next) break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let pluginDecorations = this.view.pluginField(PluginField.decorations);
        this.pluginDecorationLength = pluginDecorations.length;
        return this.decorations = [
            ...pluginDecorations,
            ...this.view.state.facet(decorations),
            this.compositionDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
    }
    scrollIntoView(target) {
        let { range  } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect) return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {
            left: Math.min(rect.left, other.left),
            top: Math.min(rect.top, other.top),
            right: Math.max(rect.right, other.right),
            bottom: Math.max(rect.bottom, other.bottom)
        };
        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
        for (let margins of this.view.pluginField(PluginField.scrollMargins))if (margins) {
            let { left , right , top: top16 , bottom  } = margins;
            if (left != null) mLeft = Math.max(mLeft, left);
            if (right != null) mRight = Math.max(mRight, right);
            if (top16 != null) mTop = Math.max(mTop, top16);
            if (bottom != null) mBottom = Math.max(mBottom, bottom);
        }
        let targetRect = {
            left: rect.left - mLeft,
            top: rect.top - mTop,
            right: rect.right + mRight,
            bottom: rect.bottom + mBottom
        };
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
    split;
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
    height;
    constructor(height){
        super();
        this.height = height;
    }
    toDOM() {
        let elt6 = document.createElement("div");
        this.updateDOM(elt6);
        return elt6;
    }
    eq(other) {
        return other.height == this.height;
    }
    updateDOM(elt7) {
        elt7.style.height = this.height + "px";
        return true;
    }
    get estimatedHeight() {
        return this.height;
    }
}
function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode) return null;
    let cView = view.docView.nearest(textNode);
    if (!cView) return null;
    if (cView instanceof LineView) {
        let topNode = textNode;
        while(topNode.parentNode != cView.dom)topNode = topNode.parentNode;
        let prev = topNode.previousSibling;
        while(prev && !ContentView.get(prev))prev = prev.previousSibling;
        let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
        return {
            from: pos,
            to: pos,
            node: topNode,
            text: textNode
        };
    } else {
        for(;;){
            let { parent  } = cView;
            if (!parent) return null;
            if (parent instanceof LineView) break;
            cView = parent;
        }
        let from = cView.posAtStart;
        return {
            from,
            to: from + cView.length,
            node: cView.dom,
            text: textNode
        };
    }
}
function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding) return Decoration.none;
    let { from , to , node , text: textNode  } = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let { state: state28  } = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state28).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
        if (state28.doc.sliceString(newFrom, Math.min(state28.doc.length, newFrom + text.length), LineBreakPlaceholder) == text) newTo = newFrom + text.length;
        else if (state28.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text) newFrom = newTo - text.length;
        else return Decoration.none;
    } else if (state28.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
        return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView) topView = topView.widget.topView;
    else if (topView) topView.parent = null;
    return Decoration.set(Decoration.replace({
        widget: new CompositionWidget(node, textNode, topView)
    }).range(newFrom, newTo));
}
class CompositionWidget extends WidgetType {
    top;
    text;
    topView;
    constructor(top17, text, topView){
        super();
        this.top = top17;
        this.text = text;
        this.topView = topView;
    }
    eq(other) {
        return this.top == other.top && this.text == other.text;
    }
    toDOM() {
        return this.top;
    }
    ignoreEvent() {
        return false;
    }
    get customView() {
        return CompositionView;
    }
}
function nearbyTextNode(node, offset, side) {
    for(;;){
        if (node.nodeType == 3) return node;
        if (node.nodeType == 1 && offset > 0 && side <= 0) {
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
            node = node.childNodes[offset];
            offset = 0;
        } else {
            return null;
        }
    }
}
var NextTo;
(function(NextTo1) {
    NextTo1[NextTo1["Before"] = 1] = "Before";
    NextTo1[NextTo1["After"] = 2] = "After";
})(NextTo || (NextTo = {}));
function nextToUneditable(node, offset) {
    if (node.nodeType != 1) return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? NextTo.Before : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? NextTo.After : 0);
}
class DecorationComparator1 {
    changes = [];
    compareRange(from, to) {
        addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
        addRange(from, to, this.changes);
    }
}
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator1;
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside1) {
    for(let cur13 = node; cur13 && cur13 != inside1; cur13 = cur13.assignedSlot || cur13.parentNode){
        if (cur13.nodeType == 1 && cur13.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function groupAt(state29, pos, bias = 1) {
    let categorize = state29.charCategorizer(pos);
    let line = state29.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0) return EditorSelection.cursor(pos);
    if (linePos == 0) bias = 1;
    else if (linePos == line.length) bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0) from = findClusterBreak(line.text, linePos, false);
    else to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while(from > 0){
        let prev = findClusterBreak(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat) break;
        from = prev;
    }
    while(to < line.length){
        let next = findClusterBreak(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat) break;
        to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top18) {
    return top18 < rect.top ? {
        top: top18,
        left: rect.left,
        right: rect.right,
        bottom: rect.bottom
    } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? {
        top: rect.top,
        left: rect.left,
        right: rect.right,
        bottom
    } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY;
    let above, below, aboveRect, belowRect;
    for(let child = parent.firstChild; child; child = child.nextSibling){
        let rects = clientRectsFor(child);
        for(let i89 = 0; i89 < rects.length; i89++){
            let rect = rects[i89];
            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            } else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            } else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest) return {
        node: parent,
        offset: 0
    };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
    if (!closestX && closest.contentEditable == "true") return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {
        node: parent,
        offset
    };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1000000000, generalSide = 0;
    for(let i90 = 0; i90 < len; i90++){
        let rects = textRange(node, i90, i90 + 1).getClientRects();
        for(let j = 0; j < rects.length; j++){
            let rect = rects[j];
            if (rect.top == rect.bottom) continue;
            if (!generalSide) generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (__default.chrome || __default.gecko) {
                    let rectBefore = textRange(node, i90).getBoundingClientRect();
                    if (rectBefore.left == rect.right) after = !right;
                }
                if (dy <= 0) return {
                    node,
                    offset: i90 + (after ? 1 : 0)
                };
                closestOffset = i90 + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return {
        node,
        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
    };
}
function posAtCoords(view, { x , y  }, precise, bias = -1) {
    let content5 = view.contentDOM.getBoundingClientRect(), docTop = content5.top + view.viewState.paddingTop;
    let block, { docHeight  } = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0) return 0;
    if (yOffset > docHeight) return view.state.doc.length;
    for(let halfLine = view.defaultLineHeight / 2, bounced = false;;){
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text) break;
        for(;;){
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight) break;
            if (bounced) return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content5, block, x, y);
    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content5, block, x, y);
    let doc17 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc17;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element)) element = null;
    if (!element) {
        x = Math.max(content5.left + 1, Math.min(content5.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element)) element = null;
    }
    let node, offset = -1;
    if (element && view.docView.nearest(element)?.isEditable != false) {
        if (doc17.caretPositionFromPoint) {
            let pos = doc17.caretPositionFromPoint(x, y);
            if (pos) ({ offsetNode: node , offset  } = pos);
        } else if (doc17.caretRangeFromPoint) {
            let range = doc17.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node , startOffset: offset  } = range);
                if (__default.safari && isSuspiciousCaretResult(node, offset, x)) node = undefined;
            }
        }
    }
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node , offset  } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let line = Math.floor((y - block.top) / view.defaultLineHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content6 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content6, into, view.state.tabSize);
}
function isSuspiciousCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
    for(let next = node.nextSibling; next; next = next.nextSibling)if (next.nodeType != 1 || next.nodeName != "BR") return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let pos = view.posAtCoords({
            x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2
        });
        if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    for(let cur14 = start, check = null;;){
        let next = moveVisually(line, spans, view.textDirection, cur14, forward), __char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1)) return cur14;
            __char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = EditorSelection.cursor(forward ? line.from : line.to);
        }
        if (!check) {
            if (!by) return next;
            check = by(__char);
        } else if (!check(__char)) {
            return cur14;
        }
        cur14 = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next)=>{
        let nextCat = categorize(next);
        if (cat == CharCategory.Space) cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0)) return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null) goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
        let line = view.viewState.lineBlockAt(startPos - docTop);
        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance ?? view.defaultLineHeight >> 1;
    for(let extra = 0;; extra += 10){
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, {
            x: resolvedGoal,
            y: curY
        }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) return EditorSelection.cursor(pos, start.assoc, undefined, goal);
    }
}
function skipAtoms(view, oldPos, pos) {
    let atoms = view.pluginField(PluginField.atomicRanges);
    for(;;){
        let moved = false;
        for (let set of atoms){
            set.between(pos.from - 1, pos.from + 1, (from, to, value)=>{
                if (pos.from > from && pos.from < to) {
                    pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
                    moved = true;
                }
            });
        }
        if (!moved) return pos;
    }
}
class InputState {
    lastKeyCode = 0;
    lastKeyTime = 0;
    pendingIOSKey = undefined;
    lastSelectionOrigin = null;
    lastSelectionTime = 0;
    lastEscPress = 0;
    lastContextMenu = 0;
    scrollHandlers = [];
    registeredEvents = [];
    customHandlers = [];
    composing = -1;
    compositionFirstChange = null;
    compositionEndedAt = 0;
    rapidCompositionStart = false;
    mouseSelection = null;
    notifiedFocused;
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view){
        for(let type in handlers){
            let handler = handlers[type];
            view.contentDOM.addEventListener(type, (event)=>{
                if (type == "keydown" && this.keydown(view, event)) return;
                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event)) return;
                if (this.mustFlushObserver(event)) view.observer.forceFlush();
                if (this.runCustomHandlers(type, view, event)) event.preventDefault();
                else handler(view, event);
            });
            this.registeredEvents.push(type);
        }
        this.notifiedFocused = view.hasFocus;
        this.ensureHandlers(view);
        if (__default.safari) view.contentDOM.addEventListener("input", ()=>null
        );
    }
    ensureHandlers(view) {
        let handlers1 = this.customHandlers = view.pluginField(domEventHandlers);
        for (let set of handlers1){
            for(let type in set.handlers)if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                this.registeredEvents.push(type);
                view.contentDOM.addEventListener(type, (event)=>{
                    if (!eventBelongsToEditor(view, event)) return;
                    if (this.runCustomHandlers(type, view, event)) event.preventDefault();
                });
            }
        }
    }
    runCustomHandlers(type, view, event) {
        for (let set of this.customHandlers){
            let handler = set.handlers[type];
            if (handler) {
                try {
                    if (handler.call(set.plugin, event, view) || event.defaultPrevented) return true;
                } catch (e) {
                    logException(view.state, e);
                }
            }
        }
        return false;
    }
    runScrollHandlers(view, event) {
        for (let set of this.customHandlers){
            let handler = set.handlers.scroll;
            if (handler) {
                try {
                    handler.call(set.plugin, event, view);
                } catch (e) {
                    logException(view.state, e);
                }
            }
        }
    }
    keydown(view, event) {
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (this.screenKeyEvent(view, event)) return true;
        if (__default.android && __default.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
            view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        let pending;
        if (__default.ios && (pending = PendingKeys.find((key)=>key.keyCode == event.keyCode
        )) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
            this.pendingIOSKey = pending;
            setTimeout(()=>this.flushIOSKey(view)
            , 250);
            return true;
        }
        return false;
    }
    flushIOSKey(view) {
        let key = this.pendingIOSKey;
        if (!key) return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type)) return false;
        if (this.composing > 0) return true;
        if (__default.safari && Date.now() - this.compositionEndedAt < 500) {
            this.compositionEndedAt = 0;
            return true;
        }
        return false;
    }
    screenKeyEvent(view, event) {
        let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;
        if (event.keyCode == 27) this.lastEscPress = Date.now();
        else if (modifierCodes.indexOf(event.keyCode) < 0) this.lastEscPress = 0;
        return protectedTab;
    }
    mustFlushObserver(event) {
        return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !__default.ios;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection) this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        if (this.mouseSelection) this.mouseSelection.update(update);
        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection) this.mouseSelection.destroy();
    }
}
const PendingKeys = [
    {
        key: "Backspace",
        keyCode: 8,
        inputType: "deleteContentBackward"
    },
    {
        key: "Enter",
        keyCode: 13,
        inputType: "insertParagraph"
    },
    {
        key: "Delete",
        keyCode: 46,
        inputType: "deleteContentForward"
    }
];
const modifierCodes = [
    16,
    17,
    18,
    20,
    91,
    92,
    224,
    225
];
class MouseSelection {
    view;
    style;
    mustSelect;
    dragging;
    dragMove;
    extend;
    multiple;
    lastEvent;
    constructor(view, startEvent, style, mustSelect){
        this.view = view;
        this.style = style;
        this.mustSelect = mustSelect;
        this.lastEvent = startEvent;
        let doc18 = view.contentDOM.ownerDocument;
        doc18.addEventListener("mousemove", this.move = this.move.bind(this));
        doc18.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragMove = dragMovesSelection1(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
        if (this.dragging === false) {
            startEvent.preventDefault();
            this.select(startEvent);
        }
    }
    move(event) {
        if (event.buttons == 0) return this.destroy();
        if (this.dragging !== false) return;
        this.select(this.lastEvent = event);
    }
    up(event) {
        if (this.dragging == null) this.select(this.lastEvent);
        if (!this.dragging) event.preventDefault();
        this.destroy();
    }
    destroy() {
        let doc19 = this.view.contentDOM.ownerDocument;
        doc19.removeEventListener("mousemove", this.move);
        doc19.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = null;
    }
    select(event) {
        let selection = this.style.get(event, this.extend, this.multiple);
        if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc) this.view.dispatch({
            selection,
            userEvent: "select.pointer",
            scrollIntoView: true
        });
        this.mustSelect = false;
    }
    update(update) {
        if (update.docChanged && this.dragging) this.dragging = this.dragging.map(update.changes);
        if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent)
        , 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : __default.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection1(view, event) {
    let facet = view.state.facet(dragMovesSelection);
    return facet.length ? facet[0](event) : __default.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main  } = view.state.selection;
    if (main.empty) return false;
    let sel = getSelection(view.root);
    if (sel.rangeCount == 0) return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for(let i91 = 0; i91 < rects.length; i91++){
        let rect = rects[i91];
        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles) return true;
    if (event.defaultPrevented) return false;
    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;
    return true;
}
const handlers = Object.create(null);
const brokenClipboardAPI = __default.ie && __default.ie_version < 15 || __default.ios && __default.webkit_version < 604;
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent) return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(()=>{
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function doPaste(view, input) {
    let { state: state30  } = view, changes, i92 = 1, text = state30.toText(input);
    let byLine = text.lines == state30.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state30.selection.ranges.every((r)=>r.empty
    ) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state30.changeByRange((range)=>{
            let line = state30.doc.lineAt(range.from);
            if (line.from == lastLine) return {
                range
            };
            lastLine = line.from;
            let insert6 = state30.toText((byLine ? text.line(i92++).text : input) + state30.lineBreak);
            return {
                changes: {
                    from: line.from,
                    insert: insert6
                },
                range: EditorSelection.cursor(range.from + insert6.length)
            };
        });
    } else if (byLine) {
        changes = state30.changeByRange((range)=>{
            let line = text.line(i92++);
            return {
                changes: {
                    from: range.from,
                    to: range.to,
                    insert: line.text
                },
                range: EditorSelection.cursor(range.from + line.length)
            };
        });
    } else {
        changes = state30.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
handlers.keydown = (view, event)=>{
    view.inputState.setSelectionOrigin("select");
};
let lastTouch = 0;
handlers.touchstart = (view, e)=>{
    lastTouch = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.touchmove = (view)=>{
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event)=>{
    view.observer.flush();
    if (lastTouch > Date.now() - 2000 && getClickType(event) == 1) return;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)){
        style = makeStyle(view, event);
        if (style) break;
    }
    if (!style && event.button == 0) style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = view.root.activeElement != view.contentDOM;
        if (mustFocus) view.observer.ignore(()=>focusPreventScroll(view.contentDOM)
        );
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
        return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
        return groupAt(view.state, pos, bias);
    } else {
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to) to++;
        return EditorSelection.range(from, to);
    }
}
let insideY = (y, rect)=>y >= rect.top && y <= rect.bottom
;
let inside = (x, y, rect)=>insideY(y, rect) && x >= rect.left && x <= rect.right
;
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line) return 1;
    let off = pos - line.posAtStart;
    if (off == 0) return 1;
    if (off == line.length) return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before)) return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after)) return 1;
    return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({
        x: event.clientX,
        y: event.clientY
    }, false);
    return {
        pos,
        bias: findPositionSide(view, pos, event.clientX, event.clientY)
    };
}
const BadMouseDetail = __default.ie && __default.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail) return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event1) {
    let start = queryPos(view, event1), type = getClickType(event1);
    let startSel = view.state.selection;
    let last = start, lastEvent = event1;
    return {
        update (update) {
            if (update.docChanged) {
                if (start) start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
                lastEvent = null;
            }
        },
        get (event, extend1, multiple) {
            let cur15;
            if (lastEvent && event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY) cur15 = last;
            else {
                cur15 = last = queryPos(view, event);
                lastEvent = event;
            }
            if (!cur15 || !start) return startSel;
            let range = rangeForClick(view, cur15.pos, cur15.bias, type);
            if (start.pos != cur15.pos && !extend1) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
            }
            if (extend1) return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple) return startSel.addRange(range);
            else return EditorSelection.create([
                range
            ]);
        }
    };
}
handlers.dragstart = (view, event)=>{
    let { selection: { main  }  } = view.state;
    let { mouseSelection  } = view.inputState;
    if (mouseSelection) mouseSelection.dragging = main;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
        event.dataTransfer.effectAllowed = "copyMove";
    }
};
function dropText(view, event, text, direct) {
    if (!text) return;
    let dropPos = view.posAtCoords({
        x: event.clientX,
        y: event.clientY
    }, false);
    event.preventDefault();
    let { mouseSelection  } = view.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {
        from: mouseSelection.dragging.from,
        to: mouseSelection.dragging.to
    } : null;
    let ins = {
        from: dropPos,
        insert: text
    };
    let changes = view.state.changes(del ? [
        del,
        ins
    ] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: {
            anchor: changes.mapPos(dropPos, -1),
            head: changes.mapPos(dropPos, 1)
        },
        userEvent: del ? "move.drop" : "input.drop"
    });
}
handlers.drop = (view, event)=>{
    if (!event.dataTransfer) return;
    if (view.state.readOnly) return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
        event.preventDefault();
        let text = Array(files.length), read = 0;
        let finishFile = ()=>{
            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null
            ).join(view.state.lineBreak), false);
        };
        for(let i93 = 0; i93 < files.length; i93++){
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = ()=>{
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i93] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i93]);
        }
    } else {
        dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
};
handlers.paste = (view, event)=>{
    if (view.state.readOnly) return event.preventDefault();
    view.observer.flush();
    let data1 = brokenClipboardAPI ? null : event.clipboardData;
    if (data1) {
        doPaste(view, data1.getData("text/plain"));
        event.preventDefault();
    } else {
        capturePaste(view);
    }
};
function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent) return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(()=>{
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state31) {
    let content7 = [], ranges = [], linewise = false;
    for (let range of state31.selection.ranges)if (!range.empty) {
        content7.push(state31.sliceDoc(range.from, range.to));
        ranges.push(range);
    }
    if (!content7.length) {
        let upto = -1;
        for (let { from  } of state31.selection.ranges){
            let line = state31.doc.lineAt(from);
            if (line.number > upto) {
                content7.push(line.text);
                ranges.push({
                    from: line.from,
                    to: Math.min(state31.doc.length, line.to + 1)
                });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return {
        text: content7.join(state31.lineBreak),
        ranges,
        linewise
    };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event)=>{
    let { text , ranges , linewise  } = copiedRange(view.state);
    if (!text && !linewise) return;
    lastLinewiseCopy = linewise ? text : null;
    let data2 = brokenClipboardAPI ? null : event.clipboardData;
    if (data2) {
        event.preventDefault();
        data2.clearData();
        data2.setData("text/plain", text);
    } else {
        captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly) view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
    });
};
handlers.focus = handlers.blur = (view)=>{
    setTimeout(()=>{
        if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);
    }, 10);
};
handlers.beforeprint = (view)=>{
    view.viewState.printing = true;
    view.requestMeasure();
    setTimeout(()=>{
        view.viewState.printing = false;
        view.requestMeasure();
    }, 2000);
};
function forceClearComposition(view, rapid) {
    if (view.docView.compositionDeco.size) {
        view.inputState.rapidCompositionStart = rapid;
        try {
            view.update([]);
        } finally{
            view.inputState.rapidCompositionStart = false;
        }
    }
}
handlers.compositionstart = handlers.compositionupdate = (view)=>{
    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        if (view.docView.compositionDeco.size) {
            view.observer.flush();
            forceClearComposition(view, true);
        }
    }
};
handlers.compositionend = (view)=>{
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    setTimeout(()=>{
        if (view.inputState.composing < 0) forceClearComposition(view, false);
    }, 50);
};
handlers.contextmenu = (view)=>{
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event)=>{
    let pending;
    if (__default.chrome && __default.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType
    ))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = window.visualViewport?.height || 0;
            setTimeout(()=>{
                if ((window.visualViewport?.height || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
};
function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
    let top19 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
    let body = dom.ownerDocument.body;
    for(let parent = dom.parentNode; parent && parent != body;){
        if (parent.nodeType == 1) {
            let elt8 = parent;
            let style = window.getComputedStyle(elt8);
            if ((elt8.scrollHeight > elt8.clientHeight || elt8.scrollWidth > elt8.clientWidth) && style.overflow != "visible") {
                let parentRect = elt8.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top19 = Math.max(top19, parentRect.top);
                bottom = Math.min(bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt8.offsetParent : elt8.parentNode;
        } else if (parent.nodeType == 11) {
            parent = parent.host;
        } else {
            break;
        }
    }
    return {
        left: left - rect.left,
        right: Math.max(left, right) - rect.left,
        top: top19 - (rect.top + paddingTop),
        bottom: Math.max(top19, bottom) - (rect.top + paddingTop)
    };
}
var VP;
(function(VP1) {
    VP1[VP1["Margin"] = 1000] = "Margin";
    VP1[VP1["MinCoverMargin"] = 10] = "MinCoverMargin";
    VP1[VP1["MaxCoverMargin"] = VP1.Margin / 4] = "MaxCoverMargin";
    VP1[VP1["MaxDOMHeight"] = 7000000] = "MaxDOMHeight";
})(VP || (VP = {}));
class LineGap {
    from;
    to;
    size;
    constructor(from, to, size){
        this.from = from;
        this.to = to;
        this.size = size;
    }
    static same(a, b) {
        if (a.length != b.length) return false;
        for(let i94 = 0; i94 < a.length; i94++){
            let gA = a[i94], gB = b[i94];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
        }
        return true;
    }
    draw(wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.size, wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    size;
    vertical;
    constructor(size, vertical){
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) {
        return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
        let elt9 = document.createElement("div");
        if (this.vertical) {
            elt9.style.height = this.size + "px";
        } else {
            elt9.style.width = this.size + "px";
            elt9.style.height = "2px";
            elt9.style.display = "inline-block";
        }
        return elt9;
    }
    get estimatedHeight() {
        return this.vertical ? this.size : -1;
    }
}
var LG;
(function(LG1) {
    LG1[LG1["Margin"] = 2000] = "Margin";
    LG1[LG1["HalfMargin"] = LG1.Margin >> 1] = "HalfMargin";
    LG1[LG1["DoubleMargin"] = LG1.Margin << 1] = "DoubleMargin";
    LG1[LG1["SelectionMargin"] = 10] = "SelectionMargin";
})(LG || (LG = {}));
class ViewState {
    state;
    pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
    };
    inView = true;
    paddingTop = 0;
    paddingBottom = 0;
    contentDOMWidth = 0;
    contentDOMHeight = 0;
    editorHeight = 0;
    editorWidth = 0;
    heightOracle = new HeightOracle;
    heightMap;
    scaler = IdScaler;
    scrollTarget = null;
    printing = false;
    mustMeasureContent = true;
    viewportLines;
    viewport;
    viewports;
    visibleRanges = [];
    lineGaps;
    lineGapDeco;
    mustEnforceCursorAssoc = false;
    constructor(state32){
        this.state = state32;
        this.heightMap = HeightMap.empty().applyChanges(state32.facet(decorations), Text.empty, this.heightOracle.setDoc(state32.doc), [
            new ChangedRange(0, 0, 0, state32.doc.length)
        ]);
        this.viewport = this.getViewport(0, null);
        this.updateViewportLines();
        this.updateForViewport();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(false)
        ));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [
            this.viewport
        ], { main  } = this.state.selection;
        for(let i95 = 0; i95 <= 1; i95++){
            let pos = i95 ? main.head : main.anchor;
            if (!viewports.some(({ from , to  })=>pos >= from && pos <= to
            )) {
                let { from , to  } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b)=>a.from - b.from
        );
        this.scaler = this.heightMap.height <= VP.MaxDOMHeight ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block)=>{
            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        let prev = this.state;
        this.state = update.state;
        let newDeco = this.state.facet(decorations);
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight) update.flags |= UpdateFlag.Height;
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
        let updateLines = !update.changes.empty || update.flags & UpdateFlag.Height || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        this.updateForViewport();
        if (updateLines) this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > LG.DoubleMargin) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges();
        if (scrollTarget) this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc) this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForStyle(whiteSpace, direction);
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
        let result = 0, bias = 0;
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping) measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= UpdateFlag.Geometry;
        }
        if (measureContent) {
            this.mustMeasureContent = false;
            this.contentDOMHeight = dom.clientHeight;
            let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
            if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
                result |= UpdateFlag.Geometry;
                this.paddingTop = paddingTop;
                this.paddingBottom = paddingBottom;
            }
        }
        let pixelViewport = this.printing ? {
            top: -100000000,
            bottom: 100000000,
            left: -100000000,
            right: 100000000
        } : visiblePixelRange(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView) measureContent = true;
        }
        if (!this.inView) return 0;
        let contentWidth = dom.clientWidth;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = contentWidth;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= UpdateFlag.Geometry;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights();
            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight , charWidth  } = view.docView.measureTextSize();
                refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= UpdateFlag.Geometry;
                }
            }
            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
            oracle.heightChanged = false;
            this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
            if (oracle.heightChanged) result |= UpdateFlag.Height;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);
        this.updateForViewport();
        if (result & UpdateFlag.Height || viewportChange) this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > LG.DoubleMargin) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / VP.Margin / 2));
        let map = this.heightMap, doc20 = this.state.doc, { visibleTop , visibleBottom  } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * VP.Margin, QueryType.ByHeight, doc20, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * VP.Margin, QueryType.ByHeight, doc20, 0, 0).to);
        if (scrollTarget) {
            let { head  } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, doc20, 0, 0), topPos;
                if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from) topPos = block.top;
                else topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - VP.Margin / 2, QueryType.ByHeight, doc20, 0, 0).from, map.lineAt(topPos + viewHeight + VP.Margin / 2, QueryType.ByHeight, doc20, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({ from , to  }, bias = 0) {
        if (!this.inView) return true;
        let { top: top20  } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
        let { bottom  } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
        let { visibleTop , visibleBottom  } = this;
        return (from == 0 || top20 <= visibleTop - Math.max(VP.MinCoverMargin, Math.min(-bias, VP.MaxCoverMargin))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(VP.MinCoverMargin, Math.min(bias, VP.MaxCoverMargin))) && top20 > visibleTop - 2 * VP.Margin && bottom < visibleBottom + 2 * VP.Margin;
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty) return gaps;
        let mapped = [];
        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
        return mapped;
    }
    ensureLineGaps(current) {
        let gaps = [];
        if (this.heightOracle.direction != Direction.LTR) return gaps;
        for (let line of this.viewportLines){
            if (line.length < LG.DoubleMargin) continue;
            let structure = lineStructure(line.from, line.to, this.state);
            if (structure.total < LG.DoubleMargin) continue;
            let viewFrom, viewTo;
            if (this.heightOracle.lineWrapping) {
                let marginHeight = LG.Margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
                viewFrom = findPosition(structure, (this.visibleTop - line.top - marginHeight) / line.height);
                viewTo = findPosition(structure, (this.visibleBottom - line.top + marginHeight) / line.height);
            } else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = LG.Margin * this.heightOracle.charWidth;
                viewFrom = findPosition(structure, (this.pixelViewport.left - marginWidth) / totalWidth);
                viewTo = findPosition(structure, (this.pixelViewport.right + marginWidth) / totalWidth);
            }
            let outside = [];
            if (viewFrom > line.from) outside.push({
                from: line.from,
                to: viewFrom
            });
            if (viewTo < line.to) outside.push({
                from: viewTo,
                to: line.to
            });
            let sel = this.state.selection.main;
            if (sel.from >= line.from && sel.from <= line.to) cutRange(outside, sel.from - LG.SelectionMargin, sel.from + LG.SelectionMargin);
            if (!sel.empty && sel.to >= line.from && sel.to <= line.to) cutRange(outside, sel.to - LG.SelectionMargin, sel.to + LG.SelectionMargin);
            for (let { from , to  } of outside)if (to - from > LG.HalfMargin) {
                gaps.push(find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < LG.HalfMargin && Math.abs(gap.to - to) < LG.HalfMargin
                ) || new LineGap(from, to, this.gapSize(line, from, to, structure)));
            }
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        } else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this.heightOracle.lineWrapping)
            ));
        }
    }
    computeVisibleRanges() {
        let deco = this.state.facet(decorations);
        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span (from, to) {
                ranges.push({
                    from,
                    to
                });
            },
            point () {}
        }, 20);
        let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i96)=>r.from != ranges[i96].from || r.to != ranges[i96].to
        );
        this.visibleRanges = ranges;
        return changed ? UpdateFlag.Viewport : 0;
    }
    lineBlockAt(pos) {
        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos
        ) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    from;
    to;
    constructor(from, to){
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from1, to1, state33) {
    let ranges = [], pos = from1, total = 0;
    RangeSet.spans(state33.facet(decorations), from1, to1, {
        span () {},
        point (from, to) {
            if (from > pos) {
                ranges.push({
                    from: pos,
                    to: from
                });
                total += from - pos;
            }
            pos = to;
        }
    }, 20);
    if (pos < to1) {
        ranges.push({
            from: pos,
            to: to1
        });
        total += to1 - pos;
    }
    return {
        total,
        ranges
    };
}
function findPosition({ total , ranges  }, ratio) {
    if (ratio <= 0) return ranges[0].from;
    if (ratio >= 1) return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for(let i97 = 0;; i97++){
        let { from , to  } = ranges[i97], size = to - from;
        if (dist <= size) return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from , to  } of structure.ranges){
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function cutRange(ranges, from, to) {
    for(let i98 = 0; i98 < ranges.length; i98++){
        let r = ranges[i98];
        if (r.from < to && r.to > from) {
            let pieces = [];
            if (r.from < from) pieces.push({
                from: r.from,
                to: from
            });
            if (r.to > to) pieces.push({
                from: to,
                to: r.to
            });
            ranges.splice(i98, 1, ...pieces);
            i98 += pieces.length - 1;
        }
    }
}
function find(array, f) {
    for (let val of array)if (f(val)) return val;
    return undefined;
}
const IdScaler = {
    toDOM (n) {
        return n;
    },
    fromDOM (n) {
        return n;
    },
    scale: 1
};
class BigScaler {
    scale;
    viewports;
    constructor(doc21, heightMap, viewports){
        let vpHeight = 0, base5 = 0, domBase = 0;
        this.viewports = viewports.map(({ from , to  })=>{
            let top21 = heightMap.lineAt(from, QueryType.ByPos, doc21, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc21, 0, 0).bottom;
            vpHeight += bottom - top21;
            return {
                from,
                to,
                top: top21,
                bottom,
                domTop: 0,
                domBottom: 0
            };
        });
        this.scale = (VP.MaxDOMHeight - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports){
            obj.domTop = domBase + (obj.top - base5) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base5 = obj.bottom;
        }
    }
    toDOM(n) {
        for(let i99 = 0, base6 = 0, domBase = 0;; i99++){
            let vp = i99 < this.viewports.length ? this.viewports[i99] : null;
            if (!vp || n < vp.top) return domBase + (n - base6) * this.scale;
            if (n <= vp.bottom) return vp.domTop + (n - vp.top);
            base6 = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for(let i100 = 0, base7 = 0, domBase = 0;; i100++){
            let vp = i100 < this.viewports.length ? this.viewports[i100] : null;
            if (!vp || n < vp.domTop) return base7 + (n - domBase) / this.scale;
            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);
            base7 = vp.bottom;
            domBase = vp.domBottom;
        }
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1) return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b)=>scaleBlock(b, scaler)
    ) : block.type);
}
const theme = Facet.define({
    combine: (strs)=>strs.join(" ")
});
const darkTheme = Facet.define({
    combine: (values10)=>values10.indexOf(true) > -1
});
const baseThemeID = StyleModule.newName(), baseLightID = StyleModule.newName(), baseDarkID = StyleModule.newName();
const lightDarkIDs = {
    "&light": "." + baseLightID,
    "&dark": "." + baseDarkID
};
function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
        finish (sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, (m)=>{
                if (m == "&") return main;
                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme = buildTheme("." + baseThemeID, {
    "&.cm-editor": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        minHeight: "100%",
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only"
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere"
    },
    "&light .cm-content": {
        caretColor: "black"
    },
    "&dark .cm-content": {
        caretColor: "white"
    },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
        zIndex: -1,
        contain: "size style"
    },
    ".cm-selectionBackground": {
        position: "absolute"
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        zIndex: 100,
        contain: "size style",
        pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {
        "0%": {},
        "50%": {
            visibility: "hidden"
        },
        "100%": {}
    },
    "@keyframes cm-blink2": {
        "0%": {},
        "50%": {
            visibility: "hidden"
        },
        "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
        position: "absolute",
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none"
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
        display: "block"
    },
    "&light .cm-activeLine": {
        backgroundColor: "#f3f9ff"
    },
    "&dark .cm-activeLine": {
        backgroundColor: "#223039"
    },
    "&light .cm-specialChar": {
        color: "red"
    },
    "&dark .cm-specialChar": {
        color: "#f78"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);
const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
const useCharData = __default.ie && __default.ie_version <= 11;
class DOMObserver {
    view;
    onChange;
    onScrollChanged;
    dom;
    observer;
    active = false;
    selectionRange = new DOMSelectionState;
    selectionChanged = false;
    delayedFlush = -1;
    resizeTimeout = -1;
    queue = [];
    delayedAndroidKey = null;
    onCharData;
    scrollTargets = [];
    intersection = null;
    resize = null;
    intersecting = false;
    gapIntersection = null;
    gaps = [];
    parentCheck = -1;
    constructor(view, onChange, onScrollChanged){
        this.view = view;
        this.onChange = onChange;
        this.onScrollChanged = onScrollChanged;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver((mutations)=>{
            for (let mut of mutations)this.queue.push(mut);
            if ((__default.ie && __default.ie_version <= 11 || __default.ios && view.composing) && mutations.some((m)=>m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length
            )) this.flushSoon();
            else this.flush();
        });
        if (useCharData) this.onCharData = (event)=>{
            this.queue.push({
                target: event.target,
                type: "characterData",
                oldValue: event.prevValue
            });
            this.flushSoon();
        };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        window.addEventListener("resize", this.onResize = this.onResize.bind(this));
        if (typeof ResizeObserver == "function") {
            this.resize = new ResizeObserver(()=>{
                if (this.view.docView.lastUpdate < Date.now() - 75) this.onResize();
            });
            this.resize.observe(view.scrollDOM);
        }
        this.start();
        window.addEventListener("scroll", this.onScroll = this.onScroll.bind(this));
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver((entries)=>{
                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
                }
            }, {});
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver((entries)=>{
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
        this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    onScroll(e) {
        if (this.intersecting) this.flush(false);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{
            this.resizeTimeout = -1;
            this.view.requestMeasure();
        }, 50);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i101)=>g != gaps[i101]
        ))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        if (!this.readSelectionRange() || this.delayedAndroidKey) return;
        let { view  } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) return;
        if ((__default.ie && __default.ie_version <= 11 || __default.android && __default.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();
        else this.flush(false);
    }
    readSelectionRange() {
        let { root  } = this.view, domSel = getSelection(root);
        let range = __default.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM && safariSelectionRangeHack(this.view) || domSel;
        if (this.selectionRange.eq(range)) return false;
        this.selectionRange.setRange(range);
        return this.selectionChanged = true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i102 = 0, changed = null;
        for(let dom = this.dom; dom;){
            if (dom.nodeType == 1) {
                if (!changed && i102 < this.scrollTargets.length && this.scrollTargets[i102] == dom) i102++;
                else if (!changed) changed = this.scrollTargets.slice(0, i102);
                if (changed) changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            } else if (dom.nodeType == 11) {
                dom = dom.host;
            } else {
                break;
            }
        }
        if (i102 < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i102);
        if (changed) {
            for (let dom of this.scrollTargets)dom.removeEventListener("scroll", this.onScroll);
            for (let dom1 of this.scrollTargets = changed)dom1.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active) return f();
        try {
            this.stop();
            return f();
        } finally{
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active) return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active) return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    delayAndroidKey(key1, keyCode) {
        if (!this.delayedAndroidKey) requestAnimationFrame(()=>{
            let key = this.delayedAndroidKey;
            this.delayedAndroidKey = null;
            let startState = this.view.state;
            if (dispatchKey(this.view.contentDOM, key.key, key.keyCode)) this.processRecords();
            else this.flush();
            if (this.view.state == startState) this.view.update([]);
        });
        if (!this.delayedAndroidKey || key1 == "Enter") this.delayedAndroidKey = {
            key: key1,
            keyCode
        };
    }
    flushSoon() {
        if (this.delayedFlush < 0) this.delayedFlush = window.setTimeout(()=>{
            this.delayedFlush = -1;
            this.flush();
        }, 20);
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            window.clearTimeout(this.delayedFlush);
            this.delayedFlush = -1;
            this.flush();
        }
    }
    processRecords() {
        let records = this.queue;
        for (let mut of this.observer.takeRecords())records.push(mut);
        if (records.length) this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records){
            let range = this.readMutation(record);
            if (!range) continue;
            if (range.typeOver) typeOver = true;
            if (from == -1) {
                ({ from , to  } = range);
            } else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return {
            from,
            to,
            typeOver
        };
    }
    flush(readSelection = true) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return;
        if (readSelection) this.readSelectionRange();
        let { from , to , typeOver  } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel) return;
        this.selectionChanged = false;
        let startState = this.view.state;
        this.onChange(from, to, typeOver);
        if (this.view.state == startState) this.view.update([]);
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec)) return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes") cView.dirty |= Dirty.Attrs;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return {
                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
                typeOver: false
            };
        } else if (rec.type == "characterData") {
            return {
                from: cView.posAtStart,
                to: cView.posAtEnd,
                typeOver: rec.target.nodeValue == rec.oldValue
            };
        } else {
            return null;
        }
    }
    destroy() {
        this.stop();
        this.intersection?.disconnect();
        this.gapIntersection?.disconnect();
        this.resize?.disconnect();
        for (let dom of this.scrollTargets)dom.removeEventListener("scroll", this.onScroll);
        window.removeEventListener("scroll", this.onScroll);
        window.removeEventListener("resize", this.onResize);
        this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
    }
}
function findChild(cView, dom, dir) {
    while(dom){
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView) return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found) return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [
        focusNode,
        focusOffset,
        anchorNode,
        anchorOffset
    ];
    return {
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset
    };
}
function applyDOMChange(view, start, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main;
    if (start > -1) {
        let bounds = view.docView.domBoundsAround(start, end, 0);
        if (!bounds || view.state.readOnly) return;
        let { from , to  } = bounds;
        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(bounds.startDOM, bounds.endDOM);
        let preferredPos = sel.from, preferredSide = null;
        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || __default.android && reader.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
        if (diff) {
            if (__default.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
            change = {
                from: from + diff.from,
                to: from + diff.toA,
                insert: Text.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
            };
        }
        newSel = selectionFromPoints(selPoints, from);
    } else if (view.hasFocus || !view.state.facet(editable)) {
        let domSel = view.observer.selectionRange;
        let { impreciseHead: iHead , impreciseAnchor: iAnchor  } = view.docView;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        if (head != sel.head || anchor != sel.anchor) newSel = EditorSelection.single(anchor, head);
    }
    if (!change && !newSel) return;
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty) change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, sel.to)
    };
    else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
    if (change) {
        let startState = view.state;
        if (__default.ios && view.inputState.flushIOSKey(view)) return;
        if (__default.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46))) return;
        let text = change.insert.toString();
        if (view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text)
        )) return;
        if (view.inputState.composing >= 0) view.inputState.composing++;
        let tr;
        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
        } else {
            let changes = startState.changes(change);
            let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : undefined;
            if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
                let replaced = view.state.sliceDoc(change.from, change.to);
                let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
                let offset = sel.to - change.to, size = sel.to - sel.from;
                tr = startState.changeByRange((range)=>{
                    if (range.from == sel.from && range.to == sel.to) return {
                        changes,
                        range: mainSel || range.map(changes)
                    };
                    let to = range.to - offset, from = to - replaced.length;
                    if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to) return {
                        range
                    };
                    let rangeChanges = startState.changes({
                        from,
                        to,
                        insert: change.insert
                    }), selOff = range.to - sel.to;
                    return {
                        changes: rangeChanges,
                        range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                    };
                });
            } else {
                tr = {
                    changes,
                    selection: mainSel && startState.selection.replaceRange(mainSel)
                };
            }
        }
        let userEvent = "input.type";
        if (view.composing) {
            userEvent += ".compose";
            if (view.inputState.compositionFirstChange) {
                userEvent += ".start";
                view.inputState.compositionFirstChange = false;
            }
        }
        view.dispatch(tr, {
            scrollIntoView: true,
            userEvent
        });
    } else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView3 = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select") scrollIntoView3 = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({
            selection: newSel,
            scrollIntoView: scrollIntoView3,
            userEvent
        });
    }
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;
    if (from == minLen && a.length == b.length) return null;
    let toA = a.length, toB = b.length;
    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    } else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return {
        from,
        toA,
        toB
    };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM) return result;
    let { anchorNode , anchorOffset , focusNode , focusOffset  } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base8) {
    if (points.length == 0) return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base8, head + base8) : null;
}
var UpdateState;
(function(UpdateState1) {
    UpdateState1[UpdateState1["Idle"] = 0] = "Idle";
    UpdateState1[UpdateState1["Measuring"] = 1] = "Measuring";
    UpdateState1[UpdateState1["Updating"] = 2] = "Updating";
})(UpdateState || (UpdateState = {}));
class EditorView {
    get state() {
        return this.viewState.state;
    }
    get viewport() {
        return this.viewState.viewport;
    }
    get visibleRanges() {
        return this.viewState.visibleRanges;
    }
    get inView() {
        return this.viewState.inView;
    }
    get composing() {
        return this.inputState.composing > 0;
    }
    get compositionStarted() {
        return this.inputState.composing >= 0;
    }
    _dispatch;
    root;
    dom;
    scrollDOM;
    contentDOM;
    announceDOM;
    inputState;
    viewState;
    docView;
    plugins = [];
    pluginMap = new Map;
    editorAttrs = {};
    contentAttrs = {};
    styleModules;
    bidiCache = [];
    destroyed = false;
    updateState = UpdateState.Updating;
    observer;
    measureScheduled = -1;
    measureRequests = [];
    constructor(config7 = {}){
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.style.cssText = "position: absolute; top: -10000px";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        this._dispatch = config7.dispatch || ((tr)=>this.update([
                tr
            ])
        );
        this.dispatch = this.dispatch.bind(this);
        this.root = config7.root || getRoot(config7.parent) || document;
        this.viewState = new ViewState(config7.state || EditorState.create());
        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec)
        );
        for (let plugin of this.plugins)plugin.update(this);
        this.observer = new DOMObserver(this, (from, to, typeOver)=>{
            applyDOMChange(this, from, to, typeOver);
        }, (event)=>{
            this.inputState.runScrollHandlers(this, event);
            if (this.observer.intersecting) this.measure();
        });
        this.inputState = new InputState(this);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = UpdateState.Idle;
        this.requestMeasure();
        if (config7.parent) config7.parent.appendChild(this.dom);
    }
    dispatch(...input) {
        this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
        if (this.updateState != UpdateState.Idle) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, update;
        let state34 = this.state;
        for (let tr2 of transactions){
            if (tr2.startState != state34) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state34 = tr2.state;
        }
        if (this.destroyed) {
            this.viewState.state = state34;
            return;
        }
        if (state34.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(state34);
        update = new ViewUpdate(this, state34, transactions);
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = UpdateState.Updating;
            for (let tr1 of transactions){
                if (scrollTarget) scrollTarget = scrollTarget.map(tr1.changes);
                if (tr1.scrollIntoView) {
                    let { main  } = tr1.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr1.effects){
                    if (e.is(scrollTo)) scrollTarget = new ScrollTarget(e.value);
                    else if (e.is(centerOn)) scrollTarget = new ScrollTarget(e.value, "center");
                    else if (e.is(scrollIntoView)) scrollTarget = e.value;
                }
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
            this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent("select.pointer")
            ));
        } finally{
            this.updateState = UpdateState.Idle;
        }
        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;
        if (redrawn || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
        if (!update.empty) for (let listener of this.state.facet(updateListener))listener(update);
    }
    setState(newState) {
        if (this.updateState != UpdateState.Idle) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = UpdateState.Updating;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec)
            );
            this.pluginMap.clear();
            for (let plugin1 of this.plugins)plugin1.update(this);
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        } finally{
            this.updateState = UpdateState.Idle;
        }
        if (hadFocus) this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs){
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                } else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
            this.inputState.ensureHandlers(this);
        } else {
            for (let p7 of this.plugins)p7.mustUpdate = update;
        }
        for(let i103 = 0; i103 < this.plugins.length; i103++)this.plugins[i103].update(this);
    }
    measure(flush = true) {
        if (this.destroyed) return;
        if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
        this.measureScheduled = 0;
        if (flush) this.observer.flush();
        let updated = null;
        try {
            for(let i104 = 0;; i104++){
                this.updateState = UpdateState.Measuring;
                let oldViewport = this.viewport;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
                if (i104 > 5) {
                    console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                if (!(changed & UpdateFlag.Viewport)) [this.measureRequests, measuring] = [
                    measuring,
                    this.measureRequests
                ];
                let measured = measuring.map((m)=>{
                    try {
                        return m.read(this);
                    } catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = new ViewUpdate(this, this.state), redrawn = false, scrolled = false;
                update.flags |= changed;
                if (!updated) updated = update;
                else updated.flags |= changed;
                this.updateState = UpdateState.Updating;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                }
                for(let i114 = 0; i114 < measuring.length; i114++)if (measured[i114] != BadMeasure) {
                    try {
                        let m = measuring[i114];
                        if (m.write) m.write(measured[i114], this);
                    } catch (e) {
                        logException(this.state, e);
                    }
                }
                if (this.viewState.scrollTarget) {
                    this.docView.scrollIntoView(this.viewState.scrollTarget);
                    this.viewState.scrollTarget = null;
                    scrolled = true;
                }
                if (redrawn) this.docView.updateSelection(true);
                if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0) break;
            }
        } finally{
            this.updateState = UpdateState.Idle;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);
    }
    get themeClasses() {
        return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${__default.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        this.observer.ignore(()=>{
            updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {
            if (first) this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
        }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
    }
    readMeasured() {
        if (this.updateState == UpdateState.Updating) throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == UpdateState.Idle && this.measureScheduled > -1) this.measure(false);
    }
    requestMeasure(request) {
        if (this.measureScheduled < 0) this.measureScheduled = requestAnimationFrame(()=>this.measure()
        );
        if (request) {
            if (request.key != null) for(let i105 = 0; i105 < this.measureRequests.length; i105++){
                if (this.measureRequests[i105].key === request.key) {
                    this.measureRequests[i105] = request;
                    return;
                }
            }
            this.measureRequests.push(request);
        }
    }
    pluginField(field) {
        let result = [];
        for (let plugin of this.plugins)plugin.update(this).takeField(field, result);
        return result;
    }
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p8)=>p8.spec == plugin
        ) || null);
        return known && known.update(this).value;
    }
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
        return {
            top: this.viewState.paddingTop,
            bottom: this.viewState.paddingBottom
        };
    }
    blockAtHeight(height, docTop) {
        let top22 = ensureTop(docTop, this);
        return this.elementAtHeight(height - top22).moveY(top22);
    }
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    visualLineAtHeight(height, docTop) {
        let top23 = ensureTop(docTop, this);
        return this.lineBlockAtHeight(height - top23).moveY(top23);
    }
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    viewportLines(f, docTop) {
        let top24 = ensureTop(docTop, this);
        for (let line of this.viewportLineBlocks)f(line.moveY(top24));
    }
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    visualLineAt(pos, docTop = 0) {
        return this.lineBlockAt(pos).moveY(docTop + this.viewState.paddingTop);
    }
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)
        ));
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    scrollPosIntoView(pos) {
        this.dispatch({
            effects: scrollTo.of(EditorSelection.cursor(pos))
        });
    }
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right) return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span3 = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, span3.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
        return this.viewState.heightOracle.direction;
    }
    get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
        if (line.length > MaxBidiLine) return trivialOrder(line.length);
        let dir = this.textDirection;
        for (let entry of this.bidiCache)if (entry.from == line.from && entry.dir == dir) return entry.order;
        let order = computeOrder(line.text, this.textDirection);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
        return order;
    }
    get hasFocus() {
        return (document.hasFocus() || __default.safari && this.inputState?.lastContextMenu > Date.now() - 30000) && this.root.activeElement == this.contentDOM;
    }
    focus() {
        this.observer.ignore(()=>{
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    destroy() {
        for (let plugin of this.plugins)plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    static scrollTo = scrollTo;
    static centerOn = centerOn;
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static styleModule = styleModule;
    static domEventHandlers(handlers1) {
        return ViewPlugin.define(()=>({})
        , {
            eventHandlers: handlers1
        });
    }
    static inputHandler = inputHandler;
    static exceptionSink = exceptionSink;
    static updateListener = updateListener;
    static editable = editable;
    static mouseSelectionStyle = mouseSelectionStyle;
    static dragMovesSelection = dragMovesSelection;
    static clickAddsSelectionRange = clickAddsSelectionRange;
    static decorations = decorations;
    static theme(spec, options) {
        let prefix = StyleModule.newName();
        let result = [
            theme.of(prefix),
            styleModule.of(buildTheme(`.${prefix}`, spec))
        ];
        if (options && options.dark) result.push(darkTheme.of(true));
        return result;
    }
    static darkTheme = darkTheme;
    static baseTheme(spec) {
        return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static contentAttributes = contentAttributes;
    static editorAttributes = editorAttributes;
    static lineWrapping = EditorView.contentAttributes.of({
        "class": "cm-lineWrapping"
    });
    static announce = StateEffect.define();
}
const MaxBidiLine = 4096;
function ensureTop(given, view) {
    return (given == null ? view.contentDOM.getBoundingClientRect().top : given) + view.viewState.paddingTop;
}
const BadMeasure = {};
class CachedOrder {
    from;
    to;
    dir;
    order;
    constructor(from, to, dir, order){
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty) return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for(let i106 = Math.max(0, cache.length - 10); i106 < cache.length; i106++){
            let entry = cache[i106];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base9) {
    for(let sources = view.state.facet(facet), i107 = sources.length - 1; i107 >= 0; i107--){
        let source = sources[i107], value = typeof source == "function" ? source(view) : source;
        if (value) combineAttrs(value, base9);
    }
    return base9;
}
const base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    229: "q"
};
const shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: "\"",
    229: "Q"
};
const chrome1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
const safari1 = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
const gecko1 = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
const mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
const ie1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
const brokenModifierNames = chrome1 && (mac || +chrome1[1] < 57) || gecko1 && mac;
for(let i1 = 0; i1 < 10; i1++)base[48 + i1] = base[96 + i1] = String(i1);
for(let i116 = 1; i116 <= 24; i116++)base[i116 + 111] = "F" + i116;
for(let i2 = 65; i2 <= 90; i2++){
    base[i2] = String.fromCharCode(i2 + 32);
    shift[i2] = String.fromCharCode(i2);
}
for(const code in base)if (!Object.prototype.hasOwnProperty.call(shift, code)) shift[code] = base[code];
function keyName(event) {
    const ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari1 || ie1) && event.shiftKey && event.key && event.key.length == 1;
    let name9 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.code] || event.key || "Unidentified";
    if (name9 == "Esc") name9 = "Escape";
    if (name9 == "Del") name9 = "Delete";
    if (name9 == "Left") name9 = "ArrowLeft";
    if (name9 == "Up") name9 = "ArrowUp";
    if (name9 == "Right") name9 = "ArrowRight";
    if (name9 == "Down") name9 = "ArrowDown";
    return name9;
}
const currentPlatform = __default.mac ? "mac" : __default.windows ? "win" : __default.linux ? "linux" : "key";
function normalizeKeyName(name10, platform1) {
    const parts = name10.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space") result = " ";
    let alt, ctrl, shift1, meta2;
    for(let i108 = 0; i108 < parts.length - 1; ++i108){
        const mod50 = parts[i108];
        if (/^(cmd|meta|m)$/i.test(mod50)) meta2 = true;
        else if (/^a(lt)?$/i.test(mod50)) alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod50)) ctrl = true;
        else if (/^s(hift)?$/i.test(mod50)) shift1 = true;
        else if (/^mod$/i.test(mod50)) {
            if (platform1 == "mac") meta2 = true;
            else ctrl = true;
        } else throw new Error("Unrecognized modifier name: " + mod50);
    }
    if (alt) result = "Alt-" + result;
    if (ctrl) result = "Ctrl-" + result;
    if (meta2) result = "Meta-" + result;
    if (shift1) result = "Shift-" + result;
    return result;
}
function modifiers(name11, event, shift2) {
    if (event.altKey) name11 = "Alt-" + name11;
    if (event.ctrlKey) name11 = "Ctrl-" + name11;
    if (event.metaKey) name11 = "Meta-" + name11;
    if (shift2 !== false && event.shiftKey) name11 = "Shift-" + name11;
    return name11;
}
const handleKeyEvents = EditorView.domEventHandlers({
    keydown (event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
});
const keymap = Facet.define({
    enables: handleKeyEvents
});
const Keymaps = new WeakMap();
function getKeymap(state35) {
    const bindings = state35.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b)
    , [])));
    return map;
}
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform2 = currentPlatform) {
    const bound = Object.create(null);
    const isPrefix = Object.create(null);
    const checkPrefix = (name12, is)=>{
        const current = isPrefix[name12];
        if (current == null) isPrefix[name12] = is;
        else if (current != is) throw new Error("Key binding " + name12 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    const add3 = (scope, key, command1, preventDefault)=>{
        const scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        const parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform2)
        );
        for(let i109 = 1; i109 < parts.length; i109++){
            const prefix = parts.slice(0, i109).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix]) scopeObj[prefix] = {
                preventDefault: true,
                commands: [
                    (view)=>{
                        const ourObj = storedPrefix = {
                            view,
                            prefix,
                            scope
                        };
                        setTimeout(()=>{
                            if (storedPrefix == ourObj) storedPrefix = null;
                        }, PrefixTimeout);
                        return true;
                    }
                ]
            };
        }
        const full = parts.join(" ");
        checkPrefix(full, false);
        const binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            commands: []
        });
        binding.commands.push(command1);
        if (preventDefault) binding.preventDefault = true;
    };
    for (const b of bindings){
        const name13 = b[platform2] || b.key;
        if (!name13) continue;
        for (const scope of b.scope ? b.scope.split(" ") : [
            "editor"
        ]){
            add3(scope, name13, b.run, b.preventDefault);
            if (b.shift) add3(scope, "Shift-" + name13, b.shift, b.preventDefault);
        }
    }
    return bound;
}
function runHandlers(map, event, view, scope) {
    const name14 = keyName(event), isChar = name14.length == 1 && name14 != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        const fallthrough = modifierCodes.indexOf(parseInt(event.code)) < 0 ? false : true;
        if (fallthrough) storedPrefix = null;
    }
    const runFor = (binding)=>{
        if (binding) {
            for (const cmd1 of binding.commands)if (cmd1(view)) return true;
            if (binding.preventDefault) fallthrough = true;
        }
        return false;
    };
    const scopeObj = map[scope];
    let baseName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name14, event, !isChar)])) return true;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.code]) && baseName != name14) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;
        } else if (isChar && event.shiftKey) {
            if (runFor(scopeObj[prefix + modifiers(name14, event, true)])) return true;
        }
    }
    return fallthrough;
}
const CanHidePrimary = !__default.ios;
var C2;
(function(C5) {
    C5[C5["Epsilon"] = 0.01] = "Epsilon";
})(C2 || (C2 = {}));
const selectionConfig = Facet.define({
    combine (configs) {
        return combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b)=>Math.min(a, b)
            ,
            drawRangeCursor: (a, b)=>a || b
        });
    }
});
function drawSelection(config8 = {}) {
    return [
        selectionConfig.of(config8),
        drawSelectionPlugin,
        hideNativeSelection
    ];
}
class Piece {
    left;
    top;
    width;
    height;
    className;
    constructor(left, top25, width, height, className){
        this.left = left;
        this.top = top25;
        this.width = width;
        this.height = height;
        this.className = className;
    }
    draw() {
        let elt10 = document.createElement("div");
        elt10.className = this.className;
        this.adjust(elt10);
        return elt10;
    }
    adjust(elt11) {
        elt11.style.left = this.left + "px";
        elt11.style.top = this.top + "px";
        if (this.width >= 0) elt11.style.width = this.width + "px";
        elt11.style.height = this.height + "px";
    }
    eq(p9) {
        return this.left == p9.left && this.top == p9.top && this.width == p9.width && this.height == p9.height && this.className == p9.className;
    }
}
const drawSelectionPlugin = ViewPlugin.fromClass(class {
    view;
    rangePieces = [];
    cursors = [];
    measureReq;
    selectionLayer;
    cursorLayer;
    constructor(view){
        this.view = view;
        this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawSel.bind(this)
        };
        this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.selectionLayer.className = "cm-selectionLayer";
        this.selectionLayer.setAttribute("aria-hidden", "true");
        this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.cursorLayer.className = "cm-cursorLayer";
        this.cursorLayer.setAttribute("aria-hidden", "true");
        view.requestMeasure(this.measureReq);
        this.setBlinkRate();
    }
    setBlinkRate() {
        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
        let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged) this.view.requestMeasure(this.measureReq);
        if (update.transactions.some((tr)=>tr.scrollIntoView
        )) this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        if (confChanged) this.setBlinkRate();
    }
    readPos() {
        let { state: state36  } = this.view, conf = state36.facet(selectionConfig);
        let rangePieces = state36.selection.ranges.map((r)=>r.empty ? [] : measureRange(this.view, r)
        ).reduce((a, b)=>a.concat(b)
        );
        let cursors = [];
        for (let r1 of state36.selection.ranges){
            let prim = r1 == state36.selection.main;
            if (r1.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let piece = measureCursor(this.view, r1, prim);
                if (piece) cursors.push(piece);
            }
        }
        return {
            rangePieces,
            cursors
        };
    }
    drawSel({ rangePieces , cursors  }) {
        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p10, i117)=>!p10.eq(this.rangePieces[i117])
        )) {
            this.selectionLayer.textContent = "";
            for (let p11 of rangePieces)this.selectionLayer.appendChild(p11.draw());
            this.rangePieces = rangePieces;
        }
        if (cursors.length != this.cursors.length || cursors.some((c, i118)=>!c.eq(this.cursors[i118])
        )) {
            let oldCursors = this.cursorLayer.children;
            if (oldCursors.length !== cursors.length) {
                this.cursorLayer.textContent = "";
                for (const c of cursors)this.cursorLayer.appendChild(c.draw());
            } else {
                cursors.forEach((c, idx)=>c.adjust(oldCursors[idx])
                );
            }
            this.cursors = cursors;
        }
    }
    destroy() {
        this.selectionLayer.remove();
        this.cursorLayer.remove();
    }
});
const themeSpec = {
    ".cm-line": {
        "& ::selection": {
            backgroundColor: "transparent !important"
        },
        "&::selection": {
            backgroundColor: "transparent !important"
        }
    }
};
if (CanHidePrimary) themeSpec[".cm-line"].caretColor = "transparent !important";
const hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return {
        left: left - view.scrollDOM.scrollLeft,
        top: rect.top - view.scrollDOM.scrollTop
    };
}
function wrappedLine(view, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
        from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
        to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
        type: BlockType.Text
    };
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type)) for (let l of line.type){
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;
    }
    return line;
}
function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];
    let from1 = Math.max(range.from, view.viewport.from), to1 = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content8 = view.contentDOM, contentRect = content8.getBoundingClientRect(), base10 = getBase(view);
    let lineStyle = window.getComputedStyle(content8.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from1), endBlock = blockAt(view, to1);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
        if (visualStart) visualStart = wrappedLine(view, from1, visualStart);
        if (visualEnd) visualEnd = wrappedLine(view, to1, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
        return pieces1(drawForLine(range.from, range.to, visualStart));
    } else {
        let top26 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1) between.push(piece(leftSide, top26.bottom, rightSide, bottom.top));
        else if (top26.bottom < bottom.top && view.elementAtHeight((top26.bottom + bottom.top) / 2).type == BlockType.Text) top26.bottom = bottom.top = (top26.bottom + bottom.top) / 2;
        return pieces1(top26).concat(between).concat(pieces1(bottom));
    }
    function piece(left, top27, right, bottom) {
        return new Piece(left - base10.left, top27 - base10.top - C2.Epsilon, right - left, bottom - top27 + C2.Epsilon, "cm-selectionBackground");
    }
    function pieces1({ top: top28 , bottom , horizontal  }) {
        let pieces = [];
        for(let i119 = 0; i119 < horizontal.length; i119 += 2)pieces.push(piece(horizontal[i119], top28, horizontal[i119 + 1], bottom));
        return pieces;
    }
    function drawForLine(from2, to2, line) {
        let top29 = 1000000000, bottom = -1000000000, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);
            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);
            top29 = Math.min(fromCoords.top, toCoords.top, top29);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from2 ?? line.from, end = to2 ?? line.to;
        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {
            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){
                let docLine = view.state.doc.lineAt(pos);
                for (let span4 of view.bidiSpans(docLine)){
                    let spanFrom = span4.from + docLine.from, spanTo = span4.to + docLine.from;
                    if (spanFrom >= endPos) break;
                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span4.dir);
                }
                pos = docLine.to + 1;
                if (pos >= endPos) break;
            }
        }
        if (horizontal.length == 0) addSpan(start, from2 == null, end, to2 == null, view.textDirection);
        return {
            top: top29,
            bottom,
            horizontal
        };
    }
    function drawForWidget(block, top30) {
        let y = contentRect.top + (top30 ? block.top : block.bottom);
        return {
            top: y,
            bottom: y,
            horizontal: []
        };
    }
}
function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos) return null;
    let base11 = getBase(view);
    return new Piece(pos.left - base11.left, pos.top - base11.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}
const setDropCursorPos = StateEffect.define({
    map (pos, mapping) {
        return pos == null ? null : mapping.mapPos(pos);
    }
});
const dropCursorPos = StateField.define({
    create () {
        return null;
    },
    update (pos1, tr) {
        if (pos1 != null) pos1 = tr.changes.mapPos(pos1);
        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos
        , pos1);
    }
});
const drawDropCursor = ViewPlugin.fromClass(class {
    view;
    cursor = null;
    measureReq;
    constructor(view){
        this.view = view;
        this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawCursor.bind(this)
        };
    }
    update(update) {
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                this.cursor?.remove();
                this.cursor = null;
            }
        } else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let pos = this.view.state.field(dropCursorPos);
        let rect = pos != null && this.view.coordsAtPos(pos);
        if (!rect) return null;
        let outer = this.view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
            top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            if (pos) {
                this.cursor.style.left = pos.left + "px";
                this.cursor.style.top = pos.top + "px";
                this.cursor.style.height = pos.height + "px";
            } else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor) this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({
            effects: setDropCursorPos.of(pos)
        });
    }
}, {
    eventHandlers: {
        dragover (event) {
            this.setDropPos(this.view.posAtCoords({
                x: event.clientX,
                y: event.clientY
            }));
        },
        dragleave (event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);
        },
        dragend () {
            this.setDropPos(null);
        },
        drop () {
            this.setDropPos(null);
        }
    }
});
function dropCursor() {
    return [
        dropCursorPos,
        drawDropCursor
    ];
}
function iterMatches(doc22, re, from, to, f) {
    re.lastIndex = 0;
    for(let cursor = doc22.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){
        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, pos + m.index + m[0].length, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;
    let result = [];
    for (let { from , to  } of visible){
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;
        else result.push({
            from,
            to
        });
    }
    return result;
}
class MatchDecorator {
    regexp;
    getDeco;
    boundary;
    maxLength;
    constructor(config9){
        let { regexp , decoration , boundary , maxLength =1000  } = config9;
        if (!regexp.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        this.getDeco = typeof decoration == "function" ? decoration : ()=>decoration
        ;
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    createDeco(view) {
        let build = new RangeSetBuilder();
        for (let { from , to  } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (a, b, m)=>build.add(a, b, this.getDeco(m, view, a))
        );
        return build.finish();
    }
    updateDeco(update, deco) {
        let changeFrom = 1000000000, changeTo = -1;
        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{
            if (to > update.view.viewport.from && from < update.view.viewport.to) {
                changeFrom = Math.min(from, changeFrom);
                changeTo = Math.max(to, changeTo);
            }
        });
        if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);
        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges){
            let from1 = Math.max(r.from, updateFrom), to1 = Math.min(r.to, updateTo);
            if (to1 > from1) {
                let fromLine = view.state.doc.lineAt(from1), toLine = fromLine.to < to1 ? view.state.doc.lineAt(to1) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for(; from1 > fromLine.from; from1--)if (this.boundary.test(fromLine.text[from1 - 1 - fromLine.from])) {
                        start = from1;
                        break;
                    }
                    for(; to1 < toLine.to; to1++)if (this.boundary.test(toLine.text[to1 - toLine.from])) {
                        end = to1;
                        break;
                    }
                }
                let ranges = [], m1;
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while((m1 = this.regexp.exec(fromLine.text)) && m1.index < end - fromLine.from){
                        let pos = m1.index + fromLine.from;
                        ranges.push(this.getDeco(m1, view, pos).range(pos, pos + m1[0].length));
                    }
                } else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, to, m)=>ranges.push(this.getDeco(m, view, from).range(from, to))
                    );
                }
                deco = deco.update({
                    filterFrom: start,
                    filterTo: end,
                    filter: (from, to)=>from < start || to > end
                    ,
                    add: ranges
                });
            }
        }
        return deco;
    }
}
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = (styles.tabSize ?? styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = Facet.define({
    combine (configs) {
        let config10 = combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config10.replaceTabs = !supportsTabSize()) config10.specialChars = new RegExp("\t|" + config10.specialChars.source, UnicodeRegexpSupport);
        if (config10.addSpecialChars) config10.specialChars = new RegExp(config10.specialChars.source + "|" + config10.addSpecialChars.source, UnicodeRegexpSupport);
        return config10;
    }
});
function highlightSpecialChars(config11 = {}) {
    return [
        specialCharConfig.of(config11),
        specialCharPlugin()
    ];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        view;
        decorations = Decoration.none;
        decorationCache = Object.create(null);
        decorator;
        constructor(view){
            this.view = view;
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos)=>{
                    let { doc: doc23  } = view.state;
                    let code6 = codePointAt(m[0], 0);
                    if (code6 == 9) {
                        let line = doc23.lineAt(pos);
                        let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)
                        });
                    }
                    return this.decorationCache[code6] || (this.decorationCache[code6] = Decoration.replace({
                        widget: new SpecialCharWidget(conf, code6)
                    }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            } else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: (v)=>v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
function placeholder(code7) {
    if (code7 >= 32) return DefaultPlaceholder;
    if (code7 == 10) return "\u2424";
    return String.fromCharCode(9216 + code7);
}
class SpecialCharWidget extends WidgetType {
    options;
    code;
    constructor(options, code8){
        super();
        this.options = options;
        this.code = code8;
    }
    eq(other) {
        return other.code == this.code;
    }
    toDOM(view) {
        let ph = placeholder(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom) return custom;
        let span5 = document.createElement("span");
        span5.textContent = ph;
        span5.title = desc;
        span5.setAttribute("aria-label", desc);
        span5.className = "cm-specialChar";
        return span5;
    }
    ignoreEvent() {
        return false;
    }
}
class TabWidget extends WidgetType {
    width;
    constructor(width){
        super();
        this.width = width;
    }
    eq(other) {
        return other.width == this.width;
    }
    toDOM() {
        let span6 = document.createElement("span");
        span6.textContent = "\t";
        span6.className = "cm-tab";
        span6.style.width = this.width + "px";
        return span6;
    }
    ignoreEvent() {
        return false;
    }
}
ViewPlugin.fromClass(class {
    height = 1000;
    attrs = {
        style: "padding-bottom: 1000px"
    };
    update(update) {
        let height = update.view.viewState.editorHeight - update.view.defaultLineHeight;
        if (height != this.height) {
            this.height = height;
            this.attrs = {
                style: `padding-bottom: ${height}px`
            };
        }
    }
});
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = Decoration.line({
    class: "cm-activeLine"
});
const activeLineHighlighter = ViewPlugin.fromClass(class {
    decorations;
    constructor(view){
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges){
            if (!r.empty) return Decoration.none;
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: (v)=>v.decorations
});
var BranchName;
(function(BranchName1) {
    BranchName1[BranchName1["Done"] = 0] = "Done";
    BranchName1[BranchName1["Undone"] = 1] = "Undone";
})(BranchName || (BranchName = {}));
const fromHistory = Annotation.define();
const isolateHistory = Annotation.define();
const invertedEffects = Facet.define();
const historyConfig = Facet.define({
    combine (configs) {
        return combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min
        });
    }
});
function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to)=>end = to
    );
    return end;
}
const historyField_ = StateField.define({
    create () {
        return HistoryState.empty;
    },
    update (state37, tr) {
        let config12 = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : undefined;
            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
            let other = from == BranchName.Done ? state37.undone : state37.done;
            if (item) other = updateBranch(other, other.length, config12.minDepth, item);
            else other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == BranchName.Done ? fromHist.rest : other, from == BranchName.Done ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before") state37 = state37.isolate();
        if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state37.addMapping(tr.changes.desc) : state37;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
        if (event) state37 = state37.addChanges(event, time, userEvent, config12.newGroupDelay, config12.minDepth);
        else if (tr.selection) state37 = state37.addSelection(tr.startState.selection, time, userEvent, config12.newGroupDelay);
        if (isolate == "full" || isolate == "after") state37 = state37.isolate();
        return state37;
    },
    toJSON (value) {
        return {
            done: value.done.map((e)=>e.toJSON()
            ),
            undone: value.undone.map((e)=>e.toJSON()
            )
        };
    },
    fromJSON (json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
function history(config13 = {}) {
    return [
        historyField_,
        historyConfig.of(config13),
        EditorView.domEventHandlers({
            beforeinput (e, view) {
                let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command2) return false;
                e.preventDefault();
                return command2(view);
            }
        })
    ];
}
function cmd(side, selection) {
    return function({ state: state38 , dispatch  }) {
        if (!selection && state38.readOnly) return false;
        let historyState = state38.field(historyField_, false);
        if (!historyState) return false;
        let tr = historyState.pop(side, state38, selection);
        if (!tr) return false;
        dispatch(tr);
        return true;
    };
}
const undo = cmd(BranchName.Done, false);
const redo = cmd(BranchName.Undone, false);
const undoSelection = cmd(BranchName.Done, true);
const redoSelection = cmd(BranchName.Undone, true);
function depth(side) {
    return function(state39) {
        let histState = state39.field(historyField_, false);
        if (!histState) return 0;
        let branch = side == BranchName.Done ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
depth(BranchName.Done);
depth(BranchName.Undone);
class HistEvent {
    changes;
    effects;
    mapped;
    startSelection;
    selectionsAfter;
    constructor(changes, effects, mapped, startSelection, selectionsAfter){
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        return {
            changes: this.changes?.toJSON(),
            mapped: this.mapped?.toJSON(),
            startSelection: this.startSelection?.toJSON(),
            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON()
            )
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
        let effects = none2;
        for (let invert of tr.startState.facet(invertedEffects)){
            let result = invert(tr);
            if (result.length) effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty) return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
        return new HistEvent(undefined, none2, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent1 = false;
    a.iterChangedRanges((f, t2)=>ranges.push(f, t2)
    );
    b.iterChangedRanges((_f, _t, f, t3)=>{
        for(let i120 = 0; i120 < ranges.length;){
            let from = ranges[i120++], to = ranges[i120++];
            if (t3 >= from && f <= to) isAdjacent1 = true;
        }
    });
    return isAdjacent1;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i121)=>r.empty != b.ranges[i121].empty
    ).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const none2 = [];
function addSelection(branch, selection) {
    if (!branch.length) {
        return [
            HistEvent.selection([
                selection
            ])
        ];
    } else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - 200));
        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1000000000, lastEvent.setSelAfter(sels));
    }
}
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
function addMappingToBranch(branch, mapping) {
    if (!branch.length) return branch;
    let length = branch.length, selections = none2;
    while(length){
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) {
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        } else {
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [
        HistEvent.selection(selections)
    ] : none2;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)
    ) : none2, extraSelections);
    if (!event.changes) return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
    done;
    undone;
    prevTime;
    prevUserEvent;
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
        } else {
            done = updateBranch(done, done.length, maxLen, event);
        }
        return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state40, selection) {
        let branch = side == BranchName.Done ? this.done : this.undone;
        if (branch.length == 0) return null;
        let event = branch[branch.length - 1];
        if (selection && event.selectionsAfter.length) {
            return state40.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({
                    side,
                    rest: popSelection(branch)
                }),
                userEvent: side == BranchName.Done ? "select.undo" : "select.redo",
                scrollIntoView: true
            });
        } else if (!event.changes) {
            return null;
        } else {
            let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
            return state40.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({
                    side,
                    rest
                }),
                filter: false,
                userEvent: side == BranchName.Done ? "undo" : "redo",
                scrollIntoView: true
            });
        }
    }
    static empty = new HistoryState(none2, none2);
}
const historyKeymap = [
    {
        key: "Mod-z",
        run: undo,
        preventDefault: true
    },
    {
        key: "Mod-y",
        mac: "Mod-Shift-z",
        run: redo,
        preventDefault: true
    },
    {
        key: "Mod-u",
        run: undoSelection,
        preventDefault: true
    },
    {
        key: "Alt-u",
        mac: "Mod-Shift-u",
        run: redoSelection,
        preventDefault: true
    }
];
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range1 {
    from;
    to;
    constructor(from, to){
        this.from = from;
        this.to = to;
    }
}
class NodeProp {
    id;
    perNode;
    deserialize;
    constructor(config14 = {}){
        this.id = nextPropID++;
        this.perNode = !!config14.perNode;
        this.deserialize = config14.deserialize || (()=>{
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    add(match) {
        if (this.perNode) throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function") match = NodeType.match(match);
        return (type)=>{
            let result = match(type);
            return result === undefined ? null : [
                this,
                result
            ];
        };
    }
    static closedBy = new NodeProp({
        deserialize: (str)=>str.split(" ")
    });
    static openedBy = new NodeProp({
        deserialize: (str)=>str.split(" ")
    });
    static group = new NodeProp({
        deserialize: (str)=>str.split(" ")
    });
    static contextHash = new NodeProp({
        perNode: true
    });
    static lookAhead = new NodeProp({
        perNode: true
    });
    static mounted = new NodeProp({
        perNode: true
    });
}
class MountedTree {
    tree;
    overlay;
    parser;
    constructor(tree, overlay, parser4){
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser4;
    }
}
var NodeFlag;
(function(NodeFlag1) {
    NodeFlag1[NodeFlag1["Top"] = 1] = "Top";
    NodeFlag1[NodeFlag1["Skipped"] = 2] = "Skipped";
    NodeFlag1[NodeFlag1["Error"] = 4] = "Error";
    NodeFlag1[NodeFlag1["Anonymous"] = 8] = "Anonymous";
})(NodeFlag || (NodeFlag = {}));
const noProps = Object.create(null);
class NodeType {
    name;
    props;
    id;
    flags;
    constructor(name15, props, id6, flags = 0){
        this.name = name15;
        this.props = props;
        this.id = id6;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) | (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props) for (let src of spec.props){
            if (!Array.isArray(src)) src = src(type);
            if (src) {
                if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
                props[src[0].id] = src[1];
            }
        }
        return type;
    }
    prop(prop) {
        return this.props[prop.id];
    }
    get isTop() {
        return (this.flags & NodeFlag.Top) > 0;
    }
    get isSkipped() {
        return (this.flags & NodeFlag.Skipped) > 0;
    }
    get isError() {
        return (this.flags & NodeFlag.Error) > 0;
    }
    get isAnonymous() {
        return (this.flags & NodeFlag.Anonymous) > 0;
    }
    is(name16) {
        if (typeof name16 == 'string') {
            if (this.name == name16) return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name16) > -1 : false;
        }
        return this.id == name16;
    }
    static none = new NodeType("", Object.create(null), 0, NodeFlag.Anonymous);
    static match(map) {
        let direct = Object.create(null);
        for(let prop in map)for (let name17 of prop.split(" "))direct[name17] = map[prop];
        return (node)=>{
            for(let groups = node.prop(NodeProp.group), i122 = -1; i122 < (groups ? groups.length : 0); i122++){
                let found = direct[i122 < 0 ? node.name : groups[i122]];
                if (found) return found;
            }
        };
    }
}
class NodeSet {
    types;
    constructor(types1){
        this.types = types1;
        for(let i123 = 0; i123 < types1.length; i123++)if (types1[i123].id != i123) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
        let newTypes = [];
        for (let type of this.types){
            let newProps = null;
            for (let source of props){
                let add4 = source(type);
                if (add4) {
                    if (!newProps) newProps = Object.assign({}, type.props);
                    newProps[add4[0].id] = add4[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
class Tree1 {
    type;
    children;
    positions;
    length;
    props = null;
    constructor(type, children, positions, length, props){
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay) return mounted.tree.toString();
        let children = "";
        for (let ch of this.children){
            let str = ch.toString();
            if (str) {
                if (children) children += ",";
                children += str;
            }
        }
        return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    static empty = new Tree1(NodeType.none, [], [], 0);
    cursor(pos, side = 0) {
        let scope = pos != null && CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    fullCursor() {
        return new TreeCursor(this.topNode, Mode.Full);
    }
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    iterate(spec) {
        let { enter , leave , from =0 , to =this.length  } = spec;
        for(let c = this.cursor(), get8 = ()=>c.node
        ;;){
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get8) !== false)) {
                if (c.firstChild()) continue;
                if (!c.type.isAnonymous) mustLeave = true;
            }
            for(;;){
                if (mustLeave && leave) leave(c.type, c.from, c.to, get8);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling()) break;
                if (!c.parent()) return;
                mustLeave = true;
            }
        }
    }
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    get propValues() {
        let result = [];
        if (this.props) for(let id7 in this.props)result.push([
            +id7,
            this.props[id7]
        ]);
        return result;
    }
    balance(config15 = {}) {
        return this.children.length <= Balance.BranchFactor ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree1(this.type, children, positions, length, this.propValues)
        , config15.makeTree || ((children, positions, length)=>new Tree1(NodeType.none, children, positions, length)
        ));
    }
    static build(data3) {
        return buildTree(data3);
    }
}
class FlatBufferCursor {
    buffer;
    index;
    constructor(buffer, index){
        this.buffer = buffer;
        this.index = index;
    }
    get id() {
        return this.buffer[this.index - 4];
    }
    get start() {
        return this.buffer[this.index - 3];
    }
    get end() {
        return this.buffer[this.index - 2];
    }
    get size() {
        return this.buffer[this.index - 1];
    }
    get pos() {
        return this.index;
    }
    next() {
        this.index -= 4;
    }
    fork() {
        return new FlatBufferCursor(this.buffer, this.index);
    }
}
class TreeBuffer {
    buffer;
    length;
    set;
    constructor(buffer, length, set){
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    get type() {
        return NodeType.none;
    }
    toString() {
        let result = [];
        for(let index = 0; index < this.buffer.length;){
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    childString(index) {
        let id8 = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id8], result = type.name;
        if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
        index += 4;
        if (endIndex == index) return result;
        let children = [];
        while(index < endIndex){
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer  } = this, pick = -1;
        for(let i124 = startIndex; i124 != endIndex; i124 = buffer[i124 + 3]){
            if (checkSide(side, pos, buffer[i124 + 1], buffer[i124 + 2])) {
                pick = i124;
                if (dir > 0) break;
            }
        }
        return pick;
    }
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy2 = new Uint16Array(endI - startI);
        for(let i125 = startI, j = 0; i125 < endI;){
            copy2[j++] = b[i125++];
            copy2[j++] = b[i125++] - from;
            copy2[j++] = b[i125++] - from;
            copy2[j++] = b[i125++] - startI;
        }
        return new TreeBuffer(copy2, to - from, this.set);
    }
}
var Side1;
(function(Side3) {
    Side3[Side3["Before"] = -2] = "Before";
    Side3[Side3["AtOrBefore"] = -1] = "AtOrBefore";
    Side3[Side3["Around"] = 0] = "Around";
    Side3[Side3["AtOrAfter"] = 1] = "AtOrAfter";
    Side3[Side3["After"] = 2] = "After";
    Side3[Side3["DontCare"] = 4] = "DontCare";
})(Side1 || (Side1 = {}));
function checkSide(side, pos, from, to) {
    switch(side){
        case Side1.Before:
            return from < pos;
        case Side1.AtOrBefore:
            return to >= pos && from < pos;
        case Side1.Around:
            return from < pos && to > pos;
        case Side1.AtOrAfter:
            return from <= pos && to > pos;
        case Side1.After:
            return to > pos;
        case Side1.DontCare:
            return true;
    }
}
var Mode;
(function(Mode2) {
    Mode2[Mode2["Full"] = 1] = "Full";
    Mode2[Mode2["NoEnterBuffer"] = 2] = "NoEnterBuffer";
})(Mode || (Mode = {}));
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while(scan){
        let last = scan.lastChild;
        if (!last || last.to != scan.to) break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        } else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent) return node;
        node = parent;
    }
    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){
        if (scan instanceof TreeNode && scan.index < 0 && parent.enter(pos, side, true)?.from != scan.from) node = parent;
    }
    for(;;){
        let inner = node.enter(pos, side, overlays);
        if (!inner) return node;
        node = inner;
    }
}
class TreeNode {
    node;
    _from;
    index;
    _parent;
    constructor(node, _from2, index, _parent){
        this.node = node;
        this._from = _from2;
        this.index = index;
        this._parent = _parent;
    }
    get type() {
        return this.node.type;
    }
    get name() {
        return this.node.type.name;
    }
    get from() {
        return this._from;
    }
    get to() {
        return this._from + this.node.length;
    }
    nextChild(i126, dir, pos, side, mode = 0) {
        for(let parent = this;;){
            for(let { children , positions  } = parent.node, e = dir > 0 ? children.length : -1; i126 != e; i126 += dir){
                let next = children[i126], start = positions[i126] + parent._from;
                if (!checkSide(side, pos, start, start + next.length)) continue;
                if (next instanceof TreeBuffer) {
                    if (mode & Mode.NoEnterBuffer) continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i126, start), null, index);
                } else if (mode & Mode.Full || !next.type.isAnonymous || hasChild(next)) {
                    let mounted;
                    if (!(mode & Mode.Full) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i126, parent);
                    let inner = new TreeNode(next, start, i126, parent);
                    return mode & Mode.Full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if (mode & Mode.Full || !parent.type.isAnonymous) return null;
            if (parent.index >= 0) i126 = parent.index + dir;
            else i126 = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent) return null;
        }
    }
    get firstChild() {
        return this.nextChild(0, 1, 0, Side1.DontCare);
    }
    get lastChild() {
        return this.nextChild(this.node.children.length - 1, -1, 0, Side1.DontCare);
    }
    childAfter(pos) {
        return this.nextChild(0, 1, pos, Side1.After);
    }
    childBefore(pos) {
        return this.nextChild(this.node.children.length - 1, -1, pos, Side1.Before);
    }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from , to  } of mounted.overlay){
                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : Mode.NoEnterBuffer);
    }
    nextSignificantParent() {
        let val = this;
        while(val.type.isAnonymous && val._parent)val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, Side1.DontCare) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, Side1.DontCare) : null;
    }
    get cursor() {
        return new TreeCursor(this);
    }
    get tree() {
        return this.node;
    }
    toTree() {
        return this.node;
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
        return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    toString() {
        return this.node.toString();
    }
}
function getChildren(node, type, before, after) {
    let cur16 = node.cursor, result = [];
    if (!cur16.firstChild()) return result;
    if (before != null) {
        while(!cur16.type.is(before))if (!cur16.nextSibling()) return result;
    }
    for(;;){
        if (after != null && cur16.type.is(after)) return result;
        if (cur16.type.is(type)) result.push(cur16.node);
        if (!cur16.nextSibling()) return after == null ? result : [];
    }
}
class BufferContext {
    parent;
    buffer;
    index;
    start;
    constructor(parent, buffer, index, start){
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    context;
    _parent;
    index;
    type;
    get name() {
        return this.type.name;
    }
    get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index){
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
        let { buffer  } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
        return this.child(1, 0, Side1.DontCare);
    }
    get lastChild() {
        return this.child(-1, 0, Side1.DontCare);
    }
    childAfter(pos) {
        return this.child(1, pos, Side1.After);
    }
    childBefore(pos) {
        return this.child(-1, pos, Side1.Before);
    }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers) return null;
        let { buffer  } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, Side1.DontCare);
    }
    get nextSibling() {
        let { buffer  } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer  } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart) return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, Side1.DontCare));
    }
    get cursor() {
        return new TreeCursor(this);
    }
    get tree() {
        return null;
    }
    toTree() {
        let children = [], positions = [];
        let { buffer  } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree1(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
        return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
        return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
class TreeCursor {
    mode;
    type;
    get name() {
        return this.type.name;
    }
    from;
    to;
    _tree;
    buffer = null;
    stack = [];
    index = 0;
    bufferNode = null;
    constructor(node, mode = 0){
        this.mode = mode;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        } else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    yieldNode(node) {
        if (!node) return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start , buffer  } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node) return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer  } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0) return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    firstChild() {
        return this.enterChild(1, 0, Side1.DontCare);
    }
    lastChild() {
        return this.enterChild(-1, 0, Side1.DontCare);
    }
    childAfter(pos) {
        return this.enterChild(1, pos, Side1.After);
    }
    childBefore(pos) {
        return this.enterChild(-1, pos, Side1.Before);
    }
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer) return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & Mode.Full), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    parent() {
        if (!this.buffer) return this.yieldNode(this.mode & Mode.Full ? this._tree._parent : this._tree.parent);
        if (this.stack.length) return this.yieldBuf(this.stack.pop());
        let parent = this.mode & Mode.Full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    sibling(dir) {
        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, Side1.DontCare, this.mode));
        let { buffer  } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, Side1.DontCare));
        } else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, Side1.DontCare, this.mode)) : false;
    }
    nextSibling() {
        return this.sibling(1);
    }
    prevSibling() {
        return this.sibling(-1);
    }
    atLastNode(dir) {
        let index, parent, { buffer  } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length) return false;
            } else {
                for(let i127 = 0; i127 < this.index; i127++)if (buffer.buffer.buffer[i127 + 3] < this.index) return false;
            }
            ({ index , parent  } = buffer);
        } else {
            ({ index , _parent: parent  } = this._tree);
        }
        for(; parent; { index , _parent: parent  } = parent){
            if (index > -1) for(let i128 = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i128 != e; i128 += dir){
                let child = parent.node.children[i128];
                if (this.mode & Mode.Full || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
            }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, Side1.DontCare)) return true;
        for(;;){
            if (this.sibling(dir)) return true;
            if (this.atLastNode(dir) || !this.parent()) return false;
        }
    }
    next(enter = true) {
        return this.move(1, enter);
    }
    prev(enter = true) {
        return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;
        while(this.enterChild(1, pos, side)){}
        return this;
    }
    get node() {
        if (!this.buffer) return this._tree;
        let cache = this.bufferNode, result = null, depth1 = 0;
        if (cache && cache.context == this.buffer) {
            scan: for(let index = this.index, d = this.stack.length; d >= 0;){
                for(let c = cache; c; c = c._parent)if (c.index == index) {
                    if (index == this.index) return c;
                    result = c;
                    depth1 = d + 1;
                    break scan;
                }
                index = this.stack[--d];
            }
        }
        for(let i129 = depth1; i129 < this.stack.length; i129++)result = new BufferNode(this.buffer, result, this.stack[i129]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch)
    );
}
var Balance;
(function(Balance1) {
    Balance1[Balance1["BranchFactor"] = 8] = "BranchFactor";
})(Balance || (Balance = {}));
var SpecialRecord;
(function(SpecialRecord1) {
    SpecialRecord1[SpecialRecord1["Reuse"] = -1] = "Reuse";
    SpecialRecord1[SpecialRecord1["ContextChange"] = -3] = "ContextChange";
    SpecialRecord1[SpecialRecord1["LookAhead"] = -4] = "LookAhead";
})(SpecialRecord || (SpecialRecord = {}));
function buildTree(data1) {
    let { buffer: buffer1 , nodeSet , maxBufferLength =1024 , reused =[] , minRepeatType =nodeSet.types.length  } = data1;
    let cursor = Array.isArray(buffer1) ? new FlatBufferCursor(buffer1, buffer1.length) : buffer1;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead1 = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id: id9 , start , end , size  } = cursor;
        let lookAheadAtStart = lookAhead1;
        while(size < 0){
            cursor.next();
            if (size == SpecialRecord.Reuse) {
                let node = reused[id9];
                children.push(node);
                positions.push(start - parentStart);
                return;
            } else if (size == SpecialRecord.ContextChange) {
                contextHash = id9;
                return;
            } else if (size == SpecialRecord.LookAhead) {
                lookAhead1 = id9;
                return;
            } else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
            ({ id: id9 , start , end , size  } = cursor);
        }
        let type = types2[id9], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            let data4 = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data4.length;
            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data4, index);
            node = new TreeBuffer(data4, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        } else {
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id9 >= minRepeatType ? id9 : -1;
            let lastGroup = 0, lastEnd = end;
            while(cursor.pos > endPos){
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                } else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            } else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length)=>{
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree1) {
                if (!lastI && last.type == type && last.length == length) return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base12, i130, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while(children.length > i130){
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base12 - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base12);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair1 = [
                NodeProp.contextHash,
                contextHash
            ];
            props = props ? [
                pair1
            ].concat(props) : [
                pair1
            ];
        }
        if (lookAhead > 25) {
            let pair2 = [
                NodeProp.lookAhead,
                lookAhead
            ];
            props = props ? [
                pair2
            ].concat(props) : [
                pair2
            ];
        }
        return new Tree1(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = {
            size: 0,
            start: 0,
            skip: 0
        };
        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){
            let nodeSize1 = fork.size;
            if (fork.id == inRepeat && nodeSize1 >= 0) {
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize1;
            if (nodeSize1 < 0 || startPos < minPos || fork.start < minStart) break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart2 = fork.start;
            fork.next();
            while(fork.pos > startPos){
                if (fork.size < 0) {
                    if (fork.size == SpecialRecord.ContextChange) localSkipped += 4;
                    else break scan;
                } else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart2;
            size += nodeSize1;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id: id10 , start , end , size  } = cursor;
        cursor.next();
        if (size >= 0 && id10 < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id10;
        } else if (size == SpecialRecord.ContextChange) {
            contextHash = id10;
        } else if (size == SpecialRecord.LookAhead) {
            lookAhead1 = id10;
        }
        return index;
    }
    let children1 = [], positions1 = [];
    while(cursor.pos > 0)takeNode(data1.start || 0, data1.bufferStart || 0, children1, positions1, -1);
    let length1 = data1.length ?? (children1.length ? positions1[0] + children1[0].length : 0);
    return new Tree1(types2[data1.topID], children1.reverse(), positions1.reverse(), length1);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children){
            if (child.type != balanceType || !(child instanceof Tree1)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(balanceType, children2, positions2, from1, to1, start, length2, mkTop, mkTree) {
    let total = 0;
    for(let i1 = from1; i1 < to1; i1++)total += nodeSize(balanceType, children2[i1]);
    let maxChild = Math.ceil(total * 1.5 / Balance.BranchFactor);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for(let i131 = from; i131 < to;){
            let groupFrom = i131, groupStart = positions[i131], groupSize = nodeSize(balanceType, children[i131]);
            i131++;
            for(; i131 < to; i131++){
                let nextSize = nodeSize(balanceType, children[i131]);
                if (groupSize + nextSize >= maxChild) break;
                groupSize += nextSize;
            }
            if (i131 == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom];
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            } else {
                let length = positions[i131 - 1] + children[i131 - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i131, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children2, positions2, from1, to1, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length2);
}
var Open1;
(function(Open3) {
    Open3[Open3["Start"] = 1] = "Start";
    Open3[Open3["End"] = 2] = "End";
})(Open1 || (Open1 = {}));
class TreeFragment {
    from;
    to;
    tree;
    offset;
    open;
    constructor(from, to, tree, offset, openStart = false, openEnd = false){
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? Open1.Start : 0) | (openEnd ? Open1.End : 0);
    }
    get openStart() {
        return (this.open & Open1.Start) > 0;
    }
    get openEnd() {
        return (this.open & Open1.End) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
        let result = [
            new TreeFragment(0, tree.length, tree, 0, false, partial)
        ];
        for (let f of fragments)if (f.to > tree.length) result.push(f);
        return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length) return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for(let cI = 0, pos = 0, off = 0;; cI++){
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1000000000;
            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){
                let cut = nextF;
                if (pos >= cut.from || nextPos <= cut.to || off) {
                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                }
                if (cut) result.push(cut);
                if (nextF.to > nextPos) break;
                nextF = fI < fragments.length ? fragments[fI++] : null;
            }
            if (!nextC) break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
class Parser {
    startParse(input, fragments, ranges) {
        if (typeof input == "string") input = new StringInput(input);
        ranges = !ranges ? [
            new Range1(0, input.length)
        ] : ranges.length ? ranges.map((r)=>new Range1(r.from, r.to)
        ) : [
            new Range1(0, 0)
        ];
        return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
        let parse4 = this.startParse(input, fragments, ranges);
        for(;;){
            let done = parse4.advance();
            if (done) return done;
        }
    }
}
class StringInput {
    string;
    constructor(string5){
        this.string = string5;
    }
    get length() {
        return this.string.length;
    }
    chunk(from) {
        return this.string.slice(from);
    }
    get lineChunks() {
        return false;
    }
    read(from, to) {
        return this.string.slice(from, to);
    }
}
function parseMixed(nest) {
    return (parse5, input, fragments, ranges)=>new MixedParse(parse5, nest, input, fragments, ranges)
    ;
}
class InnerParse {
    parser;
    parse;
    overlay;
    target;
    ranges;
    constructor(parser5, parse6, overlay, target, ranges){
        this.parser = parser5;
        this.parse = parse6;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    parser;
    predicate;
    mounts;
    index;
    start;
    target;
    prev;
    depth = 0;
    ranges = [];
    constructor(parser6, predicate, mounts, index, start, target, prev){
        this.parser = parser6;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
    }
}
const stoppedInner = new NodeProp({
    perNode: true
});
class MixedParse {
    nest;
    input;
    fragments;
    ranges;
    baseParse;
    inner = [];
    innerDone = 0;
    baseTree = null;
    stoppedAt = null;
    constructor(base13, nest, input, fragments, ranges){
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.baseParse = base13;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done) return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null) result = new Tree1(result.type, result.children, result.positions, result.length, result.propValues.concat([
                [
                    stoppedInner,
                    this.stoppedAt
                ]
            ]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse) return 0;
        let pos = this.input.length;
        for(let i132 = this.innerDone; i132 < this.inner.length; i132++){
            if (this.inner[i132].ranges[0].from < pos) pos = Math.min(pos, this.inner[i132].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse) this.baseParse.stopAt(pos);
        else for(let i133 = this.innerDone; i133 < this.inner.length; i133++)this.inner[i133].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), Mode.Full);
        scan: for(let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;){
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay
                    );
                    if (match) for (let r of match.mount.overlay){
                        let from = r.from + match.pos, to = r.to + match.pos;
                        if (from >= cursor.from && to <= cursor.to) overlay.ranges.push({
                            from,
                            to
                        });
                    }
                }
                enter = false;
            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != Cover.Full;
            } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree) materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                } else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [
                        new Range1(cursor.from, cursor.to)
                    ]);
                    if (ranges.length) this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map((r)=>new Range1(r.from - cursor.from, r.to - cursor.from)
                    ) : null, cursor.tree, ranges));
                    if (!nest.overlay) enter = false;
                    else if (ranges.length) covered = {
                        ranges,
                        depth: 0,
                        prev: covered
                    };
                }
            } else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true) range = new Range1(cursor.from, cursor.to);
                if (range.from < range.to) overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay) overlay.depth++;
                if (covered) covered.depth++;
            } else {
                for(;;){
                    if (cursor.nextSibling()) break;
                    if (!cursor.parent()) break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length) this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range1(r.from - overlay.start, r.to - overlay.start)
                        ), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth) covered = covered.prev;
                }
            }
        }
    }
}
var Cover;
(function(Cover1) {
    Cover1[Cover1["None"] = 0] = "None";
    Cover1[Cover1["Partial"] = 1] = "Partial";
    Cover1[Cover1["Full"] = 2] = "Full";
})(Cover || (Cover = {}));
function checkCover(covered, from, to) {
    for (let range of covered){
        if (range.from >= to) break;
        if (range.to > from) return range.from <= from && range.to >= to ? Cover.Full : Cover.Partial;
    }
    return Cover.None;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
function materialize(cursor) {
    let { node  } = cursor, depth2 = 0;
    do {
        cursor.parent();
        depth2++;
    }while (!cursor.tree)
    let i1 = 0, base14 = cursor.tree, off = 0;
    for(;; i1++){
        off = base14.positions[i1] + cursor.from;
        if (off <= node.from && off + base14.children[i1].length >= node.to) break;
    }
    let buf = base14.children[i1], b = buf.buffer;
    function split(startI, endI, type, innerOffset, length) {
        let i134 = startI;
        while(b[i134 + 2] + off <= node.from)i134 = b[i134 + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i134, children, positions, innerOffset);
        let from = b[i134 + 1], to = b[i134 + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i134] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i134 + 4, b[i134 + 3], buf.set.types[b[i134]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i134 + 3], endI, children, positions, innerOffset);
        return new Tree1(type, children, positions, length);
    }
    base14.children[i1] = split(0, b.length, NodeType.none, 0, buf.length);
    for(let d = 0; d <= depth2; d++)cursor.childAfter(node.from);
}
class StructureCursor {
    offset;
    cursor;
    done = false;
    constructor(root, offset){
        this.offset = offset;
        this.cursor = root.fullCursor();
    }
    moveTo(pos) {
        let { cursor  } = this, p12 = pos - this.offset;
        while(!this.done && cursor.from < p12){
            if (cursor.to >= pos && cursor.enter(p12, 1, false, false)) {} else if (!cursor.next(false)) this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for(let tree = this.cursor.tree;;){
                if (tree == cursor.tree) return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree1) tree = tree.children[0];
                else break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    fragments;
    curFrag;
    curTo = 0;
    fragI = 0;
    inner;
    constructor(fragments){
        this.fragments = fragments;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = first.tree.prop(stoppedInner) ?? first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        } else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while(this.curFrag && node.from >= this.curTo)this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        } else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = frag.tree.prop(stoppedInner) ?? frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser7) {
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for(let pos1 = this.inner.cursor.node; pos1; pos1 = pos1.parent){
                let mount = pos1.tree?.prop(NodeProp.mounted);
                if (mount && mount.parser == parser7) {
                    for(let i135 = this.fragI; i135 < this.fragments.length; i135++){
                        let frag = this.fragments[i135];
                        if (frag.from >= pos1.to) break;
                        if (frag.tree == this.curFrag.tree) result.push({
                            frag,
                            pos: pos1.from - frag.offset,
                            mount
                        });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy3 = null, current = ranges;
    for(let i136 = 1, j = 0; i136 < outer.length; i136++){
        let gapFrom = outer[i136 - 1].to, gapTo = outer[i136].from;
        for(; j < current.length; j++){
            let r = current[j];
            if (r.from >= gapTo) break;
            if (r.to <= gapFrom) continue;
            if (!copy3) current = copy3 = ranges.slice();
            if (r.from < gapFrom) {
                copy3[j] = new Range1(r.from, gapFrom);
                if (r.to > gapTo) copy3.splice(j + 1, 0, new Range1(gapTo, r.to));
            } else if (r.to > gapTo) {
                copy3[j--] = new Range1(gapTo, r.to);
            } else {
                copy3.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1000000000;
    let result = [];
    for(;;){
        let nextA = iA == a.length ? 1000000000 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1000000000 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end) result.push(new Range1(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1000000000) break;
        if (nextA == pos) {
            if (!inA) inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB) inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos , mount , frag  } of mounts){
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map((r)=>new Range1(r.from + pos, r.to + pos)
            );
            let changes = findCoverChanges(ranges, overlay, from, to);
            for(let i137 = 0, pos2 = from;; i137++){
                let last = i137 == changes.length, end = last ? to : changes[i137].from;
                if (end > pos2) result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2, frag.to <= end));
                if (last) break;
                pos2 = changes[i137].to;
            }
        } else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}
const languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
    return Facet.define({
        combine: baseData ? (values11)=>values11.concat(baseData)
         : undefined
    });
}
class Language {
    data;
    topNode;
    extension;
    parser;
    constructor(data5, parser8, topNode, extraExtensions = []){
        this.data = data5;
        this.topNode = topNode;
        if (!EditorState.prototype.hasOwnProperty("tree")) Object.defineProperty(EditorState.prototype, "tree", {
            get () {
                return syntaxTree(this);
            }
        });
        this.parser = parser8;
        this.extension = [
            language.of(this),
            EditorState.languageData.of((state41, pos, side)=>state41.facet(languageDataFacetAt(state41, pos, side))
            )
        ].concat(extraExtensions);
    }
    isActiveAt(state42, pos, side = -1) {
        return languageDataFacetAt(state42, pos, side) == this.data;
    }
    findRegions(state43) {
        let lang = state43.facet(language);
        if (lang?.data == this.data) return [
            {
                from: 0,
                to: state43.doc.length
            }
        ];
        if (!lang || !lang.allowsNesting) return [];
        let result = [];
        let explore = (tree, from)=>{
            if (tree.prop(languageDataProp) == this.data) {
                result.push({
                    from,
                    to: from + tree.length
                });
                return;
            }
            let mount = tree.prop(NodeProp.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay) for (let r of mount.overlay)result.push({
                        from: r.from + from,
                        to: r.to + from
                    });
                    else result.push({
                        from: from,
                        to: from + tree.length
                    });
                    return;
                } else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size) return;
                }
            }
            for(let i138 = 0; i138 < tree.children.length; i138++){
                let ch = tree.children[i138];
                if (ch instanceof Tree1) explore(ch, tree.positions[i138] + from);
            }
        };
        explore(syntaxTree(state43), 0);
        return result;
    }
    get allowsNesting() {
        return true;
    }
    static state;
    static setState = StateEffect.define();
}
function languageDataFacetAt(state44, pos, side) {
    let topLang = state44.facet(language);
    if (!topLang) return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
        for(let node = syntaxTree(state44).topNode; node; node = node.enter(pos, side, true, false))facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
}
class LRLanguage extends Language {
    parser;
    constructor(data6, parser9){
        super(data6, parser9, parser9.topNode);
        this.parser = parser9;
    }
    static define(spec) {
        let data7 = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data7, spec.parser.configure({
            props: [
                languageDataProp.add((type)=>type.isTop ? data7 : undefined
                )
            ]
        }));
    }
    configure(options) {
        return new LRLanguage(this.data, this.parser.configure(options));
    }
    get allowsNesting() {
        return this.parser.wrappers.length > 0;
    }
}
function syntaxTree(state45) {
    let field = state45.field(Language.state, false);
    return field ? field.tree : Tree1.empty;
}
class DocInput {
    doc;
    length;
    cursor;
    cursorPos = 0;
    string = "";
    constructor(doc24, length = doc24.length){
        this.doc = doc24;
        this.length = length;
        this.cursor = doc24.iter();
    }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() {
        return true;
    }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);
        else return this.string.slice(from - stringStart, to - stringStart);
    }
}
var Work;
(function(Work1) {
    Work1[Work1["Apply"] = 20] = "Apply";
    Work1[Work1["MinSlice"] = 25] = "MinSlice";
    Work1[Work1["Slice"] = 100] = "Slice";
    Work1[Work1["MinPause"] = 100] = "MinPause";
    Work1[Work1["MaxPause"] = 500] = "MaxPause";
    Work1[Work1["ChunkBudget"] = 3000] = "ChunkBudget";
    Work1[Work1["ChunkTime"] = 30000] = "ChunkTime";
    Work1[Work1["ChangeBonus"] = 50] = "ChangeBonus";
    Work1[Work1["MaxParseAhead"] = 100000] = "MaxParseAhead";
    Work1[Work1["InitViewport"] = 3000] = "InitViewport";
})(Work || (Work = {}));
let currentContext = null;
class ParseContext {
    parser;
    state;
    fragments;
    tree;
    treeLen;
    viewport;
    skipped;
    scheduleOn;
    parse = null;
    tempSkipped = [];
    constructor(parser10, state46, fragments = [], tree, treeLen, viewport, skipped, scheduleOn){
        this.parser = parser10;
        this.state = state46;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(time, upto) {
        if (upto != null && upto >= this.state.doc.length) upto = undefined;
        if (this.tree != Tree1.empty && this.isDone(upto ?? this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(()=>{
            let endTime = Date.now() + time;
            if (!this.parse) this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
            for(;;){
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = this.parse.stoppedAt ?? this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto ?? this.state.doc.length)) this.parse = this.startParse();
                    else return true;
                }
                if (Date.now() > endTime) return false;
            }
        });
    }
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
            this.withContext(()=>{
                while(!(tree = this.parse.advance())){}
            });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        } finally{
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    changes(changes, newState) {
        let { fragments , tree , treeLen , viewport , skipped  } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({
                    fromA,
                    toA,
                    fromB,
                    toB
                })
            );
            fragments = TreeFragment.applyChanges(fragments, ranges);
            tree = Tree1.empty;
            treeLen = 0;
            viewport = {
                from: changes.mapPos(viewport.from, -1),
                to: changes.mapPos(viewport.to, 1)
            };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped){
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to) skipped.push({
                        from,
                        to
                    });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for(let i139 = 0; i139 < this.skipped.length; i139++){
            let { from , to  } = this.skipped[i139];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i139--, 1);
            }
        }
        if (this.skipped.length >= startLen) return false;
        this.reset();
        return true;
    }
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    skipUntilInView(from, to) {
        this.skipped.push({
            from,
            to
        });
    }
    static getSkippingParser(until) {
        return new class extends Parser {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser11 = {
                    parsedPos: from,
                    advance () {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)cx.tempSkipped.push(r);
                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([
                                cx.scheduleOn,
                                until
                            ]) : until;
                        }
                        this.parsedPos = to;
                        return new Tree1(NodeType.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt () {}
                };
                return parser11;
            }
        };
    }
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
        return currentContext;
    }
}
function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [
        {
            fromA: from,
            toA: to,
            fromB: from,
            toB: to
        }
    ]);
}
class LanguageState {
    context;
    tree;
    constructor(context){
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged) return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(Work.Apply, upto)) newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state47) {
        let vpTo = Math.min(Work.InitViewport, state47.doc.length);
        let parseState = new ParseContext(state47.facet(language).parser, state47, [], Tree1.empty, 0, {
            from: 0,
            to: vpTo
        }, [], null);
        if (!parseState.work(Work.Apply, vpTo)) parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = StateField.define({
    create: LanguageState.init,
    update (value, tr) {
        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback)=>{
    let timeout = setTimeout(()=>callback()
    , Work.MaxPause);
    return ()=>clearTimeout(timeout)
    ;
};
if (typeof requestIdleCallback != "undefined") requestIdle = (callback)=>{
    let idle = -1, timeout = setTimeout(()=>{
        idle = requestIdleCallback(callback, {
            timeout: Work.MaxPause - Work.MinPause
        });
    }, Work.MinPause);
    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle)
    ;
};
const parseWorker = ViewPlugin.fromClass(class ParseWorker {
    view;
    working = null;
    workScheduled = 0;
    chunkEnd = -1;
    chunkBudget = -1;
    constructor(view){
        this.view = view;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
        if (update.docChanged) {
            if (this.view.hasFocus) this.chunkBudget += Work.ChangeBonus;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working) return;
        let { state: state48  } = this.view, field = state48.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state48.doc.length)) this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
            this.chunkEnd = now + Work.ChunkTime;
            this.chunkBudget = Work.ChunkBudget;
        }
        if (this.chunkBudget <= 0) return;
        let { state: state49 , viewport: { to: vpTo  }  } = this.view, field = state49.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + Work.MaxParseAhead)) return;
        let time = Math.min(this.chunkBudget, Work.Slice, deadline ? Math.max(Work.MinSlice, deadline.timeRemaining() - 5) : 1000000000);
        let viewportFirst = field.context.treeLen < vpTo && state49.doc.length > vpTo + 1000;
        let done = field.context.work(time, vpTo + (viewportFirst ? 0 : Work.MaxParseAhead));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({
                effects: Language.setState.of(new LanguageState(field.context))
            });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn.then(()=>this.scheduleWork()
            ).catch((err)=>logException(this.view.state, err)
            ).then(()=>this.workScheduled--
            );
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working) this.working();
    }
    isWorking() {
        return this.working || this.workScheduled > 0;
    }
}, {
    eventHandlers: {
        focus () {
            this.scheduleWork();
        }
    }
});
const language = Facet.define({
    combine (languages) {
        return languages.length ? languages[0] : null;
    },
    enables: [
        Language.state,
        parseWorker
    ]
});
class LanguageSupport {
    language;
    support;
    extension;
    constructor(language1, support = []){
        this.language = language1;
        this.support = support;
        this.extension = [
            language1,
            support
        ];
    }
}
class LanguageDescription {
    name;
    alias;
    extensions;
    filename;
    loadFunc;
    support;
    loading = null;
    constructor(name18, alias, extensions, filename, loadFunc, support = undefined){
        this.name = name18;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
    }
    load() {
        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support
        , (err)=>{
            this.loading = null;
            throw err;
        }));
    }
    static of(spec) {
        let { load , support  } = spec;
        if (!load) {
            if (!support) throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = ()=>Promise.resolve(support)
            ;
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()
        ), spec.extensions || [], spec.filename, load, support);
    }
    static matchFilename(descs, filename) {
        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext) {
            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;
        }
        return null;
    }
    static matchLanguageName(descs, name19, fuzzy = true) {
        name19 = name19.toLowerCase();
        for (let d of descs)if (d.alias.some((a)=>a == name19
        )) return d;
        if (fuzzy) for (let d1 of descs)for (let a1 of d1.alias){
            let found = name19.indexOf(a1);
            if (found > -1 && (a1.length > 2 || !/\w/.test(name19[found - 1]) && !/\w/.test(name19[found + a1.length]))) return d1;
        }
        return null;
    }
}
const indentService = Facet.define();
const indentUnit = Facet.define({
    combine: (values12)=>{
        if (!values12.length) return "  ";
        if (!/^(?: +|\t+)$/.test(values12[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values12[0]));
        return values12[0];
    }
});
function getIndentUnit(state50) {
    let unit = state50.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state50.tabSize * unit.length : unit.length;
}
function indentString(state51, cols) {
    let result = "", ts = state51.tabSize;
    if (state51.facet(indentUnit).charCodeAt(0) == 9) while(cols >= ts){
        result += "\t";
        cols -= ts;
    }
    for(let i140 = 0; i140 < cols; i140++)result += " ";
    return result;
}
function getIndentation(context, pos) {
    if (context instanceof EditorState) context = new IndentContext(context);
    for (let service of context.state.facet(indentService)){
        let result = service(context, pos);
        if (result != null) return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
}
class IndentContext {
    state;
    options;
    unit;
    constructor(state52, options = {}){
        this.state = state52;
        this.options = options;
        this.unit = getIndentUnit(state52);
    }
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak , simulateDoubleBreak  } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos) return {
                text: "",
                from: pos
            };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
                text: line.text.slice(simulateBreak - line.from),
                from: simulateBreak
            };
            else return {
                text: line.text.slice(0, simulateBreak - line.from),
                from: line.from
            };
        }
        return line;
    }
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
        let { text , from  } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
        let { text , from  } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1) result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    countColumn(line, pos = line.length) {
        return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
        let { text , from  } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1) return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
const indentNodeProp = new NodeProp();
function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy) return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined)
        ;
    }
    return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base15) {
    for(; node; node = node.parent){
        let strategy = indentStrategy(node);
        if (strategy) return strategy(new TreeIndentContext(base15, pos, node));
    }
    return null;
}
function topIndent() {
    return 0;
}
class TreeIndentContext extends IndentContext {
    base;
    pos;
    node;
    constructor(base16, pos, node){
        super(base16.state, base16.options);
        this.base = base16;
        this.pos = pos;
        this.node = node;
    }
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    get baseIndent() {
        let line = this.state.doc.lineAt(this.node.from);
        for(;;){
            let atBreak = this.node.resolve(line.from);
            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;
            if (isParent(atBreak, this.node)) break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    continue() {
        let parent = this.node.parent;
        return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
}
function isParent(parent, of) {
    for(let cur17 = of; cur17; cur17 = cur17.parent)if (parent == cur17) return true;
    return false;
}
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken) return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd1 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for(let pos = openToken.to;;){
        let next = tree.childAfter(pos);
        if (!next || next == last) return null;
        if (!next.type.isSkipped) return next.from < lineEnd1 ? openToken : null;
        pos = next.to;
    }
}
function delimitedIndent({ closing: closing1 , align =true , units =1  }) {
    return (context)=>delimitedStrategy(context, align, units, closing1)
    ;
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space3 = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space3, space3 + closing2.length) == closing2 || closedAt == context.pos + space3;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = (context)=>context.baseIndent
;
function continuedIndent({ except , units =1  } = {}) {
    return (context)=>{
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
function indentOnInput() {
    return EditorState.transactionFilter.of((tr)=>{
        if (!tr.docChanged || !tr.isUserEvent("input.type")) return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length) return tr;
        let doc25 = tr.newDoc, { head  } = tr.newSelection.main, line = doc25.lineAt(head);
        if (head > line.from + 200) return tr;
        let lineStart = doc25.sliceString(line.from, head);
        if (!rules.some((r)=>r.test(lineStart)
        )) return tr;
        let { state: state53  } = tr, last = -1, changes = [];
        for (let { head: head1  } of state53.selection.ranges){
            let line = state53.doc.lineAt(head1);
            if (line.from == last) continue;
            last = line.from;
            let indent = getIndentation(state53, line.from);
            if (indent == null) continue;
            let cur18 = /^\s*/.exec(line.text)[0];
            let norm = indentString(state53, indent);
            if (cur18 != norm) changes.push({
                from: line.from,
                to: line.from + cur18.length,
                insert: norm
            });
        }
        return changes.length ? [
            tr,
            {
                changes,
                sequential: true
            }
        ] : tr;
    });
}
const foldService = Facet.define();
const foldNodeProp = new NodeProp();
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? {
        from: first.to,
        to: last.type.isError ? node.to : last.from
    } : null;
}
function syntaxFolding(state54, start, end) {
    let tree = syntaxTree(state54);
    if (tree.length == 0) return null;
    let inner = tree.resolveInner(end);
    let found = null;
    for(let cur19 = inner; cur19; cur19 = cur19.parent){
        if (cur19.to <= end || cur19.from > end) continue;
        if (found && cur19.from < start) break;
        let prop = cur19.type.prop(foldNodeProp);
        if (prop) {
            let value = prop(cur19, state54);
            if (value && value.from <= end && value.from >= start && value.to > end) found = value;
        }
    }
    return found;
}
function foldable(state55, lineStart, lineEnd2) {
    for (let service of state55.facet(foldService)){
        let result = service(state55, lineStart, lineEnd2);
        if (result) return result;
    }
    return syntaxFolding(state55, lineStart, lineEnd2);
}
class GutterMarker extends RangeValue {
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
        return false;
    }
    elementClass;
    destroy(dom) {}
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = Facet.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: ()=>RangeSet.empty
    ,
    lineMarker: ()=>null
    ,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = Facet.define();
function gutter(config16) {
    return [
        gutters(),
        activeGutters.of({
            ...defaults,
            ...config16
        })
    ];
}
const baseTheme1 = EditorView.baseTheme({
    ".cm-gutters": {
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        left: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    }
});
const unfixGutters = Facet.define({
    combine: (values13)=>values13.some((x)=>x
        )
});
function gutters(config17) {
    let result = [
        gutterView,
        baseTheme1
    ];
    if (config17 && config17.fixed === false) result.push(unfixGutters.of(true));
    return result;
}
const gutterView = ViewPlugin.fromClass(class {
    view;
    gutters;
    dom;
    fixed;
    prevViewport;
    constructor(view){
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = this.view.contentHeight + "px";
        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf)
        );
        for (let gutter1 of this.gutters)this.dom.appendChild(gutter1.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + "px";
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach) this.dom.remove();
        let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map((gutter2)=>new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top)
        );
        for (let line of this.view.viewportLineBlocks){
            let text;
            if (Array.isArray(line.type)) {
                for (let b of line.type)if (b.type == BlockType.Text) {
                    text = b;
                    break;
                }
            } else {
                text = line.type == BlockType.Text ? line : undefined;
            }
            if (!text) continue;
            if (classSet.length) classSet = [];
            advanceCursor(lineClasses, classSet, line.from);
            for (let cx of contexts)cx.line(this.view, text, classSet);
        }
        for (let cx of contexts)cx.finish();
        if (detach) this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur20 = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur20) {
            for (let gutter3 of this.gutters)if (gutter3.update(update)) change = true;
        } else {
            change = true;
            let gutters1 = [];
            for (let conf of cur20){
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters1.push(new SingleGutterView(this.view, conf));
                } else {
                    this.gutters[known].update(update);
                    gutters1.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters){
                g.dom.remove();
                if (gutters1.indexOf(g) < 0) g.destroy();
            }
            for (let g1 of gutters1)this.dom.appendChild(g1.dom);
            this.gutters = gutters1;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)view.destroy();
        this.dom.remove();
    }
}, {
    provide: PluginField.scrollMargins.from((value)=>{
        if (value.gutters.length == 0 || !value.fixed) return null;
        return value.view.textDirection == Direction.LTR ? {
            left: value.dom.offsetWidth
        } : {
            right: value.dom.offsetWidth
        };
    })
});
function asArray1(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
function advanceCursor(cursor, collect, pos) {
    while(cursor.value && cursor.from <= pos){
        if (cursor.from == pos) collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    gutter;
    height;
    cursor;
    localMarkers = [];
    i = 0;
    constructor(gutter4, viewport, height){
        this.gutter = gutter4;
        this.height = height;
        this.cursor = RangeSet.iter(gutter4.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
        if (this.localMarkers.length) this.localMarkers = [];
        advanceCursor(this.cursor, this.localMarkers, line.from);
        let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine) localMarkers.unshift(forLine);
        let gutter5 = this.gutter;
        if (localMarkers.length == 0 && !gutter5.config.renderEmptyElements) return;
        let above = line.top - this.height;
        if (this.i == gutter5.elements.length) {
            let newElt = new GutterElement(view, line.height, above, localMarkers);
            gutter5.elements.push(newElt);
            gutter5.dom.appendChild(newElt.dom);
        } else {
            gutter5.elements[this.i].update(view, line.height, above, localMarkers);
        }
        this.height = line.bottom;
        this.i++;
    }
    finish() {
        let gutter6 = this.gutter;
        while(gutter6.elements.length > this.i){
            let last = gutter6.elements.pop();
            gutter6.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    view;
    config;
    dom;
    elements = [];
    markers;
    spacer = null;
    constructor(view, config18){
        this.view = view;
        this.config = config18;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for(let prop in config18.domEventHandlers){
            this.dom.addEventListener(prop, (event)=>{
                let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
                if (config18.domEventHandlers[prop](view, line, event)) event.preventDefault();
            });
        }
        this.markers = asArray1(config18.markers(view));
        if (config18.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [
                config18.initialSpacer(view)
            ]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray1(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [
                updated
            ]);
        }
        let vp = update.view.viewport;
        return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt12 of this.elements)elt12.destroy();
    }
}
class GutterElement {
    dom;
    height = -1;
    above = 0;
    markers = [];
    constructor(view, height, above, markers){
        this.dom = document.createElement("div");
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) this.dom.style.height = (this.height = height) + "px";
        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for(let iNew = 0, iOld = 0;;){
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c) cls += " " + c;
                for(let i141 = iOld; i141 < this.markers.length; i141++)if (this.markers[i141].compare(marker)) {
                    skipTo = i141;
                    matched = true;
                    break;
                }
            } else {
                skipTo = this.markers.length;
            }
            while(iOld < skipTo){
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker) break;
            if (marker.toDOM) {
                if (matched) domPos = domPos.nextSibling;
                else this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched) iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []);
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length) return false;
    for(let i142 = 0; i142 < a.length; i142++)if (!a[i142].compare(b[i142])) return false;
    return true;
}
const lineNumberMarkers = Facet.define();
const lineNumberConfig = Facet.define({
    combine (values14) {
        return combineConfig(values14, {
            formatNumber: String,
            domEventHandlers: {}
        }, {
            domEventHandlers (a, b) {
                let result = Object.assign({}, a);
                for(let event1 in b){
                    let exists = result[event1], add5 = b[event1];
                    result[event1] = exists ? (view, line, event)=>exists(view, line, event) || add5(view, line, event)
                     : add5;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    number;
    constructor(number3){
        super();
        this.number = number3;
    }
    eq(other) {
        return this.number == other.number;
    }
    toDOM() {
        return document.createTextNode(this.number);
    }
}
function formatNumber(view, number4) {
    return view.state.facet(lineNumberConfig).formatNumber(number4, view.state);
}
const lineNumberGutter = activeGutters.compute([
    lineNumberConfig
], (state56)=>({
        class: "cm-lineNumbers",
        renderEmptyElements: false,
        markers (view) {
            return view.state.facet(lineNumberMarkers);
        },
        lineMarker (view, line, others) {
            if (others.some((m)=>m.toDOM
            )) return null;
            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
        },
        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig)
        ,
        initialSpacer (view) {
            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
        },
        updateSpacer (spacer, update) {
            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
            return max == spacer.number ? spacer : new NumberMarker(max);
        },
        domEventHandlers: state56.facet(lineNumberConfig).domEventHandlers
    })
);
function lineNumbers(config19 = {}) {
    return [
        lineNumberConfig.of(config19),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while(last < lines)last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = new class extends GutterMarker {
    elementClass = "cm-activeLineGutter";
};
const activeLineGutterHighlighter = gutterLineClass.compute([
    "selection"
], (state57)=>{
    let marks = [], last = -1;
    for (let range of state57.selection.ranges)if (range.empty) {
        let linePos = state57.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : {
        from,
        to
    };
}
const foldEffect = StateEffect.define({
    map: mapRange
});
const unfoldEffect = StateEffect.define({
    map: mapRange
});
function selectedLines(view) {
    let lines = [];
    for (let { head  } of view.state.selection.ranges){
        if (lines.some((l)=>l.from <= head && l.to >= head
        )) continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
const foldState = StateField.define({
    create () {
        return Decoration.none;
    },
    update (folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects){
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({
                add: [
                    foldWidget.range(e.value.from, e.value.to)
                ]
            });
            else if (e.is(unfoldEffect)) folded = folded.update({
                filter: (from, to)=>e.value.from != from || e.value.to != to
                ,
                filterFrom: e.value.from,
                filterTo: e.value.to
            });
        }
        if (tr.selection) {
            let onSelection = false, { head  } = tr.selection.main;
            folded.between(head, head, (a, b)=>{
                if (a < head && b > head) onSelection = true;
            });
            if (onSelection) folded = folded.update({
                filterFrom: head,
                filterTo: head,
                filter: (a, b)=>b <= head || a >= head
            });
        }
        return folded;
    },
    provide: (f)=>EditorView.decorations.from(f)
});
function foldInside1(state58, from1, to1) {
    let found = null;
    state58.field(foldState, false)?.between(from1, to1, (from, to)=>{
        if (!found || found.from > from) found = {
            from,
            to
        };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b)=>{
        if (a == from && b == to) found = true;
    });
    return found;
}
function maybeEnable(state59, other) {
    return state59.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = (view)=>{
    for (let line of selectedLines(view)){
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({
                effects: maybeEnable(view.state, [
                    foldEffect.of(range),
                    announceFold(view, range)
                ])
            });
            return true;
        }
    }
    return false;
};
const unfoldCode = (view)=>{
    if (!view.state.field(foldState, false)) return false;
    let effects = [];
    for (let line of selectedLines(view)){
        let folded = foldInside1(view.state, line.from, line.to);
        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length) view.dispatch({
        effects
    });
    return effects.length > 0;
};
function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const foldAll = (view)=>{
    let { state: state60  } = view, effects = [];
    for(let pos = 0; pos < state60.doc.length;){
        let line = view.lineBlockAt(pos), range = foldable(state60, line.from, line.to);
        if (range) effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length) view.dispatch({
        effects: maybeEnable(view.state, effects)
    });
    return !!effects.length;
};
const unfoldAll = (view)=>{
    let field = view.state.field(foldState, false);
    if (!field || !field.size) return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to)=>{
        effects.push(unfoldEffect.of({
            from,
            to
        }));
    });
    view.dispatch({
        effects
    });
    return true;
};
const foldKeymap = [
    {
        key: "Ctrl-Shift-[",
        mac: "Cmd-Alt-[",
        run: foldCode
    },
    {
        key: "Ctrl-Shift-]",
        mac: "Cmd-Alt-]",
        run: unfoldCode
    },
    {
        key: "Ctrl-Alt-[",
        run: foldAll
    },
    {
        key: "Ctrl-Alt-]",
        run: unfoldAll
    }
];
const defaultConfig = {
    placeholderDOM: null,
    placeholderText: "…"
};
const foldConfig = Facet.define({
    combine (values15) {
        return combineConfig(values15, defaultConfig);
    }
});
function codeFolding(config20) {
    let result = [
        foldState,
        baseTheme2
    ];
    if (config20) result.push(foldConfig.of(config20));
    return result;
}
const foldWidget = Decoration.replace({
    widget: new class extends WidgetType {
        toDOM(view) {
            let { state: state61  } = view, conf = state61.facet(foldConfig);
            let onclick = (event)=>{
                let line = view.lineBlockAt(view.posAtDOM(event.target));
                let folded = foldInside1(view.state, line.from, line.to);
                if (folded) view.dispatch({
                    effects: unfoldEffect.of(folded)
                });
                event.preventDefault();
            };
            if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick);
            let element = document.createElement("span");
            element.textContent = conf.placeholderText;
            element.setAttribute("aria-label", state61.phrase("folded code"));
            element.title = state61.phrase("unfold");
            element.className = "cm-foldPlaceholder";
            element.onclick = onclick;
            return element;
        }
    }
});
const foldGutterDefaults = {
    openText: "⌄",
    closedText: "›",
    markerDOM: null,
    domEventHandlers: {}
};
class FoldMarker extends GutterMarker {
    config;
    open;
    constructor(config21, open){
        super();
        this.config = config21;
        this.open = open;
    }
    eq(other) {
        return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
        if (this.config.markerDOM) return this.config.markerDOM(this.open);
        let span7 = document.createElement("span");
        span7.textContent = this.open ? this.config.openText : this.config.closedText;
        span7.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span7;
    }
}
function foldGutter(config22 = {}) {
    let fullConfig = {
        ...foldGutterDefaults,
        ...config22
    };
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
        markers;
        from;
        constructor(view){
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false)) this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new RangeSetBuilder();
            for (let line of view.viewportLineBlocks){
                let mark = foldInside1(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark) builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers: domEventHandlers1  } = fullConfig;
    return [
        markers,
        gutter({
            class: "cm-foldGutter",
            markers (view) {
                return view.plugin(markers)?.markers || RangeSet.empty;
            },
            initialSpacer () {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: {
                ...domEventHandlers1,
                click: (view, line, event)=>{
                    if (domEventHandlers1.click && domEventHandlers1.click(view, line, event)) return true;
                    let folded = foldInside1(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({
                            effects: unfoldEffect.of(folded)
                        });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({
                            effects: foldEffect.of(range)
                        });
                        return true;
                    }
                    return false;
                }
            }
        }),
        codeFolding()
    ];
}
const baseTheme2 = EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});
const baseTheme3 = EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
        backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bb555544"
    }
});
const DefaultBrackets = "()[]{}";
const bracketMatchingConfig = Facet.define({
    combine (configs) {
        return combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: 10000,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = Decoration.mark({
    class: "cm-matchingBracket"
}), nonmatchingMark = Decoration.mark({
    class: "cm-nonmatchingBracket"
});
function defaultRenderMatch(match) {
    let decorations4 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations4.push(mark.range(match.start.from, match.start.to));
    if (match.end) decorations4.push(mark.range(match.end.from, match.end.to));
    return decorations4;
}
const bracketMatchingState = StateField.define({
    create () {
        return Decoration.none;
    },
    update (deco, tr) {
        if (!tr.docChanged && !tr.selection) return deco;
        let decorations5 = [];
        let config23 = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges){
            if (!range.empty) continue;
            let match = matchBrackets(tr.state, range.head, -1, config23) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config23) || config23.afterCursor && (matchBrackets(tr.state, range.head, 1, config23) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config23));
            if (match) decorations5 = decorations5.concat(config23.renderMatch(match, tr.state));
        }
        return Decoration.set(decorations5, true);
    },
    provide: (f)=>EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme3
];
function bracketMatching(config24 = {}) {
    return [
        bracketMatchingConfig.of(config24),
        bracketMatchingUnique
    ];
}
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp) return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [
            brackets[index + dir]
        ];
    }
    return null;
}
function matchBrackets(state62, pos, dir, config25 = {}) {
    let maxScanDistance = config25.maxScanDistance || 10000, brackets = config25.brackets || DefaultBrackets;
    let tree = syntaxTree(state62), node = tree.resolveInner(pos, dir);
    for(let cur21 = node; cur21; cur21 = cur21.parent){
        let matches = matchingNodes(cur21.type, dir, brackets);
        if (matches && cur21.from < cur21.to) return matchMarkedBrackets(state62, pos, dir, cur21, matches, brackets);
    }
    return matchPlainBrackets(state62, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = {
        from: token.from,
        to: token.to
    };
    let depth3 = 0, cursor = parent?.cursor;
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
            if (depth3 == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                return {
                    start: firstToken,
                    end: {
                        from: cursor.from,
                        to: cursor.to
                    },
                    matched: true
                };
            } else if (matchingNodes(cursor.type, dir, brackets)) {
                depth3++;
            } else if (matchingNodes(cursor.type, -dir, brackets)) {
                depth3--;
                if (depth3 == 0) return {
                    start: firstToken,
                    end: cursor.from == cursor.to ? undefined : {
                        from: cursor.from,
                        to: cursor.to
                    },
                    matched: false
                };
            }
        }
    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling())
    return {
        start: firstToken,
        matched: false
    };
}
function matchPlainBrackets(state63, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state63.sliceDoc(pos - 1, pos) : state63.sliceDoc(pos, pos + 1);
    let bracket1 = brackets.indexOf(startCh);
    if (bracket1 < 0 || bracket1 % 2 == 0 != dir > 0) return null;
    let startToken = {
        from: dir < 0 ? pos - 1 : pos,
        to: dir > 0 ? pos + 1 : pos
    };
    let iter = state63.doc.iterRange(pos, dir > 0 ? state63.doc.length : 0), depth4 = 0;
    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){
        let text = iter.value;
        if (dir < 0) distance += text.length;
        let basePos = pos + distance * dir;
        for(let pos1 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos1 != end; pos1 += dir){
            let found = brackets.indexOf(text[pos1]);
            if (found < 0 || tree.resolve(basePos + pos1, 1).type != tokenType) continue;
            if (found % 2 == 0 == dir > 0) {
                depth4++;
            } else if (depth4 == 1) {
                return {
                    start: startToken,
                    end: {
                        from: basePos + pos1,
                        to: basePos + pos1 + 1
                    },
                    matched: found >> 1 == bracket1 >> 1
                };
            } else {
                depth4--;
            }
        }
        if (dir > 0) distance += text.length;
    }
    return iter.done ? {
        start: startToken,
        matched: false
    } : null;
}
function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state64, selection) {
    return state64.update({
        selection,
        scrollIntoView: true,
        userEvent: "select"
    });
}
function moveSel({ state: state65 , dispatch  }, how) {
    let selection = updateSel(state65.selection, how);
    if (selection.eq(state65.selection)) return false;
    dispatch(setSel(state65, selection));
    return true;
}
function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward)
    );
}
const cursorCharLeft = (view)=>cursorByChar(view, view.textDirection != Direction.LTR)
;
const cursorCharRight = (view)=>cursorByChar(view, view.textDirection == Direction.LTR)
;
function cursorByGroup(view, forward) {
    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward)
    );
}
const cursorGroupLeft = (view)=>cursorByGroup(view, view.textDirection != Direction.LTR)
;
const cursorGroupRight = (view)=>cursorByGroup(view, view.textDirection == Direction.LTR)
;
function interestingNode(state66, node, bracketProp) {
    if (node.type.prop(bracketProp)) return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state66.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state67, start, forward) {
    let pos = syntaxTree(state67).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for(let at = start.head;;){
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next) break;
        if (interestingNode(state67, next, bracketProp)) pos = next;
        else at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state67, pos.from, 1) : matchBrackets(state67, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;
    else newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, view.textDirection != Direction.LTR)
    )
;
const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, view.textDirection == Direction.LTR)
    )
;
function cursorByLine(view, forward) {
    return moveSel(view, (range)=>{
        if (!range.empty) return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
}
const cursorLineUp = (view)=>cursorByLine(view, false)
;
const cursorLineDown = (view)=>cursorByLine(view, true)
;
function cursorByPage(view, forward) {
    let { state: state68  } = view, selection = updateSel(state68.selection, (range)=>{
        return range.empty ? view.moveVertically(range, forward, Math.min(view.dom.clientHeight, innerHeight)) : rangeEnd(range, forward);
    });
    if (selection.eq(state68.selection)) return false;
    let startPos = view.coordsAtPos(state68.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight) effect = EditorView.scrollIntoView(selection.main.head, {
        y: "start",
        yMargin: startPos.top - scrollRect.top
    });
    view.dispatch(setSel(state68, selection), {
        effects: effect
    });
    return true;
}
const cursorPageUp = (view)=>cursorByPage(view, false)
;
const cursorPageDown = (view)=>cursorByPage(view, true)
;
function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space4 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space4 && start.head != line.from + space4) moved = EditorSelection.cursor(line.from + space4);
    }
    return moved;
}
const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true)
    )
;
const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false)
    )
;
const cursorLineStart = (view)=>moveSel(view, (range)=>EditorSelection.cursor(view.lineBlockAt(range.head).from, 1)
    )
;
const cursorLineEnd = (view)=>moveSel(view, (range)=>EditorSelection.cursor(view.lineBlockAt(range.head).to, -1)
    )
;
function toMatchingBracket(state69, dispatch, extend2) {
    let found = false, selection = updateSel(state69.selection, (range)=>{
        let matching = matchBrackets(state69, range.head, -1) || matchBrackets(state69, range.head, 1) || range.head > 0 && matchBrackets(state69, range.head - 1, 1) || range.head < state69.doc.length && matchBrackets(state69, range.head + 1, -1);
        if (!matching || !matching.end) return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found) return false;
    dispatch(setSel(state69, selection));
    return true;
}
const cursorMatchingBracket = ({ state: state70 , dispatch  })=>toMatchingBracket(state70, dispatch, false)
;
function extendSel(view, how) {
    let selection = updateSel(view.state.selection, (range)=>{
        let head = how(range);
        return EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection)) return false;
    view.dispatch(setSel(view.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, (range)=>view.moveByChar(range, forward)
    );
}
const selectCharLeft = (view)=>selectByChar(view, view.textDirection != Direction.LTR)
;
const selectCharRight = (view)=>selectByChar(view, view.textDirection == Direction.LTR)
;
function selectByGroup(view, forward) {
    return extendSel(view, (range)=>view.moveByGroup(range, forward)
    );
}
const selectGroupLeft = (view)=>selectByGroup(view, view.textDirection != Direction.LTR)
;
const selectGroupRight = (view)=>selectByGroup(view, view.textDirection == Direction.LTR)
;
const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, view.textDirection != Direction.LTR)
    )
;
const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, view.textDirection == Direction.LTR)
    )
;
function selectByLine(view, forward) {
    return extendSel(view, (range)=>view.moveVertically(range, forward)
    );
}
const selectLineUp = (view)=>selectByLine(view, false)
;
const selectLineDown = (view)=>selectByLine(view, true)
;
function selectByPage(view, forward) {
    return extendSel(view, (range)=>view.moveVertically(range, forward, Math.min(view.dom.clientHeight, innerHeight))
    );
}
const selectPageUp = (view)=>selectByPage(view, false)
;
const selectPageDown = (view)=>selectByPage(view, true)
;
const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true)
    )
;
const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false)
    )
;
const selectLineStart = (view)=>extendSel(view, (range)=>EditorSelection.cursor(view.lineBlockAt(range.head).from)
    )
;
const selectLineEnd = (view)=>extendSel(view, (range)=>EditorSelection.cursor(view.lineBlockAt(range.head).to)
    )
;
const cursorDocStart = ({ state: state71 , dispatch  })=>{
    dispatch(setSel(state71, {
        anchor: 0
    }));
    return true;
};
const cursorDocEnd = ({ state: state72 , dispatch  })=>{
    dispatch(setSel(state72, {
        anchor: state72.doc.length
    }));
    return true;
};
const selectDocStart = ({ state: state73 , dispatch  })=>{
    dispatch(setSel(state73, {
        anchor: state73.selection.main.anchor,
        head: 0
    }));
    return true;
};
const selectDocEnd = ({ state: state74 , dispatch  })=>{
    dispatch(setSel(state74, {
        anchor: state74.selection.main.anchor,
        head: state74.doc.length
    }));
    return true;
};
const selectAll = ({ state: state75 , dispatch  })=>{
    dispatch(state75.update({
        selection: {
            anchor: 0,
            head: state75.doc.length
        },
        userEvent: "select"
    }));
    return true;
};
const selectLine = ({ state: state76 , dispatch  })=>{
    let ranges = selectedLineBlocks(state76).map(({ from , to  })=>EditorSelection.range(from, Math.min(to + 1, state76.doc.length))
    );
    dispatch(state76.update({
        selection: EditorSelection.create(ranges),
        userEvent: "select"
    }));
    return true;
};
const selectParentSyntax = ({ state: state77 , dispatch  })=>{
    let selection = updateSel(state77.selection, (range)=>{
        let context = syntaxTree(state77).resolveInner(range.head, 1);
        while(!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !context.parent?.parent))context = context.parent;
        return EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state77, selection));
    return true;
};
const simplifySelection = ({ state: state78 , dispatch  })=>{
    let cur22 = state78.selection, selection = null;
    if (cur22.ranges.length > 1) selection = EditorSelection.create([
        cur22.main
    ]);
    else if (!cur22.main.empty) selection = EditorSelection.create([
        EditorSelection.cursor(cur22.main.head)
    ]);
    if (!selection) return false;
    dispatch(setSel(state78, selection));
    return true;
};
function deleteBy({ state: state79 , dispatch  }, by) {
    if (state79.readOnly) return false;
    let event = "delete.selection";
    let changes = state79.changeByRange((range)=>{
        let { from , to  } = range;
        if (from == to) {
            let towards = by(from);
            if (towards < from) event = "delete.backward";
            else if (towards > from) event = "delete.forward";
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        return from == to ? {
            range
        } : {
            changes: {
                from,
                to
            },
            range: EditorSelection.cursor(from)
        };
    });
    if (changes.changes.empty) return false;
    dispatch(state79.update(changes, {
        scrollIntoView: true,
        userEvent: event
    }));
    return true;
}
function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView) for (let ranges of target.pluginField(PluginField.atomicRanges))ranges.between(pos, pos, (from, to)=>{
        if (from < pos && to > pos) pos = forward ? to : from;
    });
    return pos;
}
const deleteByChar = (target, forward)=>deleteBy(target, (pos)=>{
        let { state: state80  } = target, line = state80.doc.lineAt(pos), before, targetPos;
        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
            if (before[before.length - 1] == "\t") return pos - 1;
            let col = countColumn(before, state80.tabSize), drop = col % getIndentUnit(state80) || getIndentUnit(state80);
            for(let i143 = 0; i143 < drop && before[before.length - 1 - i143] == " "; i143++)pos--;
            targetPos = pos;
        } else {
            targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
            if (targetPos == pos && line.number != (forward ? state80.doc.lines : 1)) targetPos += forward ? 1 : -1;
        }
        return skipAtomic(target, targetPos, forward);
    })
;
const deleteCharBackward = (view)=>deleteByChar(view, false)
;
const deleteCharForward = (view)=>deleteByChar(view, true)
;
const deleteByGroup = (target, forward)=>deleteBy(target, (start)=>{
        let pos = start, { state: state81  } = target, line = state81.doc.lineAt(pos);
        let categorize = state81.charCategorizer(pos);
        for(let cat = null;;){
            if (pos == (forward ? line.to : line.from)) {
                if (pos == start && line.number != (forward ? state81.doc.lines : 1)) pos += forward ? 1 : -1;
                break;
            }
            let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
            let nextChar1 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
            let nextCat = categorize(nextChar1);
            if (cat != null && nextCat != cat) break;
            if (nextChar1 != " " || pos != start) cat = nextCat;
            pos = next;
        }
        return skipAtomic(target, pos, forward);
    })
;
const deleteGroupBackward = (target)=>deleteByGroup(target, false)
;
const deleteGroupForward = (target)=>deleteByGroup(target, true)
;
const deleteToLineEnd = (view)=>deleteBy(view, (pos)=>{
        let lineEnd3 = view.lineBlockAt(pos).to;
        return skipAtomic(view, pos < lineEnd3 ? lineEnd3 : Math.min(view.state.doc.length, pos + 1), true);
    })
;
const deleteToLineStart = (view)=>deleteBy(view, (pos)=>{
        let lineStart = view.lineBlockAt(pos).from;
        return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
    })
;
const splitLine = ({ state: state82 , dispatch  })=>{
    if (state82.readOnly) return false;
    let changes = state82.changeByRange((range)=>{
        return {
            changes: {
                from: range.from,
                to: range.to,
                insert: Text.of([
                    "",
                    ""
                ])
            },
            range: EditorSelection.cursor(range.from)
        };
    });
    dispatch(state82.update(changes, {
        scrollIntoView: true,
        userEvent: "input"
    }));
    return true;
};
const transposeChars = ({ state: state83 , dispatch  })=>{
    if (state83.readOnly) return false;
    let changes = state83.changeByRange((range)=>{
        if (!range.empty || range.from == 0 || range.from == state83.doc.length) return {
            range
        };
        let pos = range.from, line = state83.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
        return {
            changes: {
                from,
                to,
                insert: state83.doc.slice(pos, to).append(state83.doc.slice(from, pos))
            },
            range: EditorSelection.cursor(to)
        };
    });
    if (changes.changes.empty) return false;
    dispatch(state83.update(changes, {
        scrollIntoView: true,
        userEvent: "move.character"
    }));
    return true;
};
function selectedLineBlocks(state84) {
    let blocks = [], upto = -1;
    for (let range of state84.selection.ranges){
        let startLine = state84.doc.lineAt(range.from), endLine = state84.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from) endLine = state84.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
        } else {
            blocks.push({
                from: startLine.from,
                to: endLine.to,
                ranges: [
                    range
                ]
            });
        }
        upto = endLine.number + 1;
    }
    return blocks;
}
function moveLine(state85, dispatch, forward) {
    if (state85.readOnly) return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state85)){
        if (forward ? block.to == state85.doc.length : block.from == 0) continue;
        let nextLine = state85.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
            changes.push({
                from: block.to,
                to: nextLine.to
            }, {
                from: block.from,
                insert: nextLine.text + state85.lineBreak
            });
            for (let r of block.ranges)ranges.push(EditorSelection.range(Math.min(state85.doc.length, r.anchor + size), Math.min(state85.doc.length, r.head + size)));
        } else {
            changes.push({
                from: nextLine.from,
                to: block.from
            }, {
                from: block.to,
                insert: state85.lineBreak + nextLine.text
            });
            for (let r of block.ranges)ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
        }
    }
    if (!changes.length) return false;
    dispatch(state85.update({
        changes,
        scrollIntoView: true,
        selection: EditorSelection.create(ranges, state85.selection.mainIndex),
        userEvent: "move.line"
    }));
    return true;
}
const moveLineUp = ({ state: state86 , dispatch  })=>moveLine(state86, dispatch, false)
;
const moveLineDown = ({ state: state87 , dispatch  })=>moveLine(state87, dispatch, true)
;
function copyLine(state88, dispatch, forward) {
    if (state88.readOnly) return false;
    let changes = [];
    for (let block of selectedLineBlocks(state88)){
        if (forward) changes.push({
            from: block.from,
            insert: state88.doc.slice(block.from, block.to) + state88.lineBreak
        });
        else changes.push({
            from: block.to,
            insert: state88.lineBreak + state88.doc.slice(block.from, block.to)
        });
    }
    dispatch(state88.update({
        changes,
        scrollIntoView: true,
        userEvent: "input.copyline"
    }));
    return true;
}
const copyLineUp = ({ state: state89 , dispatch  })=>copyLine(state89, dispatch, false)
;
const copyLineDown = ({ state: state90 , dispatch  })=>copyLine(state90, dispatch, true)
;
const deleteLine = (view)=>{
    if (view.state.readOnly) return false;
    let { state: state91  } = view, changes = state91.changes(selectedLineBlocks(state91).map(({ from , to  })=>{
        if (from > 0) from--;
        else if (to < state91.doc.length) to++;
        return {
            from,
            to
        };
    }));
    let selection = updateSel(state91.selection, (range)=>view.moveVertically(range, true)
    ).map(changes);
    view.dispatch({
        changes,
        selection,
        scrollIntoView: true,
        userEvent: "delete.line"
    });
    return true;
};
function isBetweenBrackets(state92, pos) {
    if (/\(\)|\[\]|\{\}/.test(state92.sliceDoc(pos - 1, pos + 1))) return {
        from: pos,
        to: pos
    };
    let context = syntaxTree(state92).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state92.doc.lineAt(before.to).from == state92.doc.lineAt(after.from).from) return {
        from: before.to,
        to: after.from
    };
    return null;
}
const insertNewlineAndIndent = newlineAndIndent(false);
const insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
    return ({ state: state93 , dispatch  })=>{
        if (state93.readOnly) return false;
        let changes = state93.changeByRange((range)=>{
            let { from , to  } = range, line = state93.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state93, from);
            if (atEof) from = to = (to <= line.to ? line : state93.doc.lineAt(to)).to;
            let cx = new IndentContext(state93, {
                simulateBreak: from,
                simulateDoubleBreak: !!explode
            });
            let indent = getIndentation(cx, from);
            if (indent == null) indent = /^\s*/.exec(state93.doc.lineAt(from).text)[0].length;
            while(to < line.to && /\s/.test(line.text[to - line.from]))to++;
            if (explode) ({ from , to  } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
            let insert7 = [
                "",
                indentString(state93, indent)
            ];
            if (explode) insert7.push(indentString(state93, cx.lineIndent(line.from, -1)));
            return {
                changes: {
                    from,
                    to,
                    insert: Text.of(insert7)
                },
                range: EditorSelection.cursor(from + 1 + insert7[1].length)
            };
        });
        dispatch(state93.update(changes, {
            scrollIntoView: true,
            userEvent: "input"
        }));
        return true;
    };
}
function changeBySelectedLine(state94, f) {
    let atLine = -1;
    return state94.changeByRange((range)=>{
        let changes = [];
        for(let pos = range.from; pos <= range.to;){
            let line = state94.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state94.changes(changes);
        return {
            changes,
            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
        };
    });
}
const indentSelection = ({ state: state95 , dispatch  })=>{
    if (state95.readOnly) return false;
    let updated = Object.create(null);
    let context = new IndentContext(state95, {
        overrideIndentation: (start)=>{
            let found = updated[start];
            return found == null ? -1 : found;
        }
    });
    let changes1 = changeBySelectedLine(state95, (line, changes, range)=>{
        let indent = getIndentation(context, line.from);
        if (indent == null) return;
        if (!/\S/.test(line.text)) indent = 0;
        let cur23 = /^\s*/.exec(line.text)[0];
        let norm = indentString(state95, indent);
        if (cur23 != norm || range.from < line.from + cur23.length) {
            updated[line.from] = indent;
            changes.push({
                from: line.from,
                to: line.from + cur23.length,
                insert: norm
            });
        }
    });
    if (!changes1.changes.empty) dispatch(state95.update(changes1, {
        userEvent: "indent"
    }));
    return true;
};
const indentMore = ({ state: state96 , dispatch  })=>{
    if (state96.readOnly) return false;
    dispatch(state96.update(changeBySelectedLine(state96, (line, changes)=>{
        changes.push({
            from: line.from,
            insert: state96.facet(indentUnit)
        });
    }), {
        userEvent: "input.indent"
    }));
    return true;
};
const indentLess = ({ state: state97 , dispatch  })=>{
    if (state97.readOnly) return false;
    dispatch(state97.update(changeBySelectedLine(state97, (line, changes)=>{
        let space5 = /^\s*/.exec(line.text)[0];
        if (!space5) return;
        let col = countColumn(space5, state97.tabSize), keep = 0;
        let insert8 = indentString(state97, Math.max(0, col - getIndentUnit(state97)));
        while(keep < space5.length && keep < insert8.length && space5.charCodeAt(keep) == insert8.charCodeAt(keep))keep++;
        changes.push({
            from: line.from + keep,
            to: line.from + space5.length,
            insert: insert8.slice(keep)
        });
    }), {
        userEvent: "delete.dedent"
    }));
    return true;
};
const emacsStyleKeymap = [
    {
        key: "Ctrl-b",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
    },
    {
        key: "Ctrl-f",
        run: cursorCharRight,
        shift: selectCharRight
    },
    {
        key: "Ctrl-p",
        run: cursorLineUp,
        shift: selectLineUp
    },
    {
        key: "Ctrl-n",
        run: cursorLineDown,
        shift: selectLineDown
    },
    {
        key: "Ctrl-a",
        run: cursorLineStart,
        shift: selectLineStart
    },
    {
        key: "Ctrl-e",
        run: cursorLineEnd,
        shift: selectLineEnd
    },
    {
        key: "Ctrl-d",
        run: deleteCharForward
    },
    {
        key: "Ctrl-h",
        run: deleteCharBackward
    },
    {
        key: "Ctrl-k",
        run: deleteToLineEnd
    },
    {
        key: "Ctrl-Alt-h",
        run: deleteGroupBackward
    },
    {
        key: "Ctrl-o",
        run: splitLine
    },
    {
        key: "Ctrl-t",
        run: transposeChars
    },
    {
        key: "Ctrl-v",
        run: cursorPageDown
    }, 
];
const standardKeymap = [
    {
        key: "ArrowLeft",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: true
    },
    {
        key: "Mod-ArrowLeft",
        mac: "Alt-ArrowLeft",
        run: cursorGroupLeft,
        shift: selectGroupLeft
    },
    {
        mac: "Cmd-ArrowLeft",
        run: cursorLineBoundaryBackward,
        shift: selectLineBoundaryBackward
    },
    {
        key: "ArrowRight",
        run: cursorCharRight,
        shift: selectCharRight,
        preventDefault: true
    },
    {
        key: "Mod-ArrowRight",
        mac: "Alt-ArrowRight",
        run: cursorGroupRight,
        shift: selectGroupRight
    },
    {
        mac: "Cmd-ArrowRight",
        run: cursorLineBoundaryForward,
        shift: selectLineBoundaryForward
    },
    {
        key: "ArrowUp",
        run: cursorLineUp,
        shift: selectLineUp,
        preventDefault: true
    },
    {
        mac: "Cmd-ArrowUp",
        run: cursorDocStart,
        shift: selectDocStart
    },
    {
        mac: "Ctrl-ArrowUp",
        run: cursorPageUp,
        shift: selectPageUp
    },
    {
        key: "ArrowDown",
        run: cursorLineDown,
        shift: selectLineDown,
        preventDefault: true
    },
    {
        mac: "Cmd-ArrowDown",
        run: cursorDocEnd,
        shift: selectDocEnd
    },
    {
        mac: "Ctrl-ArrowDown",
        run: cursorPageDown,
        shift: selectPageDown
    },
    {
        key: "PageUp",
        run: cursorPageUp,
        shift: selectPageUp
    },
    {
        key: "PageDown",
        run: cursorPageDown,
        shift: selectPageDown
    },
    {
        key: "Home",
        run: cursorLineBoundaryBackward,
        shift: selectLineBoundaryBackward
    },
    {
        key: "Mod-Home",
        run: cursorDocStart,
        shift: selectDocStart
    },
    {
        key: "End",
        run: cursorLineBoundaryForward,
        shift: selectLineBoundaryForward
    },
    {
        key: "Mod-End",
        run: cursorDocEnd,
        shift: selectDocEnd
    },
    {
        key: "Enter",
        run: insertNewlineAndIndent
    },
    {
        key: "Mod-a",
        run: selectAll
    },
    {
        key: "Backspace",
        run: deleteCharBackward,
        shift: deleteCharBackward
    },
    {
        key: "Delete",
        run: deleteCharForward
    },
    {
        key: "Mod-Backspace",
        mac: "Alt-Backspace",
        run: deleteGroupBackward
    },
    {
        key: "Mod-Delete",
        mac: "Alt-Delete",
        run: deleteGroupForward
    },
    {
        mac: "Mod-Backspace",
        run: deleteToLineStart
    },
    {
        mac: "Mod-Delete",
        run: deleteToLineEnd
    }
].concat(emacsStyleKeymap.map((b)=>({
        mac: b.key,
        run: b.run,
        shift: b.shift
    })
));
const defaultKeymap = [
    {
        key: "Alt-ArrowLeft",
        mac: "Ctrl-ArrowLeft",
        run: cursorSyntaxLeft,
        shift: selectSyntaxLeft
    },
    {
        key: "Alt-ArrowRight",
        mac: "Ctrl-ArrowRight",
        run: cursorSyntaxRight,
        shift: selectSyntaxRight
    },
    {
        key: "Alt-ArrowUp",
        run: moveLineUp
    },
    {
        key: "Shift-Alt-ArrowUp",
        run: copyLineUp
    },
    {
        key: "Alt-ArrowDown",
        run: moveLineDown
    },
    {
        key: "Shift-Alt-ArrowDown",
        run: copyLineDown
    },
    {
        key: "Escape",
        run: simplifySelection
    },
    {
        key: "Mod-Enter",
        run: insertBlankLine
    },
    {
        key: "Alt-l",
        mac: "Ctrl-l",
        run: selectLine
    },
    {
        key: "Mod-i",
        run: selectParentSyntax,
        preventDefault: true
    },
    {
        key: "Mod-[",
        run: indentLess
    },
    {
        key: "Mod-]",
        run: indentMore
    },
    {
        key: "Mod-Alt-\\",
        run: indentSelection
    },
    {
        key: "Shift-Mod-k",
        run: deleteLine
    },
    {
        key: "Shift-Mod-\\",
        run: cursorMatchingBracket
    }
].concat(standardKeymap);
const defaults1 = {
    brackets: [
        "(",
        "[",
        "{",
        "'",
        '"'
    ],
    before: ")]}'\":;>"
};
const closeBracketEffect = StateEffect.define({
    map (value, mapping) {
        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
        return mapped == null ? undefined : mapped;
    }
});
const skipBracketEffect = StateEffect.define({
    map (value, mapping) {
        return mapping.mapPos(value);
    }
});
const closedBracket = new class extends RangeValue {
};
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = StateField.define({
    create () {
        return RangeSet.empty;
    },
    update (value, tr) {
        if (tr.selection) {
            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
            if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = RangeSet.empty;
        }
        value = value.map(tr.changes);
        for (let effect of tr.effects){
            if (effect.is(closeBracketEffect)) value = value.update({
                add: [
                    closedBracket.range(effect.value, effect.value + 1)
                ]
            });
            else if (effect.is(skipBracketEffect)) value = value.update({
                filter: (from)=>from != effect.value
            });
        }
        return value;
    }
});
function closeBrackets() {
    return [
        inputHandler1,
        bracketState
    ];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
    for(let i144 = 0; i144 < definedClosing.length; i144 += 2)if (definedClosing.charCodeAt(i144) == ch) return definedClosing.charAt(i144 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state98, pos) {
    return state98.languageDataAt("closeBrackets", pos)[0] || defaults1;
}
const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
const inputHandler1 = EditorView.inputHandler.of((view, from, to, insert9)=>{
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;
    let sel = view.state.selection.main;
    if (insert9.length > 2 || insert9.length == 2 && codePointSize(codePointAt(insert9, 0)) == 1 || from != sel.from || to != sel.to) return false;
    let tr = insertBracket(view.state, insert9);
    if (!tr) return false;
    view.dispatch(tr);
    return true;
});
const deleteBracketPair = ({ state: state99 , dispatch  })=>{
    if (state99.readOnly) return false;
    let conf = config(state99, state99.selection.main.head);
    let tokens = conf.brackets || defaults1.brackets;
    let dont = null, changes = state99.changeByRange((range)=>{
        if (range.empty) {
            let before = prevChar(state99.doc, range.head);
            for (let token of tokens){
                if (token == before && nextChar(state99.doc, range.head) == closing(codePointAt(token, 0))) return {
                    changes: {
                        from: range.head - token.length,
                        to: range.head + token.length
                    },
                    range: EditorSelection.cursor(range.head - token.length),
                    userEvent: "delete.backward"
                };
            }
        }
        return {
            range: dont = range
        };
    });
    if (!dont) dispatch(state99.update(changes, {
        scrollIntoView: true
    }));
    return !dont;
};
const closeBracketsKeymap = [
    {
        key: "Backspace",
        run: deleteBracketPair
    }
];
function insertBracket(state100, bracket3) {
    let conf = config(state100, state100.selection.main.head);
    let tokens = conf.brackets || defaults1.brackets;
    for (let tok of tokens){
        let closed = closing(codePointAt(tok, 0));
        if (bracket3 == tok) return closed == tok ? handleSame(state100, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state100, tok, closed, conf.before || defaults1.before);
        if (bracket3 == closed && closedBracketAt(state100, state100.selection.main.from)) return handleClose(state100, tok, closed);
    }
    return null;
}
function closedBracketAt(state101, pos) {
    let found = false;
    state101.field(bracketState).between(0, state101.doc.length, (from)=>{
        if (from == pos) found = true;
    });
    return found;
}
function nextChar(doc26, pos) {
    let next = doc26.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc27, pos) {
    let prev = doc27.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state102, open, close, closeBefore) {
    let dont = null, changes = state102.changeByRange((range)=>{
        if (!range.empty) return {
            changes: [
                {
                    insert: open,
                    from: range.from
                },
                {
                    insert: close,
                    from: range.to
                }
            ],
            effects: closeBracketEffect.of(range.to + open.length),
            range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
        let next = nextChar(state102.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) return {
            changes: {
                insert: open + close,
                from: range.head
            },
            effects: closeBracketEffect.of(range.head + open.length),
            range: EditorSelection.cursor(range.head + open.length)
        };
        return {
            range: dont = range
        };
    });
    return dont ? null : state102.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function handleClose(state103, _open, close) {
    let dont = null, moved = state103.selection.ranges.map((range)=>{
        if (range.empty && nextChar(state103.doc, range.head) == close) return EditorSelection.cursor(range.head + close.length);
        return dont = range;
    });
    return dont ? null : state103.update({
        selection: EditorSelection.create(moved, state103.selection.mainIndex),
        scrollIntoView: true,
        effects: state103.selection.ranges.map(({ from  })=>skipBracketEffect.of(from)
        )
    });
}
function handleSame(state104, token, allowTriple) {
    let dont = null, changes = state104.changeByRange((range)=>{
        if (!range.empty) return {
            changes: [
                {
                    insert: token,
                    from: range.from
                },
                {
                    insert: token,
                    from: range.to
                }
            ],
            effects: closeBracketEffect.of(range.to + token.length),
            range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
        let pos = range.head, next = nextChar(state104.doc, pos);
        if (next == token) {
            if (nodeStart(state104, pos)) {
                return {
                    changes: {
                        insert: token + token,
                        from: pos
                    },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: EditorSelection.cursor(pos + token.length)
                };
            } else if (closedBracketAt(state104, pos)) {
                let isTriple = allowTriple && state104.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                return {
                    range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
                    effects: skipBracketEffect.of(pos)
                };
            }
        } else if (allowTriple && state104.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state104, pos - 2 * token.length)) {
            return {
                changes: {
                    insert: token + token + token + token,
                    from: pos
                },
                effects: closeBracketEffect.of(pos + token.length),
                range: EditorSelection.cursor(pos + token.length)
            };
        } else if (state104.charCategorizer(pos)(next) != CharCategory.Word) {
            let prev = state104.sliceDoc(pos - 1, pos);
            if (prev != token && state104.charCategorizer(pos)(prev) != CharCategory.Word && !probablyInString(state104, pos, token)) return {
                changes: {
                    insert: token + token,
                    from: pos
                },
                effects: closeBracketEffect.of(pos + token.length),
                range: EditorSelection.cursor(pos + token.length)
            };
        }
        return {
            range: dont = range
        };
    });
    return dont ? null : state104.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function nodeStart(state105, pos) {
    let tree = syntaxTree(state105).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
}
function probablyInString(state106, pos, quoteToken) {
    let node = syntaxTree(state106).resolveInner(pos, -1);
    for(let i145 = 0; i145 < 5; i145++){
        if (state106.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken) return true;
        let parent = node.to == pos && node.parent;
        if (!parent) break;
        node = parent;
    }
    return false;
}
const panelConfig = Facet.define({
    combine (configs) {
        let topContainer, bottomContainer;
        for (let c of configs){
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return {
            topContainer,
            bottomContainer
        };
    }
});
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = ViewPlugin.fromClass(class {
    input;
    specs;
    panels;
    top;
    bottom;
    constructor(view){
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter((s)=>s
        );
        this.panels = this.specs.map((spec)=>spec(view)
        );
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter((p13)=>p13.top
        ));
        this.bottom.sync(this.panels.filter((p14)=>!p14.top
        ));
        for (let p1 of this.panels){
            p1.dom.classList.add("cm-panel");
            if (p1.mount) p1.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter((x)=>x
            );
            let panels1 = [], top31 = [], bottom = [], mount = [];
            for (let spec of specs){
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                } else {
                    panel = this.panels[known];
                    if (panel.update) panel.update(update);
                }
                panels1.push(panel);
                (panel.top ? top31 : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels1;
            this.top.sync(top31);
            this.bottom.sync(bottom);
            for (let p15 of mount){
                p15.dom.classList.add("cm-panel");
                if (p15.mount) p15.mount();
            }
        } else {
            for (let p16 of this.panels)if (p16.update) p16.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: PluginField.scrollMargins.from((value)=>({
            top: value.top.scrollMargin(),
            bottom: value.bottom.scrollMargin()
        })
    )
});
class PanelGroup {
    view;
    top;
    container;
    dom = undefined;
    classes = "";
    panels = [];
    constructor(view, top32, container){
        this.view = view;
        this.top = top32;
        this.container = container;
        this.syncClasses();
    }
    sync(panels2) {
        for (let p17 of this.panels)if (p17.destroy && panels2.indexOf(p17) < 0) p17.destroy();
        this.panels = panels2;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels){
            if (panel.dom.parentNode == this.dom) {
                while(curDOM != panel.dom)curDOM = rm1(curDOM);
                curDOM = curDOM.nextSibling;
            } else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while(curDOM)curDOM = rm1(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses) return;
        for (let cls of this.classes.split(" "))if (cls) this.container.classList.remove(cls);
        for (let cls1 of (this.classes = this.view.themeClasses).split(" "))if (cls1) this.container.classList.add(cls1);
    }
}
function rm1(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
const baseTheme4 = EditorView.baseTheme({
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    }
});
const showPanel = Facet.define({
    enables: [
        panelPlugin,
        baseTheme4
    ]
});
function crelt() {
    var elt13 = arguments[0];
    if (typeof elt13 == "string") elt13 = document.createElement(elt13);
    var i146 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
        for(var name20 in next)if (Object.prototype.hasOwnProperty.call(next, name20)) {
            var value = next[name20];
            if (typeof value == "string") elt13.setAttribute(name20, value);
            else if (value != null) elt13[name20] = value;
        }
        i146++;
    }
    for(; i146 < arguments.length; i146++)add(elt13, arguments[i146]);
    return elt13;
}
function add(elt14, child) {
    if (typeof child == "string") {
        elt14.appendChild(document.createTextNode(child));
    } else if (child == null) {} else if (child.nodeType != null) {
        elt14.appendChild(child);
    } else if (Array.isArray(child)) {
        for(var i147 = 0; i147 < child.length; i147++)add(elt14, child[i147]);
    } else {
        throw new RangeError("Unsupported child node: " + child);
    }
}
const basicNormalize = typeof String.prototype.normalize == "function" ? (x)=>x.normalize("NFKD")
 : (x)=>x
;
class SearchCursor {
    iter;
    value = {
        from: 0,
        to: 0
    };
    done = false;
    matches = [];
    buffer = "";
    bufferPos = 0;
    bufferStart;
    normalize;
    query;
    constructor(text, query, from = 0, to = text.length, normalize4){
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize4 ? (x)=>normalize4(basicNormalize(x))
         : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done) return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
        while(this.matches.length)this.matches.pop();
        return this.nextOverlapping();
    }
    nextOverlapping() {
        for(;;){
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += codePointSize(next);
            let norm = this.normalize(str);
            for(let i148 = 0, pos = start;; i148++){
                let code9 = norm.charCodeAt(i148);
                let match = this.match(code9, pos);
                if (match) {
                    this.value = match;
                    return this;
                }
                if (i148 == norm.length - 1) break;
                if (pos == start && i148 < str.length && str.charCodeAt(i148) == code9) pos++;
            }
        }
    }
    match(code10, pos) {
        let match = null;
        for(let i149 = 0; i149 < this.matches.length; i149 += 2){
            let index = this.matches[i149], keep = false;
            if (this.query.charCodeAt(index) == code10) {
                if (index == this.query.length - 1) {
                    match = {
                        from: this.matches[i149 + 1],
                        to: pos + 1
                    };
                } else {
                    this.matches[i149]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i149, 2);
                i149 -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code10) {
            if (this.query.length == 1) match = {
                from: pos,
                to: pos + 1
            };
            else this.matches.push(1, pos);
        }
        return match;
    }
    [Symbol.iterator];
}
if (typeof Symbol != "undefined") SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
};
const empty = {
    from: -1,
    to: -1,
    match: /.*/.exec("")
};
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
class RegExpCursor {
    to;
    iter;
    re;
    curLine = "";
    curLineStart;
    matchPos;
    done = false;
    value = empty;
    constructor(text, query, options, from = 0, to = text.length){
        this.to = to;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + (options?.ignoreCase ? "i" : ""));
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = from;
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        } else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to) this.curLine = "";
        else this.getLine(0);
    }
    next() {
        for(let off = this.matchPos - this.curLineStart;;){
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = to + (from == to ? 1 : 0);
                if (from == this.curLine.length) this.nextLine();
                if (from < to || from > this.value.to) {
                    this.value = {
                        from,
                        to,
                        match
                    };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            } else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            } else {
                this.done = true;
                return this;
            }
        }
    }
    [Symbol.iterator];
}
const flattened = new WeakMap();
class FlattenedDoc {
    from;
    text;
    constructor(from, text){
        this.from = from;
        this.text = text;
    }
    get to() {
        return this.from + this.text.length;
    }
    static get(doc28, from, to) {
        let cached = flattened.get(doc28);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc28.sliceString(from, to));
            flattened.set(doc28, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to) return cached;
        let { text , from: cachedFrom  } = cached;
        if (cachedFrom > from) {
            text = doc28.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to) text += doc28.sliceString(cached.to, to);
        flattened.set(doc28, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
var Chunk1;
(function(Chunk2) {
    Chunk2[Chunk2["Base"] = 5000] = "Base";
})(Chunk1 || (Chunk1 = {}));
class MultilineRegExpCursor {
    text;
    to;
    flat;
    matchPos;
    re;
    done = false;
    value = empty;
    constructor(text, query, options, from, to){
        this.text = text;
        this.to = to;
        this.matchPos = from;
        this.re = new RegExp(query, baseFlags + (options?.ignoreCase ? "i" : ""));
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + Chunk1.Base));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for(;;){
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                this.value = {
                    from,
                    to,
                    match
                };
                this.matchPos = to + (from == to ? 1 : 0);
                return this;
            } else {
                if (this.flat.to == this.to) {
                    this.done = true;
                    return this;
                }
                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
            }
        }
    }
    [Symbol.iterator];
}
if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
        return this;
    };
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    } catch  {
        return false;
    }
}
function createLineDialog(view) {
    let input = crelt("input", {
        class: "cm-textfield",
        name: "line"
    });
    let dom = crelt("form", {
        class: "cm-gotoLine",
        onkeydown: (event)=>{
            if (event.keyCode == 27) {
                event.preventDefault();
                view.dispatch({
                    effects: dialogEffect.of(false)
                });
                view.focus();
            } else if (event.keyCode == 13) {
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event)=>{
            event.preventDefault();
            go();
        }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
        class: "cm-button",
        type: "submit"
    }, view.state.phrase("go")));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match) return;
        let { state: state107  } = view, startLine = state107.doc.lineAt(state107.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign) pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state107.doc.lines;
            line = Math.round(state107.doc.lines * pc);
        } else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state107.doc.line(Math.max(1, Math.min(state107.doc.lines, line)));
        view.dispatch({
            effects: dialogEffect.of(false),
            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
            scrollIntoView: true
        });
        view.focus();
    }
    return {
        dom,
        pos: -10
    };
}
const dialogEffect = StateEffect.define();
const dialogField = StateField.define({
    create () {
        return true;
    },
    update (value, tr) {
        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;
        return value;
    },
    provide: (f)=>showPanel.from(f, (val)=>val ? createLineDialog : null
        )
});
const gotoLine = (view)=>{
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
        let effects = [
            dialogEffect.of(true)
        ];
        if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([
            dialogField,
            baseTheme5
        ]));
        view.dispatch({
            effects
        });
        panel = getPanel(view, createLineDialog);
    }
    if (panel) panel.dom.querySelector("input").focus();
    return true;
};
const baseTheme5 = EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": {
            fontSize: "80%"
        }
    }
});
const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: true
};
const highlightConfig = Facet.define({
    combine (options) {
        return combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b)=>a || b
            ,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
function highlightSelectionMatches(options) {
    let ext = [
        defaultTheme,
        matchHighlighter
    ];
    if (options) ext.push(highlightConfig.of(options));
    return ext;
}
const matchDeco = Decoration.mark({
    class: "cm-selectionMatch"
});
const mainMatchDeco = Decoration.mark({
    class: "cm-selectionMatch cm-selectionMatch-main"
});
function insideWordBoundaries(check, state108, from, to) {
    return (from == 0 || check(state108.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state108.doc.length || check(state108.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state109, from, to) {
    return check(state109.sliceDoc(from, from + 1)) == CharCategory.Word && check(state109.sliceDoc(to - 1, to)) == CharCategory.Word;
}
const matchHighlighter = ViewPlugin.fromClass(class {
    decorations;
    constructor(view){
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state: state110  } = view, sel = state110.selection;
        if (sel.ranges.length > 1) return Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor) return Decoration.none;
            let word = state110.wordAt(range.head);
            if (!word) return Decoration.none;
            check = state110.charCategorizer(range.head);
            query = state110.sliceDoc(word.from, word.to);
        } else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200) return Decoration.none;
            if (conf.wholeWords) {
                query = state110.sliceDoc(range.from, range.to);
                check = state110.charCategorizer(range.head);
                if (!(insideWordBoundaries(check, state110, range.from, range.to) && insideWord(check, state110, range.from, range.to))) return Decoration.none;
            } else {
                query = state110.sliceDoc(range.from, range.to).trim();
                if (!query) return Decoration.none;
            }
        }
        let deco = [];
        for (let part of view.visibleRanges){
            let cursor = new SearchCursor(state110.doc, query, part.from, part.to);
            while(!cursor.next().done){
                let { from , to  } = cursor.value;
                if (!check || insideWordBoundaries(check, state110, from, to)) {
                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches) return Decoration.none;
                }
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: (v)=>v.decorations
});
const defaultTheme = EditorView.baseTheme({
    ".cm-selectionMatch": {
        backgroundColor: "#99ff7780"
    },
    ".cm-searchMatch .cm-selectionMatch": {
        backgroundColor: "transparent"
    }
});
const selectWord = ({ state: state111 , dispatch  })=>{
    let { selection  } = state111;
    let newSel = EditorSelection.create(selection.ranges.map((range)=>state111.wordAt(range.head) || EditorSelection.cursor(range.head)
    ), selection.mainIndex);
    if (newSel.eq(selection)) return false;
    dispatch(state111.update({
        selection: newSel
    }));
    return true;
};
function findNextOccurrence(state112, query) {
    let { main , ranges  } = state112.selection;
    let word = state112.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for(let cycled = false, cursor = new SearchCursor(state112.doc, query, ranges[ranges.length - 1].to);;){
        cursor.next();
        if (cursor.done) {
            if (cycled) return null;
            cursor = new SearchCursor(state112.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
        } else {
            if (cycled && ranges.some((r)=>r.from == cursor.value.from
            )) continue;
            if (fullWord) {
                let word = state112.wordAt(cursor.value.from);
                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;
            }
            return cursor.value;
        }
    }
}
const selectNextOccurrence = ({ state: state113 , dispatch  })=>{
    let { ranges  } = state113.selection;
    if (ranges.some((sel)=>sel.from === sel.to
    )) return selectWord({
        state: state113,
        dispatch
    });
    let searchedText = state113.sliceDoc(ranges[0].from, ranges[0].to);
    if (state113.selection.ranges.some((r)=>state113.sliceDoc(r.from, r.to) != searchedText
    )) return false;
    let range = findNextOccurrence(state113, searchedText);
    if (!range) return false;
    dispatch(state113.update({
        selection: state113.selection.addRange(EditorSelection.range(range.from, range.to), false),
        effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
};
const searchConfigFacet = Facet.define({
    combine (configs) {
        return {
            top: configs.reduce((val, conf)=>val ?? conf.top
            , undefined) || false,
            caseSensitive: configs.reduce((val, conf)=>val ?? (conf.caseSensitive || conf.matchCase)
            , undefined) || false,
            createPanel: configs.find((c)=>c.createPanel
            )?.createPanel || ((view)=>new SearchPanel(view)
            )
        };
    }
});
class SearchQuery {
    search;
    caseSensitive;
    regexp;
    replace;
    valid;
    unquoted;
    constructor(config26){
        this.search = config26.search;
        this.caseSensitive = !!config26.caseSensitive;
        this.regexp = !!config26.regexp;
        this.replace = config26.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.search.replace(/\\([nrt\\])/g, (_, ch)=>ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\"
        );
    }
    eq(other) {
        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
    }
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(doc29, from = 0, to = doc29.length) {
        return this.regexp ? regexpCursor(this, doc29, from, to) : stringCursor(this, doc29, from, to);
    }
}
class QueryType1 {
    spec;
    constructor(spec){
        this.spec = spec;
    }
}
var FindPrev;
(function(FindPrev1) {
    FindPrev1[FindPrev1["ChunkSize"] = 10000] = "ChunkSize";
})(FindPrev || (FindPrev = {}));
function stringCursor(spec, doc30, from, to) {
    return new SearchCursor(doc30, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase()
    );
}
class StringQuery extends QueryType1 {
    constructor(spec){
        super(spec);
    }
    nextMatch(doc31, curFrom, curTo) {
        let cursor = stringCursor(this.spec, doc31, curTo, doc31.length).nextOverlapping();
        if (cursor.done) cursor = stringCursor(this.spec, doc31, 0, curFrom).nextOverlapping();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc32, from, to) {
        for(let pos = to;;){
            let start = Math.max(from, pos - FindPrev.ChunkSize - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, doc32, start, pos), range = null;
            while(!cursor.nextOverlapping().done)range = cursor.value;
            if (range) return range;
            if (start == from) return null;
            pos -= FindPrev.ChunkSize;
        }
    }
    prevMatch(doc33, curFrom, curTo) {
        return this.prevMatchInRange(doc33, 0, curFrom) || this.prevMatchInRange(doc33, curTo, doc33.length);
    }
    getReplacement(_result) {
        return this.spec.replace;
    }
    matchAll(doc34, limit) {
        let cursor = stringCursor(this.spec, doc34, 0, doc34.length), ranges = [];
        while(!cursor.next().done){
            if (ranges.length >= limit) return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(doc35, from, to, add6) {
        let cursor = stringCursor(this.spec, doc35, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc35.length));
        while(!cursor.next().done)add6(cursor.value.from, cursor.value.to);
    }
}
var RegExp1;
(function(RegExp) {
    RegExp[RegExp["HighlightMargin"] = 250] = "HighlightMargin";
})(RegExp1 || (RegExp1 = {}));
function regexpCursor(spec, doc36, from, to) {
    return new RegExpCursor(doc36, spec.search, spec.caseSensitive ? undefined : {
        ignoreCase: true
    }, from, to);
}
class RegExpQuery extends QueryType1 {
    nextMatch(doc37, curFrom, curTo) {
        let cursor = regexpCursor(this.spec, doc37, curTo, doc37.length).next();
        if (cursor.done) cursor = regexpCursor(this.spec, doc37, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc38, from, to) {
        for(let size = 1;; size++){
            let start = Math.max(from, to - size * FindPrev.ChunkSize);
            let cursor = regexpCursor(this.spec, doc38, start, to), range = null;
            while(!cursor.next().done)range = cursor.value;
            if (range && (start == from || range.from > start + 10)) return range;
            if (start == from) return null;
        }
    }
    prevMatch(doc39, curFrom, curTo) {
        return this.prevMatchInRange(doc39, 0, curFrom) || this.prevMatchInRange(doc39, curTo, doc39.length);
    }
    getReplacement(result) {
        return this.spec.replace.replace(/\$([$&\d+])/g, (m, i150)=>i150 == "$" ? "$" : i150 == "&" ? result.match[0] : i150 != "0" && +i150 < result.match.length ? result.match[i150] : m
        );
    }
    matchAll(doc40, limit) {
        let cursor = regexpCursor(this.spec, doc40, 0, doc40.length), ranges = [];
        while(!cursor.next().done){
            if (ranges.length >= limit) return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(doc41, from, to, add7) {
        let cursor = regexpCursor(this.spec, doc41, Math.max(0, from - RegExp1.HighlightMargin), Math.min(to + RegExp1.HighlightMargin, doc41.length));
        while(!cursor.next().done)add7(cursor.value.from, cursor.value.to);
    }
}
const setSearchQuery = StateEffect.define();
const togglePanel = StateEffect.define();
const searchState = StateField.define({
    create (state114) {
        return new SearchState(defaultQuery(state114).create(), null);
    },
    update (value, tr) {
        for (let effect of tr.effects){
            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: (f)=>showPanel.from(f, (val)=>val.panel
        )
});
class SearchState {
    query;
    panel;
    constructor(query, panel){
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = Decoration.mark({
    class: "cm-searchMatch"
}), selectedMatchMark = Decoration.mark({
    class: "cm-searchMatch cm-searchMatch-selected"
});
const searchHighlighter = ViewPlugin.fromClass(class {
    view;
    decorations;
    constructor(view){
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state115 = update.state.field(searchState);
        if (state115 != update.startState.field(searchState) || update.docChanged || update.selectionSet) this.decorations = this.highlight(state115);
    }
    highlight({ query , panel  }) {
        if (!panel || !query.spec.valid) return Decoration.none;
        let { view  } = this;
        let builder = new RangeSetBuilder();
        for(let i151 = 0, ranges = view.visibleRanges, l = ranges.length; i151 < l; i151++){
            let { from: from1 , to: to1  } = ranges[i151];
            while(i151 < l - 1 && to1 > ranges[i151 + 1].from - 2 * RegExp1.HighlightMargin)to1 = ranges[++i151].to;
            query.highlight(view.state.doc, from1, to1, (from, to)=>{
                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to
                );
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: (v)=>v.decorations
});
function searchCommand(f) {
    return (view)=>{
        let state116 = view.state.field(searchState, false);
        return state116 && state116.query.spec.valid ? f(view, state116) : openSearchPanel(view);
    };
}
const findNext = searchCommand((view, { query  })=>{
    let { from , to  } = view.state.selection.main;
    let next = query.nextMatch(view.state.doc, from, to);
    if (!next || next.from == from && next.to == to) return false;
    view.dispatch({
        selection: {
            anchor: next.from,
            head: next.to
        },
        scrollIntoView: true,
        effects: announceMatch(view, next),
        userEvent: "select.search"
    });
    return true;
});
const findPrevious = searchCommand((view, { query  })=>{
    let { state: state117  } = view, { from , to  } = state117.selection.main;
    let range = query.prevMatch(state117.doc, from, to);
    if (!range) return false;
    view.dispatch({
        selection: {
            anchor: range.from,
            head: range.to
        },
        scrollIntoView: true,
        effects: announceMatch(view, range),
        userEvent: "select.search"
    });
    return true;
});
const selectMatches = searchCommand((view, { query  })=>{
    let ranges = query.matchAll(view.state.doc, 1000);
    if (!ranges || !ranges.length) return false;
    view.dispatch({
        selection: EditorSelection.create(ranges.map((r)=>EditorSelection.range(r.from, r.to)
        )),
        userEvent: "select.search.matches"
    });
    return true;
});
const selectSelectionMatches = ({ state: state118 , dispatch  })=>{
    let sel = state118.selection;
    if (sel.ranges.length > 1 || sel.main.empty) return false;
    let { from , to  } = sel.main;
    let ranges = [], main = 0;
    for(let cur24 = new SearchCursor(state118.doc, state118.sliceDoc(from, to)); !cur24.next().done;){
        if (ranges.length > 1000) return false;
        if (cur24.value.from == from) main = ranges.length;
        ranges.push(EditorSelection.range(cur24.value.from, cur24.value.to));
    }
    dispatch(state118.update({
        selection: EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
    }));
    return true;
};
const replaceNext = searchCommand((view, { query  })=>{
    let { state: state119  } = view, { from , to  } = state119.selection.main;
    if (state119.readOnly) return false;
    let next = query.nextMatch(state119.doc, from, from);
    if (!next) return false;
    let changes = [], selection, replacement;
    if (next.from == from && next.to == to) {
        replacement = state119.toText(query.getReplacement(next));
        changes.push({
            from: next.from,
            to: next.to,
            insert: replacement
        });
        next = query.nextMatch(state119.doc, next.from, next.to);
    }
    if (next) {
        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
        selection = {
            anchor: next.from - off,
            head: next.to - off
        };
    }
    view.dispatch({
        changes,
        selection,
        scrollIntoView: !!selection,
        effects: next ? announceMatch(view, next) : undefined,
        userEvent: "input.replace"
    });
    return true;
});
const replaceAll = searchCommand((view, { query  })=>{
    if (view.state.readOnly) return false;
    let changes = query.matchAll(view.state.doc, 1000000000).map((match)=>{
        let { from , to  } = match;
        return {
            from,
            to,
            insert: query.getReplacement(match)
        };
    });
    if (!changes.length) return false;
    view.dispatch({
        changes,
        userEvent: "input.replace.all"
    });
    return true;
});
function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state120, fallback) {
    let sel = state120.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state120.sliceDoc(sel.from, sel.to);
    let caseSensitive = fallback?.caseSensitive ?? state120.facet(searchConfigFacet).caseSensitive;
    return fallback && !selText ? fallback : new SearchQuery({
        search: selText.replace(/\n/g, "\\n"),
        caseSensitive
    });
}
const openSearchPanel = (view)=>{
    let state121 = view.state.field(searchState, false);
    if (state121 && state121.panel) {
        let panel = getPanel(view, createSearchPanel);
        if (!panel) return false;
        let searchInput = panel.dom.querySelector("[name=search]");
        if (searchInput != view.root.activeElement) {
            let query = defaultQuery(view.state, state121.query.spec);
            if (query.valid) view.dispatch({
                effects: setSearchQuery.of(query)
            });
            searchInput.focus();
            searchInput.select();
        }
    } else {
        view.dispatch({
            effects: [
                togglePanel.of(true),
                state121 ? setSearchQuery.of(defaultQuery(view.state, state121.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
            ]
        });
    }
    return true;
};
const closeSearchPanel = (view)=>{
    let state122 = view.state.field(searchState, false);
    if (!state122 || !state122.panel) return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();
    view.dispatch({
        effects: togglePanel.of(false)
    });
    return true;
};
const searchKeymap = [
    {
        key: "Mod-f",
        run: openSearchPanel,
        scope: "editor search-panel"
    },
    {
        key: "F3",
        run: findNext,
        shift: findPrevious,
        scope: "editor search-panel",
        preventDefault: true
    },
    {
        key: "Mod-g",
        run: findNext,
        shift: findPrevious,
        scope: "editor search-panel",
        preventDefault: true
    },
    {
        key: "Escape",
        run: closeSearchPanel,
        scope: "editor search-panel"
    },
    {
        key: "Mod-Shift-l",
        run: selectSelectionMatches
    },
    {
        key: "Alt-g",
        run: gotoLine
    },
    {
        key: "Mod-d",
        run: selectNextOccurrence,
        preventDefault: true
    }, 
];
class SearchPanel {
    view;
    searchField;
    replaceField;
    caseField;
    reField;
    dom;
    query;
    constructor(view){
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = crelt("input", {
            value: query.search,
            placeholder: phrase(view, "Find"),
            "aria-label": phrase(view, "Find"),
            class: "cm-textfield",
            name: "search",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.replaceField = crelt("input", {
            value: query.replace,
            placeholder: phrase(view, "Replace"),
            "aria-label": phrase(view, "Replace"),
            class: "cm-textfield",
            name: "replace",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.caseField = crelt("input", {
            type: "checkbox",
            name: "case",
            checked: query.caseSensitive,
            onchange: this.commit
        });
        this.reField = crelt("input", {
            type: "checkbox",
            name: "re",
            checked: query.regexp,
            onchange: this.commit
        });
        function button(name21, onclick, content9) {
            return crelt("button", {
                class: "cm-button",
                name: name21,
                onclick,
                type: "button"
            }, content9);
        }
        this.dom = crelt("div", {
            onkeydown: (e)=>this.keydown(e)
            ,
            class: "cm-search"
        }, [
            this.searchField,
            button("next", ()=>findNext(view)
            , [
                phrase(view, "next")
            ]),
            button("prev", ()=>findPrevious(view)
            , [
                phrase(view, "previous")
            ]),
            button("select", ()=>selectMatches(view)
            , [
                phrase(view, "all")
            ]),
            crelt("label", null, [
                this.caseField,
                phrase(view, "match case")
            ]),
            crelt("label", null, [
                this.reField,
                phrase(view, "regexp")
            ]),
            ...view.state.readOnly ? [] : [
                crelt("br"),
                this.replaceField,
                button("replace", ()=>replaceNext(view)
                , [
                    phrase(view, "replace")
                ]),
                button("replaceAll", ()=>replaceAll(view)
                , [
                    phrase(view, "replace all")
                ]),
                crelt("button", {
                    name: "close",
                    onclick: ()=>closeSearchPanel(view)
                    ,
                    "aria-label": phrase(view, "close"),
                    type: "button"
                }, [
                    "×"
                ])
            ]
        ]);
    }
    commit() {
        let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            replace: this.replaceField.value
        });
        if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({
                effects: setSearchQuery.of(query)
            });
        }
    }
    keydown(e) {
        if (runScopeHandlers(this.view, e, "search-panel")) {
            e.preventDefault();
        } else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
        } else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
        }
    }
    update(update) {
        for (let tr of update.transactions)for (let effect of tr.effects){
            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);
        }
    }
    setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
    }
    mount() {
        this.searchField.select();
    }
    get pos() {
        return 80;
    }
    get top() {
        return this.view.state.facet(searchConfigFacet).top;
    }
}
function phrase(view, phrase1) {
    return view.state.phrase(phrase1);
}
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from , to  }) {
    let lineStart = view.state.doc.lineAt(from).from, lineEnd4 = view.state.doc.lineAt(to).to;
    let start = Math.max(lineStart, from - 30), end = Math.min(lineEnd4, to + 30);
    let text = view.state.sliceDoc(start, end);
    if (start != lineStart) {
        for(let i152 = 0; i152 < 30; i152++)if (!Break.test(text[i152 + 1]) && Break.test(text[i152])) {
            text = text.slice(i152);
            break;
        }
    }
    if (end != lineEnd4) {
        for(let i153 = text.length - 1; i153 > text.length - 30; i153--)if (!Break.test(text[i153 - 1]) && Break.test(text[i153])) {
            text = text.slice(0, i153);
            break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
}
const baseTheme6 = EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": {
        backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
        backgroundColor: "#00ffff8a"
    },
    "&light .cm-searchMatch-selected": {
        backgroundColor: "#ff6a0054"
    },
    "&dark .cm-searchMatch-selected": {
        backgroundColor: "#ff00ff8a"
    }
});
const searchExtensions = [
    searchState,
    Prec.lowest(searchHighlighter),
    baseTheme6
];
const ios1 = typeof navigator != "undefined" && !/Edge\/(\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
const Outside = "-10000px";
var Arrow;
(function(Arrow1) {
    Arrow1[Arrow1["Size"] = 7] = "Size";
    Arrow1[Arrow1["Offset"] = 14] = "Offset";
})(Arrow || (Arrow = {}));
class TooltipViewManager {
    facet;
    createTooltipView;
    input;
    tooltips;
    tooltipViews;
    constructor(view, facet, createTooltipView){
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter((t4)=>t4
        );
        this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update) {
        let input = update.state.facet(this.facet);
        let tooltips1 = input.filter((x)=>x
        );
        if (input === this.input) {
            for (let t5 of this.tooltipViews)if (t5.update) t5.update(update);
            return false;
        }
        let tooltipViews = [];
        for(let i154 = 0; i154 < tooltips1.length; i154++){
            let tip = tooltips1[i154], known = -1;
            if (!tip) continue;
            for(let i1 = 0; i1 < this.tooltips.length; i1++){
                let other = this.tooltips[i1];
                if (other && other.create == tip.create) known = i1;
            }
            if (known < 0) {
                tooltipViews[i154] = this.createTooltipView(tip);
            } else {
                let tooltipView = tooltipViews[i154] = this.tooltipViews[known];
                if (tooltipView.update) tooltipView.update(update);
            }
        }
        for (let t6 of this.tooltipViews)if (tooltipViews.indexOf(t6) < 0) t6.dom.remove();
        this.input = input;
        this.tooltips = tooltips1;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
function windowSpace() {
    return {
        top: 0,
        left: 0,
        bottom: innerHeight,
        right: innerWidth
    };
}
const tooltipConfig = Facet.define({
    combine: (values16)=>({
            position: ios1 ? "absolute" : values16.find((conf)=>conf.position
            )?.position || "fixed",
            parent: values16.find((conf)=>conf.parent
            )?.parent || null,
            tooltipSpace: values16.find((conf)=>conf.tooltipSpace
            )?.tooltipSpace || windowSpace
        })
});
const tooltipPlugin = ViewPlugin.fromClass(class {
    view;
    manager;
    measureReq;
    inView = true;
    position;
    parent;
    container;
    classes;
    intersectionObserver;
    lastTransaction = 0;
    measureTimeout = -1;
    constructor(view){
        this.view = view;
        let config27 = view.state.facet(tooltipConfig);
        this.position = config27.position;
        this.parent = config27.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = {
            read: this.readMeasure.bind(this),
            write: this.writeMeasure.bind(this),
            key: this
        };
        this.manager = new TooltipViewManager(view, showTooltip, (t7)=>this.createTooltip(t7)
        );
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries)=>{
            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();
        }, {
            threshold: [
                1
            ]
        }) : null;
        this.observeIntersection();
        view.dom.ownerDocument.defaultView?.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        } else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{
            this.measureTimeout = -1;
            this.maybeMeasure();
        }, 50);
    }
    update(update) {
        if (update.transactions.length) this.lastTransaction = Date.now();
        let updated = this.manager.update(update);
        if (updated) this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position) {
            this.position = newConfig.position;
            for (let t8 of this.manager.tooltipViews)t8.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent) this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t9 of this.manager.tooltipViews)this.container.appendChild(t9.dom);
            shouldMeasure = true;
        } else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure) this.maybeMeasure();
    }
    createTooltip(tooltip) {
        let tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        this.container.appendChild(tooltipView.dom);
        if (tooltipView.mount) tooltipView.mount(this.view);
        return tooltipView;
    }
    destroy() {
        this.view.dom.ownerDocument.defaultView?.removeEventListener("resize", this.measureSoon);
        for (let { dom  } of this.manager.tooltipViews)dom.remove();
        this.intersectionObserver?.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let editor = this.view.dom.getBoundingClientRect();
        return {
            editor,
            parent: this.parent ? this.container.getBoundingClientRect() : editor,
            pos: this.manager.tooltips.map((t10, i155)=>{
                let tv = this.manager.tooltipViews[i155];
                return tv.getCoords ? tv.getCoords(t10.pos) : this.view.coordsAtPos(t10.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom  })=>dom.getBoundingClientRect()
            ),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
        };
    }
    writeMeasure(measured) {
        let { editor , space: space6  } = measured;
        let others = [];
        for(let i156 = 0; i156 < this.manager.tooltips.length; i156++){
            let tooltip = this.manager.tooltips[i156], tView = this.manager.tooltipViews[i156], { dom  } = tView;
            let pos = measured.pos[i156], size = measured.size[i156];
            if (!pos || pos.bottom <= Math.max(editor.top, space6.top) || pos.top >= Math.min(editor.bottom, space6.bottom) || pos.right < Math.max(editor.left, space6.left) - 0.1 || pos.left > Math.min(editor.right, space6.right) + 0.1) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? Arrow.Size : 0;
            let width = size.right - size.left, height = size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space6.right - space6.left ? ltr ? space6.left : space6.right - size.width : ltr ? Math.min(pos.left - (arrow ? Arrow.Offset : 0) + offset.x, space6.right - width) : Math.max(space6.left, pos.left - width + (arrow ? Arrow.Offset : 0) - offset.x);
            let above = !!tooltip.above;
            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space6.top : pos.bottom + (size.bottom - size.top) + offset.y > space6.bottom) && above == space6.bottom - pos.bottom > pos.top - space6.top) above = !above;
            let top33 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true) {
                for (let r of others)if (r.left < right && r.right > left && r.top < top33 + height && r.bottom > top33) top33 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            }
            if (this.position == "absolute") {
                dom.style.top = top33 - measured.parent.top + "px";
                dom.style.left = left - measured.parent.left + "px";
            } else {
                dom.style.top = top33 + "px";
                dom.style.left = left + "px";
            }
            if (arrow) arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + Arrow.Offset - Arrow.Size)}px`;
            if (tView.overlap !== true) others.push({
                left,
                top: top33,
                right,
                bottom: top33 + height
            });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned) tView.positioned();
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView) this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventHandlers: {
        scroll () {
            this.maybeMeasure();
        }
    }
});
const baseTheme7 = EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 100
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${Arrow.Size}px`,
        width: `${Arrow.Size * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${Arrow.Size}px solid transparent`,
            borderRight: `${Arrow.Size}px solid transparent`
        },
        ".cm-tooltip-above &": {
            bottom: `-${Arrow.Size}px`,
            "&:before": {
                borderTop: `${Arrow.Size}px solid #bbb`
            },
            "&:after": {
                borderTop: `${Arrow.Size}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${Arrow.Size}px`,
            "&:before": {
                borderBottom: `${Arrow.Size}px solid #bbb`
            },
            "&:after": {
                borderBottom: `${Arrow.Size}px solid #f5f5f5`,
                top: "1px"
            }
        }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = {
    x: 0,
    y: 0
};
const showTooltip = Facet.define({
    enables: [
        tooltipPlugin,
        baseTheme7
    ]
});
const showHoverTooltip = Facet.define();
class HoverTooltipHost {
    view;
    manager;
    dom;
    mounted = false;
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view){
        this.view = view;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t11)=>this.createHostedView(t11)
        );
    }
    createHostedView(tooltip) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.appendChild(hostedView.dom);
        if (this.mounted && hostedView.mount) hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews){
            if (hostedView.mount) hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned() {
        for (let hostedView of this.manager.tooltipViews){
            if (hostedView.positioned) hostedView.positioned();
        }
    }
    update(update) {
        this.manager.update(update);
    }
}
const showHoverTooltipHost = showTooltip.compute([
    showHoverTooltip
], (state123)=>{
    let tooltips2 = state123.facet(showHoverTooltip).filter((t12)=>t12
    );
    if (tooltips2.length === 0) return null;
    return {
        pos: Math.min(...tooltips2.map((t13)=>t13.pos
        )),
        end: Math.max(...tooltips2.filter((t14)=>t14.end != null
        ).map((t15)=>t15.end
        )),
        create: HoverTooltipHost.create,
        above: tooltips2[0].above,
        arrow: tooltips2.some((t16)=>t16.arrow
        )
    };
});
var Hover;
(function(Hover2) {
    Hover2[Hover2["Time"] = 300] = "Time";
    Hover2[Hover2["MaxDist"] = 6] = "MaxDist";
})(Hover || (Hover = {}));
class HoverPlugin {
    view;
    source;
    field;
    setHover;
    hoverTime;
    lastMove;
    hoverTimeout = -1;
    restartTimeout = -1;
    pending = null;
    constructor(view, source, field, setHover, hoverTime){
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.lastMove = {
            x: 0,
            y: 0,
            target: view.dom,
            time: 0
        };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(()=>this.startHover()
            , 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active) return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { lastMove  } = this;
        let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
        if (pos == null) return;
        let posCoords = this.view.coordsAtPos(pos);
        if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth) return;
        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos
        );
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
        if (open?.then) {
            let pending = this.pending = {
                pos
            };
            open.then((result)=>{
                if (this.pending == pending) {
                    this.pending = null;
                    if (result) this.view.dispatch({
                        effects: this.setHover.of(result)
                    });
                }
            }, (e)=>logException(this.view.state, e, "hover tooltip")
            );
        } else if (open) {
            this.view.dispatch({
                effects: this.setHover.of(open)
            });
        }
    }
    mousemove(event) {
        this.lastMove = {
            x: event.clientX,
            y: event.clientY,
            target: event.target,
            time: Date.now()
        };
        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let tooltip = this.active;
        if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
            let { pos  } = tooltip || this.pending, end = tooltip?.end ?? pos;
            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, Hover.MaxDist)) {
                this.view.dispatch({
                    effects: this.setHover.of(null)
                });
                this.pending = null;
            }
        }
    }
    mouseleave() {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        if (this.active) this.view.dispatch({
            effects: this.setHover.of(null)
        });
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
function isInTooltip(elt15) {
    for(let cur25 = elt15; cur25; cur25 = cur25.parentNode)if (cur25.nodeType == 1 && cur25.classList.contains("cm-tooltip")) return true;
    return false;
}
function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for(let i157 = 0; i157 < rects.length; i157++){
        let rect = rects[i157];
        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
        if (dist <= margin) return true;
    }
    return false;
}
function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
        create () {
            return null;
        },
        update (value, tr) {
            if (value && options.hideOnChange && (tr.docChanged || tr.selection)) return null;
            for (let effect of tr.effects){
                if (effect.is(setHover)) return effect.value;
                if (effect.is(closeHoverTooltipEffect)) return null;
            }
            if (value && tr.docChanged) {
                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                if (newPos == null) return null;
                let copy4 = Object.assign(Object.create(null), value);
                copy4.pos = newPos;
                if (value.end != null) copy4.end = tr.changes.mapPos(value.end);
                return copy4;
            }
            return value;
        },
        provide: (f)=>showHoverTooltip.from(f)
    });
    return [
        hoverState,
        ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || Hover.Time)
        ),
        showHoverTooltipHost
    ];
}
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin) return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
const closeHoverTooltipEffect = StateEffect.define();
closeHoverTooltipEffect.of(null);
class CompletionContext {
    state;
    pos;
    explicit;
    abortListeners = [];
    constructor(state124, pos, explicit){
        this.state = state124;
        this.pos = pos;
        this.explicit = explicit;
    }
    tokenBefore(types3) {
        let token = syntaxTree(this.state).resolveInner(this.pos, -1);
        while(token && types3.indexOf(token.name) < 0)token = token.parent;
        return token ? {
            from: token.from,
            to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type
        } : null;
    }
    matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : {
            from: start + found,
            to: this.pos,
            text: str.slice(found)
        };
    }
    get aborted() {
        return this.abortListeners == null;
    }
    addEventListener(type, listener) {
        if (type == "abort" && this.abortListeners) this.abortListeners.push(listener);
    }
}
function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words) flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let { label  } of options){
        first[label[0]] = true;
        for(let i158 = 1; i158 < label.length; i158++)rest[label[i158]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [
        new RegExp("^" + source),
        new RegExp(source)
    ];
}
function completeFromList(list) {
    let options = list.map((o)=>typeof o == "string" ? {
            label: o
        } : o
    );
    let [span8, match] = options.every((o)=>/^\w+$/.test(o.label)
    ) ? [
        /\w*$/,
        /\w+$/
    ] : prefixMatch(options);
    return (context)=>{
        let token = context.matchBefore(match);
        return token || context.explicit ? {
            from: token ? token.from : context.pos,
            options,
            span: span8
        } : null;
    };
}
function ifNotIn(nodes, source) {
    return (context)=>{
        for(let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)if (nodes.indexOf(pos.name) > -1) return null;
        return source(context);
    };
}
class Option {
    completion;
    source;
    match;
    constructor(completion, source, match){
        this.completion = completion;
        this.source = source;
        this.match = match;
    }
}
function cur(state125) {
    return state125.selection.main.head;
}
function ensureAnchor(expr, start) {
    let { source  } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd) return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, expr.flags ?? (expr.ignoreCase ? "i" : ""));
}
const pickedCompletion = Annotation.define();
function applyCompletion(view, option) {
    let apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string") {
        view.dispatch({
            changes: {
                from: result.from,
                to: result.to,
                insert: apply
            },
            selection: {
                anchor: result.from + apply.length
            },
            userEvent: "input.complete",
            annotations: pickedCompletion.of(option.completion)
        });
    } else {
        apply(view, option.completion, result.from, result.to);
    }
}
const SourceCache = new WeakMap();
function asSource(source) {
    if (!Array.isArray(source)) return source;
    let known = SourceCache.get(source);
    if (!known) SourceCache.set(source, known = completeFromList(source));
    return known;
}
var Penalty;
(function(Penalty1) {
    Penalty1[Penalty1["Gap"] = -1100] = "Gap";
    Penalty1[Penalty1["NotStart"] = -700] = "NotStart";
    Penalty1[Penalty1["CaseFold"] = -200] = "CaseFold";
    Penalty1[Penalty1["ByWord"] = -100] = "ByWord";
})(Penalty || (Penalty = {}));
var Tp;
(function(Tp1) {
    Tp1[Tp1["NonWord"] = 0] = "NonWord";
    Tp1[Tp1["Upper"] = 1] = "Upper";
    Tp1[Tp1["Lower"] = 2] = "Lower";
})(Tp || (Tp = {}));
class FuzzyMatcher {
    pattern;
    chars = [];
    folded = [];
    astral;
    any = [];
    precise = [];
    byWord = [];
    constructor(pattern){
        this.pattern = pattern;
        for(let p18 = 0; p18 < pattern.length;){
            let __char = codePointAt(pattern, p18), size = codePointSize(__char);
            this.chars.push(__char);
            let part = pattern.slice(p18, p18 + size), upper = part.toUpperCase();
            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
            p18 += size;
        }
        this.astral = pattern.length != this.chars.length;
    }
    match(word) {
        if (this.pattern.length == 0) return [
            0
        ];
        if (word.length < this.pattern.length) return null;
        let { chars , folded , any , precise , byWord  } = this;
        if (chars.length == 1) {
            let first = codePointAt(word, 0);
            return first == chars[0] ? [
                0,
                0,
                codePointSize(first)
            ] : first == folded[0] ? [
                Penalty.CaseFold,
                0,
                codePointSize(first)
            ] : null;
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0) return [
            0,
            0,
            this.pattern.length
        ];
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
            for(let i159 = 0, e = Math.min(word.length, 200); i159 < e && anyTo < len;){
                let next = codePointAt(word, i159);
                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i159;
                i159 += codePointSize(next);
            }
            if (anyTo < len) return null;
        }
        let preciseTo = 0;
        let byWordTo = 0, byWordFolded = false;
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        for(let i160 = 0, e = Math.min(word.length, 200), prevType = Tp.NonWord; i160 < e && byWordTo < len;){
            let next = codePointAt(word, i160);
            if (direct < 0) {
                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i160;
                if (adjacentTo < len) {
                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                        if (adjacentTo == 0) adjacentStart = i160;
                        adjacentEnd = i160 + 1;
                        adjacentTo++;
                    } else {
                        adjacentTo = 0;
                    }
                }
            }
            let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? Tp.Lower : next >= 65 && next <= 90 ? Tp.Upper : Tp.NonWord : (ch = fromCodePoint(next)) != ch.toLowerCase() ? Tp.Upper : ch != ch.toUpperCase() ? Tp.Lower : Tp.NonWord;
            if (!i160 || type == Tp.Upper && hasLower || prevType == Tp.NonWord && type != Tp.NonWord) {
                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i160;
                else if (byWord.length) wordAdjacent = false;
            }
            prevType = type;
            i160 += codePointSize(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(Penalty.ByWord + (byWordFolded ? Penalty.CaseFold : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0) return [
            Penalty.CaseFold - word.length,
            0,
            adjacentEnd
        ];
        if (direct > -1) return [
            Penalty.NotStart - word.length,
            direct,
            direct + this.pattern.length
        ];
        if (adjacentTo == len) return [
            Penalty.CaseFold + Penalty.NotStart - word.length,
            adjacentStart,
            adjacentEnd
        ];
        if (byWordTo == len) return this.result(Penalty.ByWord + (byWordFolded ? Penalty.CaseFold : 0) + Penalty.NotStart + (wordAdjacent ? 0 : Penalty.Gap), byWord, word);
        return chars.length == 2 ? null : this.result((any[0] ? Penalty.NotStart : 0) + Penalty.CaseFold + Penalty.Gap, any, word);
    }
    result(score1, positions, word) {
        let result = [
            score1 - word.length
        ], i161 = 1;
        for (let pos of positions){
            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
            if (i161 > 1 && result[i161 - 1] == pos) result[i161 - 1] = to;
            else {
                result[i161++] = pos;
                result[i161++] = to;
            }
        }
        return result;
    }
}
const completionConfig = Facet.define({
    combine (configs) {
        return combineConfig(configs, {
            activateOnTyping: true,
            override: null,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            optionClass: ()=>""
            ,
            aboveCursor: false,
            icons: true,
            addToOptions: []
        }, {
            defaultKeymap: (a, b)=>a && b
            ,
            icons: (a, b)=>a && b
            ,
            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c))
            ,
            addToOptions: (a, b)=>a.concat(b)
        });
    }
});
function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
}
function optionContent(config28) {
    let content10 = config28.addToOptions.slice();
    if (config28.icons) content10.push({
        render (completion) {
            let icon = document.createElement("div");
            icon.classList.add("cm-completionIcon");
            if (completion.type) icon.classList.add(...completion.type.split(/\s+/g).map((cls)=>"cm-completionIcon-" + cls
            ));
            icon.setAttribute("aria-hidden", "true");
            return icon;
        },
        position: 20
    });
    content10.push({
        render (completion, _s, match) {
            let labelElt = document.createElement("span");
            labelElt.className = "cm-completionLabel";
            let { label  } = completion, off = 0;
            for(let j = 1; j < match.length;){
                let from = match[j++], to = match[j++];
                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                let span9 = labelElt.appendChild(document.createElement("span"));
                span9.appendChild(document.createTextNode(label.slice(from, to)));
                span9.className = "cm-completionMatchedText";
                off = to;
            }
            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));
            return labelElt;
        },
        position: 50
    }, {
        render (completion) {
            if (!completion.detail) return null;
            let detailElt = document.createElement("span");
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = completion.detail;
            return detailElt;
        },
        position: 80
    });
    return content10.sort((a, b)=>a.position - b.position
    ).map((a)=>a.render
    );
}
function createInfoDialog(option, view) {
    let dom = document.createElement("div");
    dom.className = "cm-tooltip cm-completionInfo";
    let { info  } = option.completion;
    if (typeof info == "string") {
        dom.textContent = info;
    } else {
        let content11 = info(option.completion);
        if (content11.then) content11.then((node)=>dom.appendChild(node)
        , (e)=>logException(view.state, e, "completion info")
        );
        else dom.appendChild(content11);
    }
    return dom;
}
function rangeAroundSelected(total, selected, max) {
    if (total <= max) return {
        from: 0,
        to: total
    };
    if (selected <= total >> 1) {
        let off = Math.floor(selected / max);
        return {
            from: off * max,
            to: (off + 1) * max
        };
    }
    let off = Math.floor((total - selected) / max);
    return {
        from: total - (off + 1) * max,
        to: total - off * max
    };
}
class CompletionTooltip {
    view;
    stateField;
    dom;
    info = null;
    list;
    placeInfo = {
        read: ()=>this.measureInfo()
        ,
        write: (pos)=>this.positionInfo(pos)
        ,
        key: this
    };
    range;
    optionContent;
    optionClass;
    constructor(view, stateField){
        this.view = view;
        this.stateField = stateField;
        let cState = view.state.field(stateField);
        let { options , selected  } = cState.open;
        let config29 = view.state.facet(completionConfig);
        this.optionContent = optionContent(config29);
        this.optionClass = config29.optionClass;
        this.range = rangeAroundSelected(options.length, selected, config29.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.dom.addEventListener("mousedown", (e)=>{
            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){
                if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                    applyCompletion(view, options[+match[1]]);
                    e.preventDefault();
                    return;
                }
            }
        });
        this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
        this.list.addEventListener("scroll", ()=>{
            if (this.info) this.view.requestMeasure(this.placeInfo);
        });
    }
    mount() {
        this.updateSel();
    }
    update(update) {
        if (update.state.field(this.stateField) != update.startState.field(this.stateField)) this.updateSel();
    }
    positioned() {
        if (this.info) this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected < this.range.from || open.selected >= this.range.to) {
            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.list.remove();
            this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
            this.list.addEventListener("scroll", ()=>{
                if (this.info) this.view.requestMeasure(this.placeInfo);
            });
        }
        if (this.updateSelectedOption(open.selected)) {
            if (this.info) {
                this.info.remove();
                this.info = null;
            }
            let option = open.options[open.selected];
            if (option.completion.info) {
                this.info = this.dom.appendChild(createInfoDialog(option, this.view));
                this.view.requestMeasure(this.placeInfo);
            }
        }
    }
    updateSelectedOption(selected) {
        let set = null;
        for(let opt = this.list.firstChild, i162 = this.range.from; opt; opt = opt.nextSibling, i162++){
            if (i162 == selected) {
                if (!opt.hasAttribute("aria-selected")) {
                    opt.setAttribute("aria-selected", "true");
                    set = opt;
                }
            } else {
                if (opt.hasAttribute("aria-selected")) opt.removeAttribute("aria-selected");
            }
        }
        if (set) scrollIntoView1(this.list, set);
        return set;
    }
    measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info) return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10) return null;
        let top34 = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;
        let left = this.view.textDirection == Direction.RTL;
        let spaceLeft = listRect.left, spaceRight = innerWidth - listRect.right;
        if (left && spaceLeft < Math.min(infoRect.width, spaceRight)) left = false;
        else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft)) left = true;
        return {
            top: top34,
            left
        };
    }
    positionInfo(pos) {
        if (this.info) {
            this.info.style.top = (pos ? pos.top : -1000000) + "px";
            if (pos) {
                this.info.classList.toggle("cm-completionInfo-left", pos.left);
                this.info.classList.toggle("cm-completionInfo-right", !pos.left);
            }
        }
    }
    createListBox(options, id11, range) {
        const ul = document.createElement("ul");
        ul.id = id11;
        ul.setAttribute("role", "listbox");
        for(let i163 = range.from; i163 < range.to; i163++){
            let { completion , match  } = options[i163];
            const li = ul.appendChild(document.createElement("li"));
            li.id = id11 + "-" + i163;
            li.setAttribute("role", "option");
            let cls = this.optionClass(completion);
            if (cls) li.className = cls;
            for (let source of this.optionContent){
                let node = source(completion, this.view.state, match);
                if (node) li.appendChild(node);
            }
        }
        if (range.from) ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length) ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
    }
}
function completionTooltip(stateField) {
    return (view)=>new CompletionTooltip(view, stateField)
    ;
}
function scrollIntoView1(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top) container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;
}
function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state126) {
    let options = [], i164 = 0;
    for (let a of active)if (a.hasResult()) {
        if (a.result.filter === false) {
            for (let option of a.result.options)options.push(new Option(option, a, [
                1000000000 - i164++
            ]));
        } else {
            let matcher = new FuzzyMatcher(state126.sliceDoc(a.from, a.to)), match;
            for (let option of a.result.options)if (match = matcher.match(option.label)) {
                if (option.boost != null) match[0] += option.boost;
                options.push(new Option(option, a, match));
            }
        }
    }
    let result = [], prev = null;
    for (let opt of options.sort(cmpOption)){
        if (result.length == 300) break;
        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != opt.completion.type || prev.apply != opt.completion.apply) result.push(opt);
        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;
        prev = opt.completion;
    }
    return result;
}
class CompletionDialog {
    options;
    attrs;
    tooltip;
    timestamp;
    selected;
    constructor(options, attrs, tooltip, timestamp, selected){
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
    }
    setSelected(selected, id12) {
        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id12, selected), this.tooltip, this.timestamp, selected);
    }
    static build(active, state127, id13, prev, conf) {
        let options = sortOptions(active, state127);
        if (!options.length) return null;
        let selected = 0;
        if (prev && prev.selected) {
            let selectedValue = prev.options[prev.selected].completion;
            for(let i165 = 0; i165 < options.length; i165++)if (options[i165].completion == selectedValue) {
                selected = i165;
                break;
            }
        }
        return new CompletionDialog(options, makeAttrs(id13, selected), {
            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a
            , 100000000),
            create: completionTooltip(completionState),
            above: conf.aboveCursor
        }, prev ? prev.timestamp : Date.now(), selected);
    }
    map(changes) {
        return new CompletionDialog(this.options, this.attrs, {
            ...this.tooltip,
            pos: changes.mapPos(this.tooltip.pos)
        }, this.timestamp, this.selected);
    }
}
class CompletionState {
    active;
    id;
    open;
    constructor(active, id14, open){
        this.active = active;
        this.id = id14;
        this.open = open;
    }
    static start() {
        return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2000000).toString(36), null);
    }
    update(tr) {
        let { state: state128  } = tr, conf = state128.facet(completionConfig);
        let sources = conf.override || state128.languageDataAt("autocomplete", cur(state128)).map(asSource);
        let active = sources.map((source)=>{
            let value = this.active.find((s)=>s.source == source
            ) || new ActiveSource(source, this.active.some((a)=>a.state != State.Inactive
            ) ? State.Pending : State.Inactive);
            return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i166)=>a == this.active[i166]
        )) active = this.active;
        let open = tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)
        ) || !sameResults(active, this.active) ? CompletionDialog.build(active, state128, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
        if (!open && active.every((a)=>a.state != State.Pending
        ) && active.some((a)=>a.hasResult()
        )) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, State.Inactive) : a
        );
        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
        return this.open ? this.open.tooltip : null;
    }
    get attrs() {
        return this.open ? this.open.attrs : baseAttrs;
    }
}
function sameResults(a, b) {
    if (a == b) return true;
    for(let iA = 0, iB = 0;;){
        while(iA < a.length && !a[iA].hasResult)iA++;
        while(iB < b.length && !b[iB].hasResult)iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB) return endA == endB;
        if (a[iA++].result != b[iB++].result) return false;
    }
}
const baseAttrs = {
    "aria-autocomplete": "list",
    "aria-expanded": "false"
};
function makeAttrs(id15, selected) {
    return {
        "aria-autocomplete": "list",
        "aria-expanded": "true",
        "aria-activedescendant": id15 + "-" + selected,
        "aria-controls": id15
    };
}
const none3 = [];
function cmpOption(a, b) {
    let dScore = b.match[0] - a.match[0];
    if (dScore) return dScore;
    return a.completion.label.localeCompare(b.completion.label);
}
var State;
(function(State2) {
    State2[State2["Inactive"] = 0] = "Inactive";
    State2[State2["Pending"] = 1] = "Pending";
    State2[State2["Result"] = 2] = "Result";
})(State || (State = {}));
function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}
class ActiveSource {
    source;
    state;
    explicitPos;
    constructor(source, state129, explicitPos = -1){
        this.source = source;
        this.state = state129;
        this.explicitPos = explicitPos;
    }
    hasResult() {
        return false;
    }
    update(tr, conf) {
        let event = getUserEvent(tr), value = this;
        if (event) value = value.handleUserEvent(tr, event, conf);
        else if (tr.docChanged) value = value.handleChange(tr);
        else if (tr.selection && value.state != State.Inactive) value = new ActiveSource(value.source, State.Inactive);
        for (let effect of tr.effects){
            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, State.Pending, effect.value ? cur(tr.state) : -1);
            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, State.Inactive);
            else if (effect.is(setActiveEffect)) {
                for (let active of effect.value)if (active.source == value.source) value = active;
            }
        }
        return value;
    }
    handleUserEvent(tr, type, conf) {
        return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, State.Pending);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, State.Inactive) : this.map(tr.changes);
    }
    map(changes) {
        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
}
class ActiveResult extends ActiveSource {
    result;
    from;
    to;
    span;
    constructor(source, explicitPos, result, from, to, span10){
        super(source, State.Result, explicitPos);
        this.result = result;
        this.from = from;
        this.to = to;
        this.span = span10;
    }
    hasResult() {
        return true;
    }
    handleUserEvent(tr, type, conf) {
        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? State.Pending : State.Inactive);
        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);
        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to)))) return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);
        return new ActiveSource(this.source, State.Pending, explicitPos);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, State.Inactive) : this.map(tr.changes);
    }
    map(mapping) {
        return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);
    }
}
const startCompletionEffect = StateEffect.define();
const closeCompletionEffect = StateEffect.define();
const setActiveEffect = StateEffect.define({
    map (sources, mapping) {
        return sources.map((s)=>s.map(mapping)
        );
    }
});
const setSelectedEffect = StateEffect.define();
const completionState = StateField.define({
    create () {
        return CompletionState.start();
    },
    update (value, tr) {
        return value.update(tr);
    },
    provide: (f)=>[
            showTooltip.from(f, (val)=>val.tooltip
            ),
            EditorView.contentAttributes.from(f, (state130)=>state130.attrs
            )
        ]
});
function moveCompletionSelection(forward, by = "option") {
    return (view)=>{
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.open || Date.now() - cState.open.timestamp < 75) return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
        let selected = cState.open.selected + step * (forward ? 1 : -1), { length  } = cState.open.options;
        if (selected < 0) selected = by == "page" ? 0 : length - 1;
        else if (selected >= length) selected = by == "page" ? length - 1 : 0;
        view.dispatch({
            effects: setSelectedEffect.of(selected)
        });
        return true;
    };
}
const acceptCompletion = (view)=>{
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < 75) return false;
    applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
};
const startCompletion = (view)=>{
    let cState = view.state.field(completionState, false);
    if (!cState) return false;
    view.dispatch({
        effects: startCompletionEffect.of(true)
    });
    return true;
};
const closeCompletion = (view)=>{
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a)=>a.state != State.Inactive
    )) return false;
    view.dispatch({
        effects: closeCompletionEffect.of(null)
    });
    return true;
};
class RunningQuery {
    active;
    context;
    time = Date.now();
    updates = [];
    done = undefined;
    constructor(active, context){
        this.active = active;
        this.context = context;
    }
}
const DebounceTime = 50;
var CompositionState;
(function(CompositionState1) {
    CompositionState1[CompositionState1["None"] = 0] = "None";
    CompositionState1[CompositionState1["Started"] = 1] = "Started";
    CompositionState1[CompositionState1["Changed"] = 2] = "Changed";
    CompositionState1[CompositionState1["ChangedAndMoved"] = 3] = "ChangedAndMoved";
})(CompositionState || (CompositionState = {}));
const completionPlugin = ViewPlugin.fromClass(class {
    view;
    debounceUpdate = -1;
    running = [];
    debounceAccept = -1;
    composing = CompositionState.None;
    constructor(view){
        this.view = view;
        for (let active of view.state.field(completionState).active)if (active.state == State.Pending) this.startQuery(active);
    }
    update(update) {
        let cState = update.state.field(completionState);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;
        let doesReset = update.transactions.some((tr)=>{
            return (tr.selection || tr.docChanged) && !getUserEvent(tr);
        });
        for(let i167 = 0; i167 < this.running.length; i167++){
            let query = this.running[i167];
            if (doesReset || query.updates.length + update.transactions.length > 50 && Date.now() - query.time > 1000) {
                for (let handler of query.context.abortListeners){
                    try {
                        handler();
                    } catch (e) {
                        logException(this.view.state, e);
                    }
                }
                query.context.abortListeners = null;
                this.running.splice(i167--, 1);
            } else {
                query.updates.push(...update.transactions);
            }
        }
        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);
        this.debounceUpdate = cState.active.some((a)=>a.state == State.Pending && !this.running.some((q)=>q.active.source == a.source
            )
        ) ? setTimeout(()=>this.startUpdate()
        , DebounceTime) : -1;
        if (this.composing != CompositionState.None) for (let tr1 of update.transactions){
            if (getUserEvent(tr1) == "input") this.composing = CompositionState.Changed;
            else if (this.composing == CompositionState.Changed && tr1.selection) this.composing = CompositionState.ChangedAndMoved;
        }
    }
    startUpdate() {
        this.debounceUpdate = -1;
        let { state: state131  } = this.view, cState = state131.field(completionState);
        for (let active of cState.active){
            if (active.state == State.Pending && !this.running.some((r)=>r.active.source == active.source
            )) this.startQuery(active);
        }
    }
    startQuery(active) {
        let { state: state132  } = this.view, pos = cur(state132);
        let context = new CompletionContext(state132, pos, active.explicitPos == pos);
        let pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then((result)=>{
            if (!pending.context.aborted) {
                pending.done = result || null;
                this.scheduleAccept();
            }
        }, (err)=>{
            this.view.dispatch({
                effects: closeCompletionEffect.of(null)
            });
            logException(this.view.state, err);
        });
    }
    scheduleAccept() {
        if (this.running.every((q)=>q.done !== undefined
        )) this.accept();
        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept()
        , DebounceTime);
    }
    accept() {
        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig);
        for(let i168 = 0; i168 < this.running.length; i168++){
            let query = this.running[i168];
            if (query.done === undefined) continue;
            this.running.splice(i168--, 1);
            if (query.done) {
                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, query.done.to ?? cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null);
                for (let tr of query.updates)active = active.update(tr, conf);
                if (active.hasResult()) {
                    updated.push(active);
                    continue;
                }
            }
            let current = this.view.state.field(completionState).active.find((a)=>a.source == query.active.source
            );
            if (current && current.state == State.Pending) {
                if (query.done == null) {
                    let active = new ActiveSource(query.active.source, State.Inactive);
                    for (let tr of query.updates)active = active.update(tr, conf);
                    if (active.state != State.Pending) updated.push(active);
                } else {
                    this.startQuery(current);
                }
            }
        }
        if (updated.length) this.view.dispatch({
            effects: setActiveEffect.of(updated)
        });
    }
}, {
    eventHandlers: {
        compositionstart () {
            this.composing = CompositionState.Started;
        },
        compositionend () {
            if (this.composing == CompositionState.ChangedAndMoved) {
                setTimeout(()=>this.view.dispatch({
                        effects: startCompletionEffect.of(false)
                    })
                , 20);
            }
            this.composing = CompositionState.None;
        }
    }
});
const baseTheme8 = EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer",
                padding: "1px 3px",
                lineHeight: 1.2
            }
        }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"···"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: "300px"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
        right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
        left: "100%"
    },
    "&light .cm-snippetField": {
        backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
        backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": {
            content: "'ƒ'"
        }
    },
    ".cm-completionIcon-class": {
        "&:after": {
            content: "'○'"
        }
    },
    ".cm-completionIcon-interface": {
        "&:after": {
            content: "'◌'"
        }
    },
    ".cm-completionIcon-variable": {
        "&:after": {
            content: "'𝑥'"
        }
    },
    ".cm-completionIcon-constant": {
        "&:after": {
            content: "'𝐶'"
        }
    },
    ".cm-completionIcon-type": {
        "&:after": {
            content: "'𝑡'"
        }
    },
    ".cm-completionIcon-enum": {
        "&:after": {
            content: "'∪'"
        }
    },
    ".cm-completionIcon-property": {
        "&:after": {
            content: "'□'"
        }
    },
    ".cm-completionIcon-keyword": {
        "&:after": {
            content: "'🔑\uFE0E'"
        }
    },
    ".cm-completionIcon-namespace": {
        "&:after": {
            content: "'▢'"
        }
    },
    ".cm-completionIcon-text": {
        "&:after": {
            content: "'abc'",
            fontSize: "50%",
            verticalAlign: "middle"
        }
    }
});
class FieldPos {
    field;
    line;
    from;
    to;
    constructor(field, line, from, to){
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    field;
    from;
    to;
    constructor(field, from, to){
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
        let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
        return from == null || to == null ? null : new FieldRange(this.field, from, to);
    }
}
class Snippet {
    lines;
    fieldPositions;
    constructor(lines, fieldPositions){
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state133, pos1) {
        let text = [], lineStart = [
            pos1
        ];
        let lineObj = state133.doc.lineAt(pos1), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines){
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for(let i169 = 0; i169 < tabs; i169++)indent += state133.facet(indentUnit);
                lineStart.push(pos1 + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos1 += line.length + 1;
        }
        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to)
        );
        return {
            text,
            ranges
        };
    }
    static parse(template1) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template1.split(/\r\n?|\n/)){
            while(m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)){
                let seq = m[1] ? +m[1] : null, name22 = m[2] || m[3] || "", found = -1;
                for(let i170 = 0; i170 < fields.length; i170++){
                    if (seq != null ? fields[i170].seq == seq : name22 ? fields[i170].name == name22 : false) found = i170;
                }
                if (found < 0) {
                    let i171 = 0;
                    while(i171 < fields.length && (seq == null || fields[i171].seq != null && fields[i171].seq < seq))i171++;
                    fields.splice(i171, 0, {
                        seq,
                        name: name22
                    });
                    found = i171;
                    for (let pos of positions)if (pos.field >= found) pos.field++;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name22.length));
                line = line.slice(0, m.index) + name22 + line.slice(m.index + m[0].length);
            }
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
let fieldMarker = Decoration.widget({
    widget: new class extends WidgetType {
        toDOM() {
            let span11 = document.createElement("span");
            span11.className = "cm-snippetFieldPosition";
            return span11;
        }
        ignoreEvent() {
            return false;
        }
    }
});
let fieldRange = Decoration.mark({
    class: "cm-snippetField"
});
class ActiveSnippet {
    ranges;
    active;
    deco;
    constructor(ranges, active){
        this.ranges = ranges;
        this.active = active;
        this.deco = Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)
        ));
    }
    map(changes) {
        let ranges = [];
        for (let r of this.ranges){
            let mapped = r.map(changes);
            if (!mapped) return null;
            ranges.push(mapped);
        }
        return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to
            )
        );
    }
}
const setActive = StateEffect.define({
    map (value, changes) {
        return value && value.map(changes);
    }
});
const moveToField = StateEffect.define();
const snippetState = StateField.define({
    create () {
        return null;
    },
    update (value, tr) {
        for (let effect of tr.effects){
            if (effect.is(setActive)) return effect.value;
            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged) value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;
        return value;
    },
    provide: (f)=>EditorView.decorations.from(f, (val)=>val ? val.deco : Decoration.none
        )
});
function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter((r)=>r.field == field
    ).map((r)=>EditorSelection.range(r.from, r.to)
    ));
}
function snippet(template2) {
    let snippet1 = Snippet.parse(template2);
    return (editor, _completion, from, to)=>{
        let { text , ranges  } = snippet1.instantiate(editor.state, from);
        let spec = {
            changes: {
                from,
                to,
                insert: Text.of(text)
            }
        };
        if (ranges.length) spec.selection = fieldSelection(ranges, 0);
        if (ranges.length > 1) {
            let active = new ActiveSnippet(ranges, 0);
            let effects = spec.effects = [
                setActive.of(active)
            ];
            if (editor.state.field(snippetState, false) === undefined) effects.push(StateEffect.appendConfig.of([
                snippetState,
                addSnippetKeymap,
                snippetPointerHandler,
                baseTheme8
            ]));
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state: state134 , dispatch  })=>{
        let active = state134.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0) return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir
        );
        dispatch(state134.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
        }));
        return true;
    };
}
const clearSnippet = ({ state: state135 , dispatch  })=>{
    let active = state135.field(snippetState, false);
    if (!active) return false;
    dispatch(state135.update({
        effects: setActive.of(null)
    }));
    return true;
};
const nextSnippetField = moveField(1);
const prevSnippetField = moveField(-1);
const defaultSnippetKeymap = [
    {
        key: "Tab",
        run: nextSnippetField,
        shift: prevSnippetField
    },
    {
        key: "Escape",
        run: clearSnippet
    }
];
const snippetKeymap = Facet.define({
    combine (maps) {
        return maps.length ? maps[0] : defaultSnippetKeymap;
    }
});
const addSnippetKeymap = Prec.highest(keymap.compute([
    snippetKeymap
], (state136)=>state136.facet(snippetKeymap)
));
function snippetCompletion(template3, completion) {
    return {
        ...completion,
        apply: snippet(template3)
    };
}
const snippetPointerHandler = EditorView.domEventHandlers({
    mousedown (event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({
            x: event.clientX,
            y: event.clientY
        })) == null) return false;
        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos
        );
        if (!match || match.field == active.active) return false;
        view.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some((r)=>r.field > match.field
            ) ? new ActiveSnippet(active.ranges, match.field) : null)
        });
        return true;
    }
});
var C3;
(function(C6) {
    C6[C6["Range"] = 50000] = "Range";
    C6[C6["MinCacheLen"] = 1000] = "MinCacheLen";
    C6[C6["MaxList"] = 2000] = "MaxList";
})(C3 || (C3 = {}));
Object.create(null);
function autocompletion(config30 = {}) {
    return [
        completionState,
        completionConfig.of(config30),
        completionPlugin,
        completionKeymapExt,
        baseTheme8
    ];
}
const completionKeymap = [
    {
        key: "Ctrl-Space",
        run: startCompletion
    },
    {
        key: "Escape",
        run: closeCompletion
    },
    {
        key: "ArrowDown",
        run: moveCompletionSelection(true)
    },
    {
        key: "ArrowUp",
        run: moveCompletionSelection(false)
    },
    {
        key: "PageDown",
        run: moveCompletionSelection(true, "page")
    },
    {
        key: "PageUp",
        run: moveCompletionSelection(false, "page")
    },
    {
        key: "Enter",
        run: acceptCompletion
    }
];
const completionKeymapExt = Prec.highest(keymap.computeN([
    completionConfig
], (state137)=>state137.facet(completionConfig).defaultKeymap ? [
        completionKeymap
    ] : []
));
const toggleComment = (target)=>{
    let config31 = getConfig(target.state);
    return config31.line ? toggleLineComment(target) : config31.block ? toggleBlockCommentByLine(target) : false;
};
var CommentOption;
(function(CommentOption1) {
    CommentOption1[CommentOption1["Toggle"] = 0] = "Toggle";
    CommentOption1[CommentOption1["Comment"] = 1] = "Comment";
    CommentOption1[CommentOption1["Uncomment"] = 2] = "Uncomment";
})(CommentOption || (CommentOption = {}));
function command(f, option) {
    return ({ state: state138 , dispatch  })=>{
        if (state138.readOnly) return false;
        let tr = f(option, state138);
        if (!tr) return false;
        dispatch(state138.update(tr));
        return true;
    };
}
const toggleLineComment = command(changeLineComment, CommentOption.Toggle);
command(changeLineComment, CommentOption.Comment);
command(changeLineComment, CommentOption.Uncomment);
const toggleBlockComment = command(changeBlockComment, CommentOption.Toggle);
command(changeBlockComment, CommentOption.Comment);
command(changeBlockComment, CommentOption.Uncomment);
const toggleBlockCommentByLine = command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s))
, CommentOption.Toggle);
const commentKeymap = [
    {
        key: "Mod-/",
        run: toggleComment
    },
    {
        key: "Alt-A",
        run: toggleBlockComment
    }
];
function getConfig(state139, pos = state139.selection.main.head) {
    let data8 = state139.languageDataAt("commentTokens", pos);
    return data8.length ? data8[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state140, { open , close  }, from, to) {
    let textBefore = state140.sliceDoc(from - 50, from);
    let textAfter = state140.sliceDoc(to, to + 50);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return {
            open: {
                pos: from - spaceBefore,
                margin: spaceBefore && 1
            },
            close: {
                pos: to + spaceAfter,
                margin: spaceAfter && 1
            }
        };
    }
    let startText, endText;
    if (to - from <= 2 * 50) {
        startText = endText = state140.sliceDoc(from, to);
    } else {
        startText = state140.sliceDoc(from, from + SearchMargin);
        endText = state140.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
        return {
            open: {
                pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
            },
            close: {
                pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
            }
        };
    }
    return null;
}
function selectedLineRanges(state141) {
    let ranges = [];
    for (let r of state141.selection.ranges){
        let fromLine = state141.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state141.doc.lineAt(r.to);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;
        else ranges.push({
            from: fromLine.from,
            to: toLine.to
        });
    }
    return ranges;
}
function changeBlockComment(option, state142, ranges = state142.selection.ranges) {
    let tokens = ranges.map((r)=>getConfig(state142, r.from).block
    );
    if (!tokens.every((c)=>c
    )) return null;
    let comments = ranges.map((r, i172)=>findBlockComment(state142, tokens[i172], r.from, r.to)
    );
    if (option != CommentOption.Uncomment && !comments.every((c)=>c
    )) {
        return {
            changes: state142.changes(ranges.map((range, i173)=>{
                if (comments[i173]) return [];
                return [
                    {
                        from: range.from,
                        insert: tokens[i173].open + " "
                    },
                    {
                        from: range.to,
                        insert: " " + tokens[i173].close
                    }
                ];
            }))
        };
    } else if (option != CommentOption.Comment && comments.some((c)=>c
    )) {
        let changes = [];
        for(let i174 = 0, comment1; i174 < comments.length; i174++)if (comment1 = comments[i174]) {
            let token = tokens[i174], { open , close  } = comment1;
            changes.push({
                from: open.pos - token.open.length,
                to: open.pos + open.margin
            }, {
                from: close.pos - close.margin,
                to: close.pos + token.close.length
            });
        }
        return {
            changes
        };
    }
    return null;
}
function changeLineComment(option, state143, ranges = state143.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from , to  } of ranges){
        let startI = lines.length, minIndent = 1000000000;
        for(let pos = from; pos <= to;){
            let line = state143.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let token = getConfig(state143, pos).line;
                if (!token) continue;
                let indent = /^\s*/.exec(line.text)[0].length;
                let empty1 = indent == line.length;
                let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent) minIndent = indent;
                lines.push({
                    line,
                    comment: comment2,
                    token,
                    indent,
                    empty: empty1,
                    single: false
                });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1000000000) {
            for(let i175 = startI; i175 < lines.length; i175++)if (lines[i175].indent < lines[i175].line.text.length) lines[i175].indent = minIndent;
        }
        if (lines.length == startI + 1) lines[startI].single = true;
    }
    if (option != CommentOption.Uncomment && lines.some((l)=>l.comment < 0 && (!l.empty || l.single)
    )) {
        let changes = [];
        for (let { line , token , indent , empty: empty2 , single  } of lines)if (single || !empty2) changes.push({
            from: line.from + indent,
            insert: token + " "
        });
        let changeSet = state143.changes(changes);
        return {
            changes: changeSet,
            selection: state143.selection.map(changeSet, 1)
        };
    } else if (option != CommentOption.Comment && lines.some((l)=>l.comment >= 0
    )) {
        let changes = [];
        for (let { line , comment: comment3 , token  } of lines)if (comment3 >= 0) {
            let from = line.from + comment3, to = from + token.length;
            if (line.text[to - line.from] == " ") to++;
            changes.push({
                from,
                to
            });
        }
        return {
            changes
        };
    }
    return null;
}
function rectangleFor(state144, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > 2000 || b.off > 2000 || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for(let i176 = startLine; i176 <= endLine; i176++){
            let line = state144.doc.line(i176);
            if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    } else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for(let i177 = startLine; i177 <= endLine; i177++){
            let line = state144.doc.line(i177);
            let start = findColumn(line.text, startCol, state144.tabSize, true);
            if (start > -1) {
                let end = findColumn(line.text, endCol, state144.tabSize);
                ranges.push(EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({
        x: event.clientX,
        y: event.clientY
    }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > 2000 ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return {
        line: line.number,
        col,
        off
    };
}
function rectangleSelectionStyle(view, event1) {
    let start = getPos(view, event1), startSel = view.state.selection;
    if (!start) return null;
    return {
        update (update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = {
                    line: newLine.number,
                    col: start.col,
                    off: Math.min(start.off, newLine.length)
                };
                startSel = startSel.map(update.changes);
            }
        },
        get (event, _extend, multiple) {
            let cur26 = getPos(view, event);
            if (!cur26) return startSel;
            let ranges = rectangleFor(view.state, start, cur26);
            if (!ranges.length) return startSel;
            if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));
            else return EditorSelection.create(ranges);
        }
    };
}
function rectangularSelection(options) {
    let filter = options?.eventFilter || ((e)=>e.altKey && e.button == 0
    );
    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null
    );
}
let nextTagID = 0;
class Tag {
    set;
    base;
    modified;
    id = nextTagID++;
    constructor(set, base17, modified){
        this.set = set;
        this.base = base17;
        this.modified = modified;
    }
    static define(parent) {
        if (parent?.base) throw new Error("Can not derive from a modified tag");
        let tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent) for (let t1 of parent.set)tag.set.push(t1);
        return tag;
    }
    static defineModifier() {
        let mod51 = new Modifier;
        return (tag)=>{
            if (tag.modified.indexOf(mod51) > -1) return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod51).sort((a, b)=>a.id - b.id
            ));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    instances = [];
    id = nextModifierID++;
    static get(base18, mods) {
        if (!mods.length) return base18;
        let exists = mods[0].instances.find((t2)=>t2.base == base18 && sameArray1(mods, t2.modified)
        );
        if (exists) return exists;
        let set = [], tag = new Tag(set, base18, mods);
        for (let m of mods)m.instances.push(tag);
        let configs = permute(mods);
        for (let parent of base18.set)for (let config32 of configs)set.push(Modifier.get(parent, config32));
        return tag;
    }
}
function sameArray1(a, b) {
    return a.length == b.length && a.every((x, i178)=>x == b[i178]
    );
}
function permute(array) {
    let result = [
        array
    ];
    for(let i179 = 0; i179 < array.length; i179++){
        for (let a of permute(array.slice(0, i179).concat(array.slice(i179 + 1))))result.push(a);
    }
    return result;
}
function styleTags(spec) {
    let byName = Object.create(null);
    for(let prop in spec){
        let tags1 = spec[prop];
        if (!Array.isArray(tags1)) tags1 = [
            tags1
        ];
        for (let part of prop.split(" "))if (part) {
            let pieces = [], mode = Mode1.Normal, rest = part;
            for(let pos = 0;;){
                if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                    mode = Mode1.Inherit;
                    break;
                }
                let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                if (!m) throw new RangeError("Invalid path: " + part);
                pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                pos += m[0].length;
                if (pos == part.length) break;
                let next = part[pos++];
                if (pos == part.length && next == "!") {
                    mode = Mode1.Opaque;
                    break;
                }
                if (next != "/") throw new RangeError("Invalid path: " + part);
                rest = part.slice(pos);
            }
            let last = pieces.length - 1, inner = pieces[last];
            if (!inner) throw new RangeError("Invalid path: " + part);
            let rule = new Rule(tags1, mode, last > 0 ? pieces.slice(0, last) : null);
            byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new NodeProp();
const highlightStyle = Facet.define({
    combine (stylings) {
        return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
    }
});
const fallbackHighlightStyle = Facet.define({
    combine (values17) {
        return values17.length ? values17[0].match : null;
    }
});
function getHighlightStyle(state145) {
    return state145.facet(highlightStyle) || state145.facet(fallbackHighlightStyle);
}
var Mode1;
(function(Mode3) {
    Mode3[Mode3["Opaque"] = 0] = "Opaque";
    Mode3[Mode3["Inherit"] = 1] = "Inherit";
    Mode3[Mode3["Normal"] = 2] = "Normal";
})(Mode1 || (Mode1 = {}));
class Rule {
    tags;
    mode;
    context;
    next;
    constructor(tags2, mode, context, next){
        this.tags = tags2;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() {
        return this.context ? this.context.length : 0;
    }
}
class HighlightStyle {
    extension;
    fallback;
    module;
    map = Object.create(null);
    scope;
    all;
    constructor(spec1, options){
        let modSpec;
        function def(spec) {
            let cls = StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;
        for (let style of spec1){
            let cls = (style.class || def(Object.assign({}, style, {
                tag: null
            }))) + (this.all ? " " + this.all : "");
            let tags3 = style.tag;
            if (!Array.isArray(tags3)) this.map[tags3.id] = cls;
            else for (let tag of tags3)this.map[tag.id] = cls;
        }
        this.module = modSpec ? new StyleModule(modSpec, null) : null;
        this.scope = options.scope || null;
        this.match = this.match.bind(this);
        let ext = [
            treeHighlighter
        ];
        if (this.module) ext.push(EditorView.styleModule.of(this.module));
        this.extension = ext.concat(options.themeType == null ? highlightStyle.of(this) : highlightStyle.computeN([
            EditorView.darkTheme
        ], (state146)=>{
            return state146.facet(EditorView.darkTheme) == (options.themeType == "dark") ? [
                this
            ] : [];
        }));
        this.fallback = ext.concat(fallbackHighlightStyle.of(this));
    }
    match(tag, scope) {
        if (this.scope && scope != this.scope) return null;
        for (let t3 of tag.set){
            let match = this.map[t3.id];
            if (match !== undefined) {
                if (t3 != tag) this.map[tag.id] = match;
                return match;
            }
        }
        return this.map[tag.id] = this.all;
    }
    static combinedMatch(styles) {
        if (styles.length == 1) return styles[0].match;
        let cache = styles.some((s)=>s.scope
        ) ? undefined : Object.create(null);
        return (tag, scope)=>{
            let cached = cache && cache[tag.id];
            if (cached !== undefined) return cached;
            let result = null;
            for (let style of styles){
                let value = style.match(tag, scope);
                if (value) result = result ? result + " " + value : value;
            }
            if (cache) cache[tag.id] = result;
            return result;
        };
    }
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
    static get(state147, tag, scope) {
        let style = getHighlightStyle(state147);
        return style && style(tag, scope || NodeType.none);
    }
}
class TreeHighlighter {
    decorations;
    tree;
    markCache = Object.create(null);
    constructor(view){
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
    }
    update(update) {
        let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);
        let styleChange = style != update.startState.facet(highlightStyle);
        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
            this.decorations = this.decorations.map(update.changes);
        } else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, style);
        }
    }
    buildDeco(view, match) {
        if (!match || !this.tree.length) return Decoration.none;
        let builder = new RangeSetBuilder();
        for (let { from: from1 , to: to1  } of view.visibleRanges){
            highlightTreeRange(this.tree, from1, to1, match, (from, to, style)=>{
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({
                    class: style
                })));
            });
        }
        return builder.finish();
    }
}
const treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v)=>v.decorations
}));
const nodeStack = [
    ""
];
class HighlightBuilder {
    at;
    style;
    span;
    class = "";
    constructor(at, style, span12){
        this.at = at;
        this.style = style;
        this.span = span12;
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at) this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class) this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, depth5, scope) {
        let { type , from: start , to: end  } = cursor;
        if (start >= to || end <= from) return;
        nodeStack[depth5] = type.name;
        if (type.isTop) scope = type;
        let cls = inheritedClass;
        let rule = type.prop(ruleNodeProp), opaque = false;
        while(rule){
            if (!rule.context || matchContext(rule.context, nodeStack, depth5)) {
                for (let tag of rule.tags){
                    let st = this.style(tag, scope);
                    if (st) {
                        if (cls) cls += " ";
                        cls += st;
                        if (rule.mode == Mode1.Inherit) inheritedClass += (inheritedClass ? " " : "") + st;
                        else if (rule.mode == Mode1.Opaque) opaque = true;
                    }
                }
                break;
            }
            rule = rule.next;
        }
        this.startSpan(cursor.from, cls);
        if (opaque) return;
        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let hasChild1 = cursor.firstChild();
            for(let i180 = 0, pos = start;; i180++){
                let next = i180 < mounted.overlay.length ? mounted.overlay[i180] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild1) {
                    while(cursor.from < rangeTo){
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth5 + 1, scope);
                        this.startSpan(Math.min(to, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;
                    }
                }
                if (!next || nextPos > to) break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth5, mounted.tree.type);
                    this.startSpan(pos, cls);
                }
            }
            if (hasChild1) cursor.parent();
        } else if (cursor.firstChild()) {
            do {
                if (cursor.to <= from) continue;
                if (cursor.from >= to) break;
                this.highlightRange(cursor, from, to, inheritedClass, depth5 + 1, scope);
                this.startSpan(Math.min(to, cursor.to), cls);
            }while (cursor.nextSibling())
            cursor.parent();
        }
    }
}
function highlightTreeRange(tree, from, to, style, span13) {
    let builder = new HighlightBuilder(from, style, span13);
    builder.highlightRange(tree.cursor(), from, to, "", 0, tree.type);
    builder.flush(to);
}
function matchContext(context, stack, depth6) {
    if (context.length > depth6 - 1) return false;
    for(let d = depth6 - 1, i181 = context.length - 1; i181 >= 0; i181--, d--){
        let check = context[i181];
        if (check && check != stack[d]) return false;
    }
    return true;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
const tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName: typeName,
    tagName: t(typeName),
    propertyName: propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
};
const defaultHighlightStyle = HighlightStyle.define([
    {
        tag: tags.link,
        textDecoration: "underline"
    },
    {
        tag: tags.heading,
        textDecoration: "underline",
        fontWeight: "bold"
    },
    {
        tag: tags.emphasis,
        fontStyle: "italic"
    },
    {
        tag: tags.strong,
        fontWeight: "bold"
    },
    {
        tag: tags.strikethrough,
        textDecoration: "line-through"
    },
    {
        tag: tags.keyword,
        color: "#708"
    },
    {
        tag: [
            tags.atom,
            tags.bool,
            tags.url,
            tags.contentSeparator,
            tags.labelName
        ],
        color: "#219"
    },
    {
        tag: [
            tags.literal,
            tags.inserted
        ],
        color: "#164"
    },
    {
        tag: [
            tags.string,
            tags.deleted
        ],
        color: "#a11"
    },
    {
        tag: [
            tags.regexp,
            tags.escape,
            tags.special(tags.string)
        ],
        color: "#e40"
    },
    {
        tag: tags.definition(tags.variableName),
        color: "#00f"
    },
    {
        tag: tags.local(tags.variableName),
        color: "#30a"
    },
    {
        tag: [
            tags.typeName,
            tags.namespace
        ],
        color: "#085"
    },
    {
        tag: tags.className,
        color: "#167"
    },
    {
        tag: [
            tags.special(tags.variableName),
            tags.macroName
        ],
        color: "#256"
    },
    {
        tag: tags.definition(tags.propertyName),
        color: "#00c"
    },
    {
        tag: tags.comment,
        color: "#940"
    },
    {
        tag: tags.meta,
        color: "#7a757a"
    },
    {
        tag: tags.invalid,
        color: "#f00"
    }
]);
HighlightStyle.define([
    {
        tag: tags.link,
        class: "cmt-link"
    },
    {
        tag: tags.heading,
        class: "cmt-heading"
    },
    {
        tag: tags.emphasis,
        class: "cmt-emphasis"
    },
    {
        tag: tags.strong,
        class: "cmt-strong"
    },
    {
        tag: tags.keyword,
        class: "cmt-keyword"
    },
    {
        tag: tags.atom,
        class: "cmt-atom"
    },
    {
        tag: tags.bool,
        class: "cmt-bool"
    },
    {
        tag: tags.url,
        class: "cmt-url"
    },
    {
        tag: tags.labelName,
        class: "cmt-labelName"
    },
    {
        tag: tags.inserted,
        class: "cmt-inserted"
    },
    {
        tag: tags.deleted,
        class: "cmt-deleted"
    },
    {
        tag: tags.literal,
        class: "cmt-literal"
    },
    {
        tag: tags.string,
        class: "cmt-string"
    },
    {
        tag: tags.number,
        class: "cmt-number"
    },
    {
        tag: [
            tags.regexp,
            tags.escape,
            tags.special(tags.string)
        ],
        class: "cmt-string2"
    },
    {
        tag: tags.variableName,
        class: "cmt-variableName"
    },
    {
        tag: tags.local(tags.variableName),
        class: "cmt-variableName cmt-local"
    },
    {
        tag: tags.definition(tags.variableName),
        class: "cmt-variableName cmt-definition"
    },
    {
        tag: tags.special(tags.variableName),
        class: "cmt-variableName2"
    },
    {
        tag: tags.definition(tags.propertyName),
        class: "cmt-propertyName cmt-definition"
    },
    {
        tag: tags.typeName,
        class: "cmt-typeName"
    },
    {
        tag: tags.namespace,
        class: "cmt-namespace"
    },
    {
        tag: tags.className,
        class: "cmt-className"
    },
    {
        tag: tags.macroName,
        class: "cmt-macroName"
    },
    {
        tag: tags.propertyName,
        class: "cmt-propertyName"
    },
    {
        tag: tags.operator,
        class: "cmt-operator"
    },
    {
        tag: tags.comment,
        class: "cmt-comment"
    },
    {
        tag: tags.meta,
        class: "cmt-meta"
    },
    {
        tag: tags.invalid,
        class: "cmt-invalid"
    },
    {
        tag: tags.punctuation,
        class: "cmt-punctuation"
    }
]);
class SelectedDiagnostic {
    from;
    to;
    diagnostic;
    constructor(from, to, diagnostic){
        this.from = from;
        this.to = to;
        this.diagnostic = diagnostic;
    }
}
class LintState {
    diagnostics;
    panel;
    selected;
    constructor(diagnostics, panel, selected){
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
    }
    static init(diagnostics, panel, state148) {
        let ranges = Decoration.set(diagnostics.map((d)=>{
            return d.from == d.to || d.from == d.to - 1 && state148.doc.lineAt(d.from).to == d.from ? Decoration.widget({
                widget: new DiagnosticWidget(d),
                diagnostic: d
            }).range(d.from) : Decoration.mark({
                attributes: {
                    class: "cm-lintRange cm-lintRange-" + d.severity
                },
                diagnostic: d
            }).range(d.from, d.to);
        }), true);
        return new LintState(ranges, panel, findDiagnostic(ranges));
    }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1000000000, (from, to, { spec  })=>{
        if (diagnostic && spec.diagnostic != diagnostic) return;
        found = new SelectedDiagnostic(from, to, spec.diagnostic);
        return false;
    });
    return found;
}
function maybeEnableLint(state1, effects) {
    return state1.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
        lintState,
        EditorView.decorations.compute([
            lintState
        ], (state149)=>{
            let { selected , panel  } = state149.field(lintState);
            return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
                activeMark.range(selected.from, selected.to)
            ]);
        }),
        hoverTooltip(lintTooltip),
        baseTheme9
    ]));
}
function setDiagnostics(state150, diagnostics) {
    return {
        effects: maybeEnableLint(state150, [
            setDiagnosticsEffect.of(diagnostics)
        ])
    };
}
const setDiagnosticsEffect = StateEffect.define();
const togglePanel1 = StateEffect.define();
const movePanelSelection = StateEffect.define();
const lintState = StateField.define({
    create () {
        return new LintState(Decoration.none, null, null);
    },
    update (value, tr) {
        if (tr.docChanged) {
            let mapped = value.diagnostics.map(tr.changes), selected = null;
            if (value.selected) {
                let selPos = tr.changes.mapPos(value.selected.from, 1);
                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            value = new LintState(mapped, value.panel, selected);
        }
        for (let effect of tr.effects){
            if (effect.is(setDiagnosticsEffect)) {
                value = LintState.init(effect.value, value.panel, tr.state);
            } else if (effect.is(togglePanel1)) {
                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            } else if (effect.is(movePanelSelection)) {
                value = new LintState(value.diagnostics, value.panel, effect.value);
            }
        }
        return value;
    },
    provide: (f)=>[
            showPanel.from(f, (val)=>val.panel
            ),
            EditorView.decorations.from(f, (s)=>s.diagnostics
            )
        ]
});
const activeMark = Decoration.mark({
    class: "cm-lintRange cm-lintRange-active"
});
function lintTooltip(view, pos, side) {
    let { diagnostics  } = view.state.field(lintState);
    let found = [], stackStart = 200000000, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec  })=>{
        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
            found.push(spec.diagnostic);
            stackStart = Math.min(from, stackStart);
            stackEnd = Math.max(to, stackEnd);
        }
    });
    if (!found.length) return null;
    return {
        pos: stackStart,
        end: stackEnd,
        above: view.state.doc.lineAt(stackStart).to < stackEnd,
        create () {
            return {
                dom: diagnosticsTooltip(view, found)
            };
        }
    };
}
function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", {
        class: "cm-tooltip-lint"
    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)
    ));
}
const openLintPanel = (view)=>{
    let field = view.state.field(lintState, false);
    if (!field || !field.panel) view.dispatch({
        effects: maybeEnableLint(view.state, [
            togglePanel1.of(true)
        ])
    });
    let panel = getPanel(view, LintPanel.open);
    if (panel) panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
};
const closeLintPanel = (view)=>{
    let field = view.state.field(lintState, false);
    if (!field || !field.panel) return false;
    view.dispatch({
        effects: togglePanel1.of(false)
    });
    return true;
};
const nextDiagnostic = (view)=>{
    let field = view.state.field(lintState, false);
    if (!field) return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to) return false;
    }
    view.dispatch({
        selection: {
            anchor: next.from,
            head: next.to
        },
        scrollIntoView: true
    });
    return true;
};
const lintKeymap = [
    {
        key: "Mod-Shift-m",
        run: openLintPanel
    },
    {
        key: "F8",
        run: nextDiagnostic
    }
];
const lintPlugin = ViewPlugin.fromClass(class {
    view;
    lintTime;
    timeout = -1;
    set = true;
    constructor(view){
        this.view = view;
        let { delay: delay1  } = view.state.facet(lintSource);
        this.lintTime = Date.now() + delay1;
        this.run = this.run.bind(this);
        this.timeout = setTimeout(this.run, delay1);
    }
    run() {
        let now = Date.now();
        if (now < this.lintTime - 10) {
            setTimeout(this.run, this.lintTime - now);
        } else {
            this.set = false;
            let { state: state151  } = this.view, { sources  } = state151.facet(lintSource);
            Promise.all(sources.map((source)=>Promise.resolve(source(this.view))
            )).then((annotations)=>{
                let all = annotations.reduce((a, b)=>a.concat(b)
                );
                if (this.view.state.doc == state151.doc) this.view.dispatch(setDiagnostics(this.view.state, all));
            }, (error)=>{
                logException(this.view.state, error);
            });
        }
    }
    update(update) {
        let source = update.state.facet(lintSource);
        if (update.docChanged || source != update.startState.facet(lintSource)) {
            this.lintTime = Date.now() + source.delay;
            if (!this.set) {
                this.set = true;
                this.timeout = setTimeout(this.run, source.delay);
            }
        }
    }
    force() {
        if (this.set) {
            this.lintTime = Date.now();
            this.run();
        }
    }
    destroy() {
        clearTimeout(this.timeout);
    }
});
const lintSource = Facet.define({
    combine (input) {
        return {
            sources: input.map((i182)=>i182.source
            ),
            delay: input.length ? Math.max(...input.map((i183)=>i183.delay
            )) : 750
        };
    },
    enables: lintPlugin
});
function assignKeys(actions) {
    let assigned = [];
    if (actions) actions: for (let { name: name23  } of actions){
        for(let i184 = 0; i184 < name23.length; i184++){
            let ch = name23[i184];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase()
            )) {
                assigned.push(ch);
                continue actions;
            }
        }
        assigned.push("");
    }
    return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", {
        class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity
    }, crelt("span", {
        class: "cm-diagnosticText"
    }, diagnostic.message), diagnostic.actions?.map((action, i185)=>{
        let click = (e)=>{
            e.preventDefault();
            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
            if (found) action.apply(view, found.from, found.to);
        };
        let { name: name24  } = action, keyIndex = keys[i185] ? name24.indexOf(keys[i185]) : -1;
        let nameElt = keyIndex < 0 ? name24 : [
            name24.slice(0, keyIndex),
            crelt("u", name24.slice(keyIndex, keyIndex + 1)),
            name24.slice(keyIndex + 1)
        ];
        return crelt("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name24}${keyIndex < 0 ? "" : ` (access key "${keys[i185]})"`}.`
        }, nameElt);
    }), diagnostic.source && crelt("div", {
        class: "cm-diagnosticSource"
    }, diagnostic.source));
}
class DiagnosticWidget extends WidgetType {
    diagnostic;
    constructor(diagnostic){
        super();
        this.diagnostic = diagnostic;
    }
    eq(other) {
        return other.diagnostic == this.diagnostic;
    }
    toDOM() {
        return crelt("span", {
            class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity
        });
    }
}
class PanelItem {
    diagnostic;
    id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    dom;
    constructor(view, diagnostic){
        this.diagnostic = diagnostic;
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
    }
}
class LintPanel {
    view;
    items = [];
    dom;
    list;
    constructor(view){
        this.view = view;
        let onkeydown = (event)=>{
            if (event.keyCode == 27) {
                closeLintPanel(this.view);
                this.view.focus();
            } else if (event.keyCode == 38 || event.keyCode == 33) {
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            } else if (event.keyCode == 40 || event.keyCode == 34) {
                this.moveSelection((this.selectedIndex + 1) % this.items.length);
            } else if (event.keyCode == 36) {
                this.moveSelection(0);
            } else if (event.keyCode == 35) {
                this.moveSelection(this.items.length - 1);
            } else if (event.keyCode == 13) {
                this.view.focus();
            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
                let { diagnostic  } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                for(let i186 = 0; i186 < keys.length; i186++)if (keys[i186].toUpperCase().charCodeAt(0) == event.keyCode) {
                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                    if (found) diagnostic.actions[i186].apply(view, found.from, found.to);
                }
            } else {
                return;
            }
            event.preventDefault();
        };
        let onclick = (event)=>{
            for(let i187 = 0; i187 < this.items.length; i187++){
                if (this.items[i187].dom.contains(event.target)) this.moveSelection(i187);
            }
        };
        this.list = crelt("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
        });
        this.dom = crelt("div", {
            class: "cm-panel-lint"
        }, this.list, crelt("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: ()=>closeLintPanel(this.view)
        }, "×"));
        this.update();
    }
    get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected) return -1;
        for(let i188 = 0; i188 < this.items.length; i188++)if (this.items[i188].diagnostic == selected.diagnostic) return i188;
        return -1;
    }
    update() {
        let { diagnostics , selected  } = this.view.state.field(lintState);
        let i189 = 0, needsSync = false, newSelectedItem = null;
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec  })=>{
            let found = -1, item;
            for(let j = i189; j < this.items.length; j++)if (this.items[j].diagnostic == spec.diagnostic) {
                found = j;
                break;
            }
            if (found < 0) {
                item = new PanelItem(this.view, spec.diagnostic);
                this.items.splice(i189, 0, item);
                needsSync = true;
            } else {
                item = this.items[found];
                if (found > i189) {
                    this.items.splice(i189, found - i189);
                    needsSync = true;
                }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
                if (!item.dom.hasAttribute("aria-selected")) {
                    item.dom.setAttribute("aria-selected", "true");
                    newSelectedItem = item;
                }
            } else if (item.dom.hasAttribute("aria-selected")) {
                item.dom.removeAttribute("aria-selected");
            }
            i189++;
        });
        while(i189 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){
            needsSync = true;
            this.items.pop();
        }
        if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
                from: -1,
                to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
        }
        if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
                key: this,
                read: ()=>({
                        sel: newSelectedItem.dom.getBoundingClientRect(),
                        panel: this.list.getBoundingClientRect()
                    })
                ,
                write: ({ sel , panel  })=>{
                    if (sel.top < panel.top) this.list.scrollTop -= panel.top - sel.top;
                    else if (sel.bottom > panel.bottom) this.list.scrollTop += sel.bottom - panel.bottom;
                }
            });
        } else if (this.selectedIndex < 0) {
            this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync) this.sync();
    }
    sync() {
        let domPos = this.list.firstChild;
        function rm2() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
        }
        for (let item of this.items){
            if (item.dom.parentNode == this.list) {
                while(domPos != item.dom)rm2();
                domPos = item.dom.nextSibling;
            } else {
                this.list.insertBefore(item.dom, domPos);
            }
        }
        while(domPos)rm2();
    }
    moveSelection(selectedIndex) {
        if (this.selectedIndex < 0) return;
        let field = this.view.state.field(lintState);
        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection) return;
        this.view.dispatch({
            selection: {
                anchor: selection.from,
                head: selection.to
            },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
        });
    }
    static open(view) {
        return new LintPanel(view);
    }
}
function svg(content12, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content12)}</svg>')`;
}
function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const baseTheme9 = EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
        borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
        borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
        borderLeft: "5px solid #999"
    },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: 0.7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
        backgroundImage: underline("#d11")
    },
    ".cm-lintRange-warning": {
        backgroundImage: underline("orange")
    },
    ".cm-lintRange-info": {
        backgroundImage: underline("#999")
    },
    ".cm-lintRange-active": {
        backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
    },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": {
            borderBottomColor: "orange"
        }
    },
    ".cm-lintPoint-info": {
        "&:after": {
            borderBottomColor: "#999"
        }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": {
                    textDecoration: "underline"
                }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": {
                textDecoration: "none"
            },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    }
});
class LintGutterMarker extends GutterMarker {
    diagnostics;
    severity;
    constructor(diagnostics){
        super();
        this.diagnostics = diagnostics;
        this.severity = diagnostics.reduce((max, d)=>{
            let s = d.severity;
            return s == "error" || s == "warning" && max == "info" ? s : max;
        }, "info");
    }
    toDOM(view) {
        let elt1 = document.createElement("div");
        elt1.className = "cm-lint-marker cm-lint-marker-" + this.severity;
        elt1.onmouseover = ()=>gutterMarkerMouseOver(view, elt1, this.diagnostics)
        ;
        return elt1;
    }
}
var Hover1;
(function(Hover3) {
    Hover3[Hover3["Time"] = 300] = "Time";
    Hover3[Hover3["Margin"] = 10] = "Margin";
})(Hover1 || (Hover1 = {}));
function trackHoverOn(view, marker) {
    let mousemove = (event)=>{
        let rect = marker.getBoundingClientRect();
        if (event.clientX > rect.left - Hover1.Margin && event.clientX < rect.right + Hover1.Margin && event.clientY > rect.top - Hover1.Margin && event.clientY < rect.bottom + Hover1.Margin) return;
        for(let target = event.target; target; target = target.parentNode){
            if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint")) return;
        }
        window.removeEventListener("mousemove", mousemove);
        if (view.state.field(lintGutterTooltip)) view.dispatch({
            effects: setLintGutterTooltip.of(null)
        });
    };
    window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
    function hovered() {
        let line = view.visualLineAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
        const linePos = view.coordsAtPos(line.from);
        if (linePos) {
            view.dispatch({
                effects: setLintGutterTooltip.of({
                    pos: line.from,
                    above: false,
                    create () {
                        return {
                            dom: diagnosticsTooltip(view, diagnostics),
                            getCoords: ()=>marker.getBoundingClientRect()
                        };
                    }
                })
            });
        }
        marker.onmouseout = marker.onmousemove = null;
        trackHoverOn(view, marker);
    }
    let { hoverTime  } = view.state.facet(lintGutterConfig);
    let hoverTimeout = setTimeout(hovered, hoverTime);
    marker.onmouseout = ()=>{
        clearTimeout(hoverTimeout);
        marker.onmouseout = marker.onmousemove = null;
    };
    marker.onmousemove = ()=>{
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(hovered, hoverTime);
    };
}
function markersForDiagnostics(doc42, diagnostics) {
    let byLine = Object.create(null);
    for (let diagnostic of diagnostics){
        let line = doc42.lineAt(diagnostic.from);
        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
    }
    let markers = [];
    for(let line in byLine){
        markers.push(new LintGutterMarker(byLine[line]).range(+line));
    }
    return RangeSet.of(markers, true);
}
gutter({
    class: "cm-gutter-lint",
    markers: (view)=>view.state.field(lintGutterMarkers)
});
const lintGutterMarkers = StateField.define({
    create () {
        return RangeSet.empty;
    },
    update (markers, tr) {
        markers = markers.map(tr.changes);
        for (let effect of tr.effects)if (effect.is(setDiagnosticsEffect)) {
            markers = markersForDiagnostics(tr.state.doc, effect.value);
        }
        return markers;
    }
});
const setLintGutterTooltip = StateEffect.define();
const lintGutterTooltip = StateField.define({
    create () {
        return null;
    },
    update (tooltip, tr) {
        if (tooltip && tr.docChanged) tooltip = {
            ...tooltip,
            pos: tr.changes.mapPos(tooltip.pos)
        };
        return tr.effects.reduce((t17, e)=>e.is(setLintGutterTooltip) ? e.value : t17
        , tooltip);
    },
    provide: (field)=>showTooltip.from(field)
});
EditorView.baseTheme({
    ".cm-gutter-lint": {
        width: "1.4em",
        "& .cm-gutterElement": {
            padding: ".2em"
        }
    },
    ".cm-lint-marker": {
        width: "1em",
        height: "1em"
    },
    ".cm-lint-marker-info": {
        content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
    },
    ".cm-lint-marker-warning": {
        content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
    },
    ".cm-lint-marker-error:before": {
        content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
    }
});
const lintGutterConfig = Facet.define({
    combine (configs) {
        return combineConfig(configs, {
            hoverTime: Hover1.Time
        });
    }
});
const basicSetup = [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    defaultHighlightStyle.fallback,
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
        ...closeBracketsKeymap,
        ...defaultKeymap,
        ...searchKeymap,
        ...historyKeymap,
        ...foldKeymap,
        ...commentKeymap,
        ...completionKeymap,
        ...lintKeymap
    ])
];
class CompositeBlock {
    type;
    value;
    from;
    hash;
    end;
    children;
    positions;
    static create(type, value, from, parentHash, end) {
        let hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;
        return new CompositeBlock(type, value, from, hash, end, [], []);
    }
    hashProp;
    constructor(type, value, from, hash, end, children, positions){
        this.type = type;
        this.value = value;
        this.from = from;
        this.hash = hash;
        this.end = end;
        this.children = children;
        this.positions = positions;
        this.hashProp = [
            [
                NodeProp.contextHash,
                hash
            ]
        ];
    }
    addChild(child, pos) {
        if (child.prop(NodeProp.contextHash) != this.hash) child = new Tree1(child.type, child.children, child.positions, child.length, this.hashProp);
        this.children.push(child);
        this.positions.push(pos);
    }
    toTree(nodeSet, end = this.end) {
        let last = this.children.length - 1;
        if (last >= 0) end = Math.max(end, this.positions[last] + this.children[last].length + this.from);
        let tree = new Tree1(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
            makeTree: (children, positions, length)=>new Tree1(NodeType.none, children, positions, length, this.hashProp)
        });
        return tree;
    }
}
var Type;
(function(Type1) {
    Type1[Type1["Document"] = 1] = "Document";
    Type1[Type1["CodeBlock"] = 2] = "CodeBlock";
    Type1[Type1["FencedCode"] = 3] = "FencedCode";
    Type1[Type1["Blockquote"] = 4] = "Blockquote";
    Type1[Type1["HorizontalRule"] = 5] = "HorizontalRule";
    Type1[Type1["BulletList"] = 6] = "BulletList";
    Type1[Type1["OrderedList"] = 7] = "OrderedList";
    Type1[Type1["ListItem"] = 8] = "ListItem";
    Type1[Type1["ATXHeading1"] = 9] = "ATXHeading1";
    Type1[Type1["ATXHeading2"] = 10] = "ATXHeading2";
    Type1[Type1["ATXHeading3"] = 11] = "ATXHeading3";
    Type1[Type1["ATXHeading4"] = 12] = "ATXHeading4";
    Type1[Type1["ATXHeading5"] = 13] = "ATXHeading5";
    Type1[Type1["ATXHeading6"] = 14] = "ATXHeading6";
    Type1[Type1["SetextHeading1"] = 15] = "SetextHeading1";
    Type1[Type1["SetextHeading2"] = 16] = "SetextHeading2";
    Type1[Type1["HTMLBlock"] = 17] = "HTMLBlock";
    Type1[Type1["LinkReference"] = 18] = "LinkReference";
    Type1[Type1["Paragraph"] = 19] = "Paragraph";
    Type1[Type1["CommentBlock"] = 20] = "CommentBlock";
    Type1[Type1["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
    Type1[Type1["Escape"] = 22] = "Escape";
    Type1[Type1["Entity"] = 23] = "Entity";
    Type1[Type1["HardBreak"] = 24] = "HardBreak";
    Type1[Type1["Emphasis"] = 25] = "Emphasis";
    Type1[Type1["StrongEmphasis"] = 26] = "StrongEmphasis";
    Type1[Type1["Link"] = 27] = "Link";
    Type1[Type1["Image"] = 28] = "Image";
    Type1[Type1["InlineCode"] = 29] = "InlineCode";
    Type1[Type1["HTMLTag"] = 30] = "HTMLTag";
    Type1[Type1["Comment"] = 31] = "Comment";
    Type1[Type1["ProcessingInstruction"] = 32] = "ProcessingInstruction";
    Type1[Type1["URL"] = 33] = "URL";
    Type1[Type1["HeaderMark"] = 34] = "HeaderMark";
    Type1[Type1["QuoteMark"] = 35] = "QuoteMark";
    Type1[Type1["ListMark"] = 36] = "ListMark";
    Type1[Type1["LinkMark"] = 37] = "LinkMark";
    Type1[Type1["EmphasisMark"] = 38] = "EmphasisMark";
    Type1[Type1["CodeMark"] = 39] = "CodeMark";
    Type1[Type1["CodeText"] = 40] = "CodeText";
    Type1[Type1["CodeInfo"] = 41] = "CodeInfo";
    Type1[Type1["LinkTitle"] = 42] = "LinkTitle";
    Type1[Type1["LinkLabel"] = 43] = "LinkLabel";
})(Type || (Type = {}));
class LeafBlock {
    start;
    content;
    marks = [];
    parsers = [];
    constructor(start, content13){
        this.start = start;
        this.content = content13;
    }
}
class Line1 {
    text = "";
    baseIndent = 0;
    basePos = 0;
    depth = 0;
    markers = [];
    pos = 0;
    indent = 0;
    next = -1;
    forward() {
        if (this.basePos > this.pos) this.forwardInner();
    }
    forwardInner() {
        let newPos = this.skipSpace(this.basePos);
        this.indent = this.countIndent(newPos, this.pos, this.indent);
        this.pos = newPos;
        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
    }
    skipSpace(from) {
        return skipSpace(this.text, from);
    }
    reset(text) {
        this.text = text;
        this.baseIndent = this.basePos = this.pos = this.indent = 0;
        this.forwardInner();
        this.depth = 1;
        while(this.markers.length)this.markers.pop();
    }
    moveBase(to) {
        this.basePos = to;
        this.baseIndent = this.countIndent(to, this.pos, this.indent);
    }
    moveBaseColumn(indent) {
        this.baseIndent = indent;
        this.basePos = this.findColumn(indent);
    }
    addMarker(elt1) {
        this.markers.push(elt1);
    }
    countIndent(to, from = 0, indent = 0) {
        for(let i1 = from; i1 < to; i1++)indent += this.text.charCodeAt(i1) == 9 ? 4 - indent % 4 : 1;
        return indent;
    }
    findColumn(goal) {
        let i211 = 0;
        for(let indent = 0; i211 < this.text.length && indent < goal; i211++)indent += this.text.charCodeAt(i211) == 9 ? 4 - indent % 4 : 1;
        return i211;
    }
    scrub() {
        if (!this.baseIndent) return this.text;
        let result = "";
        for(let i3 = 0; i3 < this.basePos; i3++)result += " ";
        return result + this.text.slice(this.basePos);
    }
}
function skipForList(bl, cx, line) {
    if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent) return true;
    if (line.indent >= line.baseIndent + 4) return false;
    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
    return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
const DefaultSkipMarkup = {
    [Type.Blockquote] (bl, cx, line) {
        if (line.next != 62) return false;
        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
        bl.end = cx.lineStart + line.text.length;
        return true;
    },
    [Type.ListItem] (bl, _cx, line) {
        if (line.indent < line.baseIndent + bl.value && line.next > -1) return false;
        line.moveBaseColumn(line.baseIndent + bl.value);
        return true;
    },
    [Type.OrderedList]: skipForList,
    [Type.BulletList]: skipForList,
    [Type.Document] () {
        return true;
    }
};
function space(ch) {
    return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line, i4 = 0) {
    while(i4 < line.length && space(line.charCodeAt(i4)))i4++;
    return i4;
}
function skipSpaceBack(line, i5, to) {
    while(i5 > to && space(line.charCodeAt(i5 - 1)))i5--;
    return i5;
}
function isFencedCode(line) {
    if (line.next != 96 && line.next != 126) return -1;
    let pos = line.pos + 1;
    while(pos < line.text.length && line.text.charCodeAt(pos) == line.next)pos++;
    if (pos < line.pos + 3) return -1;
    if (line.next == 96) {
        for(let i6 = pos; i6 < line.text.length; i6++)if (line.text.charCodeAt(i6) == 96) return -1;
    }
    return pos;
}
function isBlockquote(line) {
    return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
    if (line.next != 42 && line.next != 45 && line.next != 95) return -1;
    let count = 1;
    for(let pos = line.pos + 1; pos < line.text.length; pos++){
        let ch = line.text.charCodeAt(pos);
        if (ch == line.next) count++;
        else if (!space(ch)) return -1;
    }
    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length) return -1;
    return count < 3 ? -1 : 1;
}
function inList(cx, type) {
    for(let i7 = cx.stack.length - 1; i7 >= 0; i7--)if (cx.stack[i7].type == type) return true;
    return false;
}
function isBulletList(line, cx, breaking) {
    return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
    let pos = line.pos, next = line.next;
    for(;;){
        if (next >= 48 && next <= 57) pos++;
        else break;
        if (pos == line.text.length) return -1;
        next = line.text.charCodeAt(pos);
    }
    if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49)) return -1;
    return pos + 1 - line.pos;
}
function isAtxHeading(line) {
    if (line.next != 35) return -1;
    let pos = line.pos + 1;
    while(pos < line.text.length && line.text.charCodeAt(pos) == 35)pos++;
    if (pos < line.text.length && line.text.charCodeAt(pos) != 32) return -1;
    let size = pos - line.pos;
    return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
    if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4) return -1;
    let pos = line.pos + 1;
    while(pos < line.text.length && line.text.charCodeAt(pos) == line.next)pos++;
    let end = pos;
    while(pos < line.text.length && space(line.text.charCodeAt(pos)))pos++;
    return pos == line.text.length ? end : -1;
}
const EmptyLine = /^[ \t]*$/, CommentEnd = /-->/, ProcessingEnd = /\?>/;
const HTMLBlockStyle = [
    [
        /^<(?:script|pre|style)(?:\s|>|$)/i,
        /<\/(?:script|pre|style)>/i
    ],
    [
        /^\s*<!--/,
        CommentEnd
    ],
    [
        /^\s*<\?/,
        ProcessingEnd
    ],
    [
        /^\s*<![A-Z]/,
        />/
    ],
    [
        /^\s*<!\[CDATA\[/,
        /\]\]>/
    ],
    [
        /^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,
        EmptyLine
    ],
    [
        /^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i,
        EmptyLine
    ]
];
function isHTMLBlock(line, _cx, breaking) {
    if (line.next != 60) return -1;
    let rest = line.text.slice(line.pos);
    for(let i8 = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i8 < e; i8++)if (HTMLBlockStyle[i8][0].test(rest)) return i8;
    return -1;
}
function getListIndent(line, pos) {
    let indentAfter = line.countIndent(pos, line.pos, line.indent);
    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks, from, to) {
    let last = marks.length - 1;
    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText) marks[last].to = to;
    else marks.push(elt(Type.CodeText, from, to));
}
const DefaultBlockParsers = {
    LinkReference: undefined,
    IndentedCode (cx, line) {
        let base19 = line.baseIndent + 4;
        if (line.indent < base19) return false;
        let start = line.findColumn(base19);
        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
        let marks = [], pendingMarks = [];
        addCodeText(marks, from, to);
        while(cx.nextLine() && line.depth >= cx.stack.length){
            if (line.pos == line.text.length) {
                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)pendingMarks.push(m);
            } else if (line.indent < base19) {
                break;
            } else {
                if (pendingMarks.length) {
                    for (let m of pendingMarks){
                        if (m.type == Type.CodeText) addCodeText(marks, m.from, m.to);
                        else marks.push(m);
                    }
                    pendingMarks = [];
                }
                addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)marks.push(m);
                to = cx.lineStart + line.text.length;
                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
                if (codeStart < to) addCodeText(marks, codeStart, to);
            }
        }
        if (pendingMarks.length) {
            pendingMarks = pendingMarks.filter((m)=>m.type != Type.CodeText
            );
            if (pendingMarks.length) line.markers = pendingMarks.concat(line.markers);
        }
        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);
        return true;
    },
    FencedCode (cx, line) {
        let fenceEnd = isFencedCode(line);
        if (fenceEnd < 0) return false;
        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
        let marks = [
            elt(Type.CodeMark, from, from + len)
        ];
        if (infoFrom < infoTo) marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
        for(let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false){
            let i9 = line.pos;
            if (line.indent - line.baseIndent < 4) while(i9 < line.text.length && line.text.charCodeAt(i9) == ch)i9++;
            if (i9 - line.pos >= len && line.skipSpace(i9) == line.text.length) {
                for (let m of line.markers)marks.push(m);
                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i9));
                cx.nextLine();
                break;
            } else {
                if (!first) addCodeText(marks, cx.lineStart - 1, cx.lineStart);
                for (let m of line.markers)marks.push(m);
                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
                if (textStart < textEnd) addCodeText(marks, textStart, textEnd);
            }
        }
        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
        return true;
    },
    Blockquote (cx, line) {
        let size = isBlockquote(line);
        if (size < 0) return false;
        cx.startContext(Type.Blockquote, line.pos);
        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
        line.moveBase(line.pos + size);
        return null;
    },
    HorizontalRule (cx, line) {
        if (isHorizontalRule(line, cx, false) < 0) return false;
        let from = cx.lineStart + line.pos;
        cx.nextLine();
        cx.addNode(Type.HorizontalRule, from);
        return true;
    },
    BulletList (cx, line) {
        let size = isBulletList(line, cx, false);
        if (size < 0) return false;
        if (cx.block.type != Type.BulletList) cx.startContext(Type.BulletList, line.basePos, line.next);
        let newBase = getListIndent(line, line.pos + 1);
        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
    },
    OrderedList (cx, line) {
        let size = isOrderedList(line, cx, false);
        if (size < 0) return false;
        if (cx.block.type != Type.OrderedList) cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
        let newBase = getListIndent(line, line.pos + size);
        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
    },
    ATXHeading (cx, line) {
        let size = isAtxHeading(line);
        if (size < 0) return false;
        let off = line.pos, from = cx.lineStart + off;
        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
        while(after > off && line.text.charCodeAt(after - 1) == line.next)after--;
        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1))) after = line.text.length;
        let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
        if (after < line.text.length) buf.write(Type.HeaderMark, after - off, endOfSpace - off);
        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
        cx.nextLine();
        cx.addNode(node, from);
        return true;
    },
    HTMLBlock (cx, line) {
        let type = isHTMLBlock(line, cx, false);
        if (type < 0) return false;
        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
        let marks = [], trailing = end != EmptyLine;
        while(!end.test(line.text) && cx.nextLine()){
            if (line.depth < cx.stack.length) {
                trailing = false;
                break;
            }
            for (let m of line.markers)marks.push(m);
        }
        if (trailing) cx.nextLine();
        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
        let to = cx.prevLineEnd();
        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);
        return true;
    },
    SetextHeading: undefined
};
var RefStage;
(function(RefStage1) {
    RefStage1[RefStage1["Failed"] = -1] = "Failed";
    RefStage1[RefStage1["Start"] = 0] = "Start";
    RefStage1[RefStage1["Label"] = 1] = "Label";
    RefStage1[RefStage1["Link"] = 2] = "Link";
    RefStage1[RefStage1["Title"] = 3] = "Title";
})(RefStage || (RefStage = {}));
class LinkReferenceParser {
    stage = RefStage.Start;
    elts = [];
    pos = 0;
    start;
    constructor(leaf){
        this.start = leaf.start;
        this.advance(leaf.content);
    }
    nextLine(cx, line, leaf) {
        if (this.stage == RefStage.Failed) return false;
        let content14 = leaf.content + "\n" + line.scrub();
        let finish2 = this.advance(content14);
        if (finish2 > -1 && finish2 < content14.length) return this.complete(cx, leaf, finish2);
        return false;
    }
    finish(cx, leaf) {
        if ((this.stage == RefStage.Link || this.stage == RefStage.Title) && skipSpace(leaf.content, this.pos) == leaf.content.length) return this.complete(cx, leaf, leaf.content.length);
        return false;
    }
    complete(cx, leaf, len) {
        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
        return true;
    }
    nextStage(elt2) {
        if (elt2) {
            this.pos = elt2.to - this.start;
            this.elts.push(elt2);
            this.stage++;
            return true;
        }
        if (elt2 === false) this.stage = RefStage.Failed;
        return false;
    }
    advance(content15) {
        for(;;){
            if (this.stage == RefStage.Failed) {
                return -1;
            } else if (this.stage == RefStage.Start) {
                if (!this.nextStage(parseLinkLabel(content15, this.pos, this.start, true))) return -1;
                if (content15.charCodeAt(this.pos) != 58) return this.stage = RefStage.Failed;
                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
                this.pos++;
            } else if (this.stage == RefStage.Label) {
                if (!this.nextStage(parseURL(content15, skipSpace(content15, this.pos), this.start))) return -1;
            } else if (this.stage == RefStage.Link) {
                let skip = skipSpace(content15, this.pos), end = 0;
                if (skip > this.pos) {
                    let title = parseLinkTitle(content15, skip, this.start);
                    if (title) {
                        let titleEnd = lineEnd(content15, title.to - this.start);
                        if (titleEnd > 0) {
                            this.nextStage(title);
                            end = titleEnd;
                        }
                    }
                }
                if (!end) end = lineEnd(content15, this.pos);
                return end > 0 && end < content15.length ? end : -1;
            } else {
                return lineEnd(content15, this.pos);
            }
        }
    }
}
function lineEnd(text, pos) {
    for(; pos < text.length; pos++){
        let next = text.charCodeAt(pos);
        if (next == 10) break;
        if (!space(next)) return -1;
    }
    return pos;
}
class SetextHeadingParser {
    nextLine(cx, line, leaf) {
        let underline1 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
        let next = line.next;
        if (underline1 < 0) return false;
        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline1);
        cx.nextLine();
        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
            ...cx.parser.parseInline(leaf.content, leaf.start),
            underlineMark
        ]));
        return true;
    }
    finish() {
        return false;
    }
}
const DefaultLeafBlocks = {
    LinkReference (_, leaf) {
        return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
    },
    SetextHeading () {
        return new SetextHeadingParser;
    }
};
const DefaultEndLeaf = [
    (_, line)=>isAtxHeading(line) >= 0
    ,
    (_, line)=>isFencedCode(line) >= 0
    ,
    (_, line)=>isBlockquote(line) >= 0
    ,
    (p19, line)=>isBulletList(line, p19, true) >= 0
    ,
    (p20, line)=>isOrderedList(line, p20, true) >= 0
    ,
    (p21, line)=>isHorizontalRule(line, p21, true) >= 0
    ,
    (p22, line)=>isHTMLBlock(line, p22, true) >= 0
];
class BlockContext {
    parser;
    input;
    ranges;
    block;
    stack;
    line = new Line1();
    atEnd = false;
    fragments;
    to;
    dontInject = new Set;
    stoppedAt = null;
    lineStart;
    absoluteLineStart;
    rangeI = 0;
    absoluteLineEnd;
    constructor(parser1, input, fragments, ranges){
        this.parser = parser1;
        this.input = input;
        this.ranges = ranges;
        this.to = ranges[ranges.length - 1].to;
        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
        this.stack = [
            this.block
        ];
        this.fragments = fragments.length ? new FragmentCursor1(fragments, input) : null;
        this.readLine();
    }
    get parsedPos() {
        return this.absoluteLineStart;
    }
    advance() {
        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish();
        let { line  } = this;
        for(;;){
            while(line.depth < this.stack.length)this.finishContext();
            for (let mark of line.markers)this.addNode(mark.type, mark.from, mark.to);
            if (line.pos < line.text.length) break;
            if (!this.nextLine()) return this.finish();
        }
        if (this.fragments && this.reuseFragment(line.basePos)) return null;
        start: for(;;){
            for (let type of this.parser.blockParsers)if (type) {
                let result = type(this, line);
                if (result != false) {
                    if (result == true) return null;
                    line.forward();
                    continue start;
                }
            }
            break;
        }
        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
        for (let parse7 of this.parser.leafBlockParsers)if (parse7) {
            let parser2 = parse7(this, leaf);
            if (parser2) leaf.parsers.push(parser2);
        }
        lines: while(this.nextLine()){
            if (line.pos == line.text.length) break;
            if (line.indent < line.baseIndent + 4) {
                for (let stop of this.parser.endLeafBlock)if (stop(this, line)) break lines;
            }
            for (let parser3 of leaf.parsers)if (parser3.nextLine(this, line, leaf)) return null;
            leaf.content += "\n" + line.scrub();
            for (let m of line.markers)leaf.marks.push(m);
        }
        this.finishLeaf(leaf);
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    reuseFragment(start) {
        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return false;
        let taken = this.fragments.takeNodes(this);
        if (!taken) return false;
        let withoutGaps = taken, end = this.absoluteLineStart + taken;
        for(let i10 = 1; i10 < this.ranges.length; i10++){
            let gapFrom = this.ranges[i10 - 1].to, gapTo = this.ranges[i10].from;
            if (gapFrom >= this.lineStart && gapTo < end) withoutGaps -= gapTo - gapFrom;
        }
        this.lineStart += withoutGaps;
        this.absoluteLineStart += taken;
        this.moveRangeI();
        if (this.absoluteLineStart < this.to) {
            this.lineStart++;
            this.absoluteLineStart++;
            this.readLine();
        } else {
            this.atEnd = true;
            this.readLine();
        }
        return true;
    }
    get depth() {
        return this.stack.length;
    }
    parentType(depth7 = this.depth - 1) {
        return this.parser.nodeSet.types[this.stack[depth7].type];
    }
    nextLine() {
        this.lineStart += this.line.text.length;
        if (this.absoluteLineEnd >= this.to) {
            this.absoluteLineStart = this.absoluteLineEnd;
            this.atEnd = true;
            this.readLine();
            return false;
        } else {
            this.lineStart++;
            this.absoluteLineStart = this.absoluteLineEnd + 1;
            this.moveRangeI();
            this.readLine();
            return true;
        }
    }
    moveRangeI() {
        while(this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to)this.rangeI++;
    }
    readLine() {
        let { line  } = this, text, end = this.absoluteLineStart;
        if (this.atEnd) {
            text = "";
        } else {
            text = this.lineChunkAt(end);
            end += text.length;
            if (this.ranges.length > 1) {
                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
                while(this.ranges[rangeI].to < end){
                    rangeI++;
                    let nextFrom = this.ranges[rangeI].from;
                    let after = this.lineChunkAt(nextFrom);
                    end = nextFrom + after.length;
                    text = text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
                    textOffset = end - text.length;
                }
            }
        }
        this.absoluteLineEnd = end;
        line.reset(text);
        for(; line.depth < this.stack.length; line.depth++){
            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
            if (!handler) throw new Error("Unhandled block context " + Type[cx.type]);
            if (!handler(cx, this, line)) break;
            line.forward();
        }
    }
    lineChunkAt(pos) {
        let next = this.input.chunk(pos), text;
        if (!this.input.lineChunks) {
            let eol = next.indexOf("\n");
            text = eol < 0 ? next : next.slice(0, eol);
        } else {
            text = next == "\n" ? "" : next;
        }
        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
    }
    prevLineEnd() {
        return this.atEnd ? this.lineStart : this.lineStart - 1;
    }
    startContext(type, start, value = 0) {
        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
        this.stack.push(this.block);
    }
    startComposite(type, start, value = 0) {
        this.startContext(this.parser.getNodeType(type), start, value);
    }
    addNode(block, from, to) {
        if (typeof block == "number") block = new Tree1(this.parser.nodeSet.types[block], none4, none4, (to ?? this.prevLineEnd()) - from);
        this.block.addChild(block, from - this.block.from);
    }
    addElement(elt3) {
        this.block.addChild(elt3.toTree(this.parser.nodeSet), elt3.from - this.block.from);
    }
    addLeafElement(leaf, elt4) {
        this.addNode(this.buffer.writeElements(injectMarks(elt4.children, leaf.marks), -elt4.from).finish(elt4.type, elt4.to - elt4.from), elt4.from);
    }
    finishContext() {
        let cx = this.stack.pop();
        let top35 = this.stack[this.stack.length - 1];
        top35.addChild(cx.toTree(this.parser.nodeSet), cx.from - top35.from);
        this.block = top35;
    }
    finish() {
        while(this.stack.length > 1)this.finishContext();
        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
    }
    addGaps(tree) {
        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;
    }
    finishLeaf(leaf) {
        for (let parser4 of leaf.parsers)if (parser4.finish(this, leaf)) return;
        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
        this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
    }
    elt(type, from, to, children) {
        if (typeof type == "string") return elt(this.parser.getNodeType(type), from, to, children);
        return new TreeElement(type, from);
    }
    get buffer() {
        return new Buffer(this.parser.nodeSet);
    }
}
function injectGaps(ranges, rangeI, tree, offset, dont) {
    if (dont.has(tree.tree)) return tree.tree;
    let rangeEnd1 = ranges[rangeI].to;
    let children = [], positions = [], start = tree.from + offset;
    function movePastNext(upto, inclusive) {
        while(inclusive ? upto >= rangeEnd1 : upto > rangeEnd1){
            let size = ranges[rangeI + 1].from - rangeEnd1;
            offset += size;
            upto += size;
            rangeI++;
            rangeEnd1 = ranges[rangeI].to;
        }
    }
    for(let ch = tree.firstChild; ch; ch = ch.nextSibling){
        movePastNext(ch.from + offset, true);
        let from = ch.from + offset, node;
        if (ch.to + offset > rangeEnd1) {
            node = injectGaps(ranges, rangeI, ch, offset, dont);
            movePastNext(ch.to + offset, false);
        } else {
            node = ch.toTree();
        }
        children.push(node);
        positions.push(from - start);
    }
    movePastNext(tree.to + offset, false);
    return new Tree1(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);
}
class MarkdownParser extends Parser {
    nodeSet;
    blockParsers;
    leafBlockParsers;
    blockNames;
    endLeafBlock;
    skipContextMarkup;
    inlineParsers;
    inlineNames;
    wrappers;
    nodeTypes = Object.create(null);
    constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers){
        super();
        this.nodeSet = nodeSet;
        this.blockParsers = blockParsers;
        this.leafBlockParsers = leafBlockParsers;
        this.blockNames = blockNames;
        this.endLeafBlock = endLeafBlock;
        this.skipContextMarkup = skipContextMarkup;
        this.inlineParsers = inlineParsers;
        this.inlineNames = inlineNames;
        this.wrappers = wrappers;
        for (let t18 of nodeSet.types)this.nodeTypes[t18.name] = t18.id;
    }
    createParse(input, fragments, ranges) {
        let parse8 = new BlockContext(this, input, fragments, ranges);
        for (let w of this.wrappers)parse8 = w(parse8, input, fragments, ranges);
        return parse8;
    }
    configure(spec) {
        let config33 = resolveConfig(spec);
        if (!config33) return this;
        let { nodeSet , skipContextMarkup  } = this;
        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
        if (nonEmpty(config33.defineNodes)) {
            skipContextMarkup = Object.assign({}, skipContextMarkup);
            let nodeTypes1 = nodeSet.types.slice();
            for (let s of config33.defineNodes){
                let { name: name1 , block , composite  } = typeof s == "string" ? {
                    name: s
                } : s;
                if (nodeTypes1.some((t19)=>t19.name == name1
                )) continue;
                if (composite) skipContextMarkup[nodeTypes1.length] = (bl, cx, line)=>composite(cx, line, bl.value)
                ;
                let id16 = nodeTypes1.length;
                let group = composite ? [
                    "Block",
                    "BlockContext"
                ] : !block ? undefined : id16 >= Type.ATXHeading1 && id16 <= Type.SetextHeading2 ? [
                    "Block",
                    "LeafBlock",
                    "Heading"
                ] : [
                    "Block",
                    "LeafBlock"
                ];
                nodeTypes1.push(NodeType.define({
                    id: id16,
                    name: name1,
                    props: group && [
                        [
                            NodeProp.group,
                            group
                        ]
                    ]
                }));
            }
            nodeSet = new NodeSet(nodeTypes1);
        }
        if (nonEmpty(config33.props)) nodeSet = nodeSet.extend(...config33.props);
        if (nonEmpty(config33.remove)) {
            for (let rm3 of config33.remove){
                let block = this.blockNames.indexOf(rm3), inline = this.inlineNames.indexOf(rm3);
                if (block > -1) blockParsers[block] = leafBlockParsers[block] = undefined;
                if (inline > -1) inlineParsers[inline] = undefined;
            }
        }
        if (nonEmpty(config33.parseBlock)) {
            for (let spec of config33.parseBlock){
                let found = blockNames.indexOf(spec.name);
                if (found > -1) {
                    blockParsers[found] = spec.parse;
                    leafBlockParsers[found] = spec.leaf;
                } else {
                    let pos = spec.before ? findName(blockNames, spec.before) : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;
                    blockParsers.splice(pos, 0, spec.parse);
                    leafBlockParsers.splice(pos, 0, spec.leaf);
                    blockNames.splice(pos, 0, spec.name);
                }
                if (spec.endLeaf) endLeafBlock.push(spec.endLeaf);
            }
        }
        if (nonEmpty(config33.parseInline)) {
            for (let spec of config33.parseInline){
                let found = inlineNames.indexOf(spec.name);
                if (found > -1) {
                    inlineParsers[found] = spec.parse;
                } else {
                    let pos = spec.before ? findName(inlineNames, spec.before) : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;
                    inlineParsers.splice(pos, 0, spec.parse);
                    inlineNames.splice(pos, 0, spec.name);
                }
            }
        }
        if (config33.wrap) wrappers = wrappers.concat(config33.wrap);
        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
    }
    getNodeType(name2) {
        let found = this.nodeTypes[name2];
        if (found == null) throw new RangeError(`Unknown node type '${name2}'`);
        return found;
    }
    parseInline(text, offset) {
        let cx = new InlineContext(this, text, offset);
        outer: for(let pos = offset; pos < cx.end;){
            let next = cx.char(pos);
            for (let token of this.inlineParsers)if (token) {
                let result = token(cx, next, pos);
                if (result >= 0) {
                    pos = result;
                    continue outer;
                }
            }
            pos++;
        }
        return cx.resolveMarkers(0);
    }
}
function nonEmpty(a) {
    return a != null && a.length > 0;
}
function resolveConfig(spec) {
    if (!Array.isArray(spec)) return spec;
    if (spec.length == 0) return null;
    let conf = resolveConfig(spec[0]);
    if (spec.length == 1) return conf;
    let rest = resolveConfig(spec.slice(1));
    if (!rest || !conf) return conf || rest;
    let conc1 = (a, b)=>(a || none4).concat(b || none4)
    ;
    let wrapA = conf.wrap, wrapB = rest.wrap;
    return {
        props: conc1(conf.props, rest.props),
        defineNodes: conc1(conf.defineNodes, rest.defineNodes),
        parseBlock: conc1(conf.parseBlock, rest.parseBlock),
        parseInline: conc1(conf.parseInline, rest.parseInline),
        remove: conc1(conf.remove, rest.remove),
        wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges)=>wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
    };
}
function findName(names, name3) {
    let found = names.indexOf(name3);
    if (found < 0) throw new RangeError(`Position specified relative to unknown parser ${name3}`);
    return found;
}
let nodeTypes = [
    NodeType.none
];
for(let i3 = 1, name1; name1 = Type[i3]; i3++){
    nodeTypes[i3] = NodeType.define({
        id: i3,
        name: name1,
        props: i3 >= Type.Escape ? [] : [
            [
                NodeProp.group,
                i3 in DefaultSkipMarkup ? [
                    "Block",
                    "BlockContext"
                ] : [
                    "Block",
                    "LeafBlock"
                ]
            ]
        ]
    });
}
const none4 = [];
class Buffer {
    nodeSet;
    content = [];
    nodes = [];
    constructor(nodeSet){
        this.nodeSet = nodeSet;
    }
    write(type, from, to, children = 0) {
        this.content.push(type, from, to, 4 + children * 4);
        return this;
    }
    writeElements(elts, offset = 0) {
        for (let e of elts)e.writeTo(this, offset);
        return this;
    }
    finish(type, length) {
        return Tree1.build({
            buffer: this.content,
            nodeSet: this.nodeSet,
            reused: this.nodes,
            topID: type,
            length
        });
    }
}
class Element {
    type;
    from;
    to;
    children;
    constructor(type, from, to, children = none4){
        this.type = type;
        this.from = from;
        this.to = to;
        this.children = children;
    }
    writeTo(buf, offset) {
        let startOff = buf.content.length;
        buf.writeElements(this.children, offset);
        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
    }
    toTree(nodeSet) {
        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
    }
}
class TreeElement {
    tree;
    from;
    constructor(tree, from){
        this.tree = tree;
        this.from = from;
    }
    get to() {
        return this.from + this.tree.length;
    }
    get type() {
        return this.tree.type.id;
    }
    get children() {
        return none4;
    }
    writeTo(buf, offset) {
        buf.nodes.push(this.tree);
        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
    }
    toTree() {
        return this.tree;
    }
}
function elt(type, from, to, children) {
    return new Element(type, from, to, children);
}
var Mark;
(function(Mark1) {
    Mark1[Mark1["Open"] = 1] = "Open";
    Mark1[Mark1["Close"] = 2] = "Close";
})(Mark || (Mark = {}));
const EmphasisUnderscore = {
    resolve: "Emphasis",
    mark: "EmphasisMark"
};
const EmphasisAsterisk = {
    resolve: "Emphasis",
    mark: "EmphasisMark"
};
const LinkStart = {}, ImageStart = {};
class InlineDelimiter {
    type;
    from;
    to;
    side;
    constructor(type, from, to, side){
        this.type = type;
        this.from = from;
        this.to = to;
        this.side = side;
    }
}
const Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
    Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch (_1) {}
const DefaultInline = {
    Escape (cx, next, start) {
        if (next != 92 || start == cx.end - 1) return -1;
        let escaped = cx.char(start + 1);
        for(let i11 = 0; i11 < Escapable.length; i11++)if (Escapable.charCodeAt(i11) == escaped) return cx.append(elt(Type.Escape, start, start + 2));
        return -1;
    },
    Entity (cx, next, start) {
        if (next != 38) return -1;
        let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;
    },
    InlineCode (cx, next, start) {
        if (next != 96 || start && cx.char(start - 1) == 96) return -1;
        let pos = start + 1;
        while(pos < cx.end && cx.char(pos) == 96)pos++;
        let size = pos - start, curSize = 0;
        for(; pos < cx.end; pos++){
            if (cx.char(pos) == 96) {
                curSize++;
                if (curSize == size && cx.char(pos + 1) != 96) return cx.append(elt(Type.InlineCode, start, pos + 1, [
                    elt(Type.CodeMark, start, start + size),
                    elt(Type.CodeMark, pos + 1 - size, pos + 1)
                ]));
            } else {
                curSize = 0;
            }
        }
        return -1;
    },
    HTMLTag (cx, next, start) {
        if (next != 60 || start == cx.end - 1) return -1;
        let after = cx.slice(start + 1, cx.end);
        let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
        if (url) return cx.append(elt(Type.URL, start, start + 1 + url[0].length));
        let comment4 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
        if (comment4) return cx.append(elt(Type.Comment, start, start + 1 + comment4[0].length));
        let procInst = /^\?[^]*?\?>/.exec(after);
        if (procInst) return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
        let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
        if (!m) return -1;
        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));
    },
    Emphasis (cx, next, start) {
        if (next != 95 && next != 42) return -1;
        let pos = start + 1;
        while(cx.char(pos) == next)pos++;
        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
        let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? Mark.Open : 0) | (canClose ? Mark.Close : 0)));
    },
    HardBreak (cx, next, start) {
        if (next == 92 && cx.char(start + 1) == 10) return cx.append(elt(Type.HardBreak, start, start + 2));
        if (next == 32) {
            let pos = start + 1;
            while(cx.char(pos) == 32)pos++;
            if (cx.char(pos) == 10 && pos >= start + 2) return cx.append(elt(Type.HardBreak, start, pos + 1));
        }
        return -1;
    },
    Link (cx, next, start) {
        return next == 91 ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, Mark.Open)) : -1;
    },
    Image (cx, next, start) {
        return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, Mark.Open)) : -1;
    },
    LinkEnd (cx, next, start) {
        if (next != 93) return -1;
        for(let i12 = cx.parts.length - 1; i12 >= 0; i12--){
            let part = cx.parts[i12];
            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
                if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
                    cx.parts[i12] = null;
                    return -1;
                }
                let content16 = cx.takeContent(i12);
                let link = cx.parts[i12] = finishLink(cx, content16, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
                if (part.type == LinkStart) for(let j = 0; j < i12; j++){
                    let p23 = cx.parts[j];
                    if (p23 instanceof InlineDelimiter && p23.type == LinkStart) p23.side = 0;
                }
                return link.to;
            }
        }
        return -1;
    }
};
function finishLink(cx, content17, type, start, startPos) {
    let { text  } = cx, next = cx.char(startPos), endPos = startPos;
    content17.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
    content17.push(elt(Type.LinkMark, startPos - 1, startPos));
    if (next == 40) {
        let pos = cx.skipSpace(startPos + 1);
        let dest = parseURL(text, pos - cx.offset, cx.offset), title;
        if (dest) {
            pos = cx.skipSpace(dest.to);
            title = parseLinkTitle(text, pos - cx.offset, cx.offset);
            if (title) pos = cx.skipSpace(title.to);
        }
        if (cx.char(pos) == 41) {
            content17.push(elt(Type.LinkMark, startPos, startPos + 1));
            endPos = pos + 1;
            if (dest) content17.push(dest);
            if (title) content17.push(title);
            content17.push(elt(Type.LinkMark, pos, endPos));
        }
    } else if (next == 91) {
        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
        if (label) {
            content17.push(label);
            endPos = label.to;
        }
    }
    return elt(type, start, endPos, content17);
}
function parseURL(text, start, offset) {
    let next = text.charCodeAt(start);
    if (next == 60) {
        for(let pos = start + 1; pos < text.length; pos++){
            let ch = text.charCodeAt(pos);
            if (ch == 62) return elt(Type.URL, start + offset, pos + 1 + offset);
            if (ch == 60 || ch == 10) return false;
        }
        return null;
    } else {
        let depth8 = 0, pos = start;
        for(let escaped = false; pos < text.length; pos++){
            let ch = text.charCodeAt(pos);
            if (space(ch)) {
                break;
            } else if (escaped) {
                escaped = false;
            } else if (ch == 40) {
                depth8++;
            } else if (ch == 41) {
                if (!depth8) break;
                depth8--;
            } else if (ch == 92) {
                escaped = true;
            }
        }
        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;
    }
}
function parseLinkTitle(text, start, offset) {
    let next = text.charCodeAt(start);
    if (next != 39 && next != 34 && next != 40) return false;
    let end = next == 40 ? 41 : next;
    for(let pos = start + 1, escaped = false; pos < text.length; pos++){
        let ch = text.charCodeAt(pos);
        if (escaped) escaped = false;
        else if (ch == end) return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
        else if (ch == 92) escaped = true;
    }
    return null;
}
function parseLinkLabel(text, start, offset, requireNonWS) {
    for(let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++){
        let ch = text.charCodeAt(pos);
        if (escaped) escaped = false;
        else if (ch == 93) return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
        else {
            if (requireNonWS && !space(ch)) requireNonWS = false;
            if (ch == 91) return false;
            else if (ch == 92) escaped = true;
        }
    }
    return null;
}
class InlineContext {
    parser;
    text;
    offset;
    parts = [];
    constructor(parser5, text, offset){
        this.parser = parser5;
        this.text = text;
        this.offset = offset;
    }
    char(pos) {
        return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
    }
    get end() {
        return this.offset + this.text.length;
    }
    slice(from, to) {
        return this.text.slice(from - this.offset, to - this.offset);
    }
    append(elt5) {
        this.parts.push(elt5);
        return elt5.to;
    }
    addDelimiter(type, from, to, open, close) {
        return this.append(new InlineDelimiter(type, from, to, (open ? Mark.Open : 0) | (close ? Mark.Close : 0)));
    }
    addElement(elt6) {
        return this.append(elt6);
    }
    resolveMarkers(from) {
        for(let i14 = from; i14 < this.parts.length; i14++){
            let close = this.parts[i14];
            if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & Mark.Close)) continue;
            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
            let closeSize = close.to - close.from;
            let open, j = i14 - 1;
            for(; j >= from; j--){
                let part = this.parts[j];
                if (!(part instanceof InlineDelimiter && part.side & Mark.Open && part.type == close.type) || emp && (close.side & Mark.Open || part.side & Mark.Close) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3)) continue;
                open = part;
                break;
            }
            if (!open) continue;
            let type = close.type.resolve, content18 = [];
            let start = open.from, end = close.to;
            if (emp) {
                let size = Math.min(2, open.to - open.from, closeSize);
                start = open.to - size;
                end = close.from + size;
                type = size == 1 ? "Emphasis" : "StrongEmphasis";
            }
            if (open.type.mark) content18.push(this.elt(open.type.mark, start, open.to));
            for(let k = j + 1; k < i14; k++){
                if (this.parts[k] instanceof Element) content18.push(this.parts[k]);
                this.parts[k] = null;
            }
            if (close.type.mark) content18.push(this.elt(close.type.mark, close.from, end));
            let element = this.elt(type, start, end, content18);
            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
            let keep = this.parts[i14] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
            if (keep) this.parts.splice(i14, 0, element);
            else this.parts[i14] = element;
        }
        let result = [];
        for(let i13 = from; i13 < this.parts.length; i13++){
            let part = this.parts[i13];
            if (part instanceof Element) result.push(part);
        }
        return result;
    }
    findOpeningDelimiter(type) {
        for(let i15 = this.parts.length - 1; i15 >= 0; i15--){
            let part = this.parts[i15];
            if (part instanceof InlineDelimiter && part.type == type) return i15;
        }
        return null;
    }
    takeContent(startIndex) {
        let content19 = this.resolveMarkers(startIndex);
        this.parts.length = startIndex;
        return content19;
    }
    skipSpace(from) {
        return skipSpace(this.text, from - this.offset) + this.offset;
    }
    elt(type, from, to, children) {
        if (typeof type == "string") return elt(this.parser.getNodeType(type), from, to, children);
        return new TreeElement(type, from);
    }
}
function injectMarks(elements, marks) {
    if (!marks.length) return elements;
    if (!elements.length) return marks;
    let elts = elements.slice(), eI = 0;
    for (let mark of marks){
        while(eI < elts.length && elts[eI].to < mark.to)eI++;
        if (eI < elts.length && elts[eI].from < mark.from) {
            let e = elts[eI];
            if (e instanceof Element) elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [
                mark
            ]));
        } else {
            elts.splice(eI++, 0, mark);
        }
    }
    return elts;
}
const NotLast = [
    Type.CodeBlock,
    Type.ListItem,
    Type.OrderedList,
    Type.BulletList
];
class FragmentCursor1 {
    fragments;
    input;
    i = 0;
    fragment = null;
    fragmentEnd = -1;
    cursor = null;
    constructor(fragments, input){
        this.fragments = fragments;
        this.input = input;
        if (fragments.length) this.fragment = fragments[this.i++];
    }
    nextFragment() {
        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
        this.cursor = null;
        this.fragmentEnd = -1;
    }
    moveTo(pos, lineStart) {
        while(this.fragment && this.fragment.to <= pos)this.nextFragment();
        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0)) return false;
        if (this.fragmentEnd < 0) {
            let end = this.fragment.to;
            while(end > 0 && this.input.read(end - 1, end) != "\n")end--;
            this.fragmentEnd = end ? end - 1 : 0;
        }
        let c = this.cursor;
        if (!c) {
            c = this.cursor = this.fragment.tree.cursor();
            c.firstChild();
        }
        let rPos = pos + this.fragment.offset;
        while(c.to <= rPos)if (!c.parent()) return false;
        for(;;){
            if (c.from >= rPos) return this.fragment.from <= lineStart;
            if (!c.childAfter(rPos)) return false;
        }
    }
    matches(hash) {
        let tree = this.cursor.tree;
        return tree && tree.prop(NodeProp.contextHash) == hash;
    }
    takeNodes(cx) {
        let cur27 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
        let prevEnd = end, prevI = blockI;
        for(;;){
            if (cur27.to - off > fragEnd) {
                if (cur27.type.isAnonymous && cur27.firstChild()) continue;
                break;
            }
            cx.dontInject.add(cur27.tree);
            cx.addNode(cur27.tree, cur27.from - off);
            if (cur27.type.is("Block")) {
                if (NotLast.indexOf(cur27.type.id) < 0) {
                    end = cur27.to - off;
                    blockI = cx.block.children.length;
                } else {
                    end = prevEnd;
                    blockI = prevI;
                    prevEnd = cur27.to - off;
                    prevI = cx.block.children.length;
                }
            }
            if (!cur27.nextSibling()) break;
        }
        while(cx.block.children.length > blockI){
            cx.block.children.pop();
            cx.block.positions.pop();
        }
        return end - start;
    }
}
const parser = new MarkdownParser(new NodeSet(nodeTypes), Object.keys(DefaultBlockParsers).map((n)=>DefaultBlockParsers[n]
), Object.keys(DefaultBlockParsers).map((n)=>DefaultLeafBlocks[n]
), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n)=>DefaultInline[n]
), Object.keys(DefaultInline), []);
function leftOverSpace(node, from, to) {
    let ranges = [];
    for(let n = node.firstChild, pos = from;; n = n.nextSibling){
        let nextPos = n ? n.from : to;
        if (nextPos > pos) ranges.push({
            from: pos,
            to: nextPos
        });
        if (!n) break;
        pos = n.to;
    }
    return ranges;
}
function parseCode(config34) {
    let { codeParser , htmlParser  } = config34;
    let wrap1 = parseMixed((node1, input)=>{
        let id17 = node1.type.id;
        if (codeParser && (id17 == Type.CodeBlock || id17 == Type.FencedCode)) {
            let info = "";
            if (id17 == Type.FencedCode) {
                let infoNode = node1.node.getChild(Type.CodeInfo);
                if (infoNode) info = input.read(infoNode.from, infoNode.to);
            }
            let parser12 = codeParser(info);
            if (parser12) return {
                parser: parser12,
                overlay: (node)=>node.type.id == Type.CodeText
            };
        } else if (htmlParser && (id17 == Type.HTMLBlock || id17 == Type.HTMLTag)) {
            return {
                parser: htmlParser,
                overlay: leftOverSpace(node1.node, node1.from, node1.to)
            };
        }
        return null;
    });
    return {
        wrap: wrap1
    };
}
const StrikethroughDelim = {
    resolve: "Strikethrough",
    mark: "StrikethroughMark"
};
const Strikethrough = {
    defineNodes: [
        "Strikethrough",
        "StrikethroughMark"
    ],
    parseInline: [
        {
            name: "Strikethrough",
            parse (cx, next, pos) {
                if (next != 126 || cx.char(pos + 1) != 126) return -1;
                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);
            },
            after: "Emphasis"
        }
    ]
};
function parseRow(cx, line, startI = 0, elts, offset = 0) {
    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
    let parseCell = ()=>{
        elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
    };
    for(let i190 = startI; i190 < line.length; i190++){
        let next = line.charCodeAt(i190);
        if (next == 124 && !esc) {
            if (!first || cellStart > -1) count++;
            first = false;
            if (elts) {
                if (cellStart > -1) parseCell();
                elts.push(cx.elt("TableDelimiter", i190 + offset, i190 + offset + 1));
            }
            cellStart = cellEnd = -1;
        } else if (esc || next != 32 && next != 9) {
            if (cellStart < 0) cellStart = i190;
            cellEnd = i190 + 1;
        }
        esc = !esc && next == 92;
    }
    if (cellStart > -1) {
        count++;
        if (elts) parseCell();
    }
    return count;
}
function hasPipe(str, start) {
    for(let i191 = start; i191 < str.length; i191++){
        let next = str.charCodeAt(i191);
        if (next == 124) return true;
        if (next == 92) i191++;
    }
    return false;
}
class TableParser {
    rows = null;
    nextLine(cx, line, leaf) {
        if (this.rows == null) {
            this.rows = false;
            let lineText;
            if ((line.next == 45 || line.next == 58 || line.next == 124) && /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/.test(lineText = line.text.slice(line.pos))) {
                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
                if (firstCount == parseRow(cx, lineText, line.pos)) this.rows = [
                    cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
                    cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
                ];
            }
        } else if (this.rows) {
            let content20 = [];
            parseRow(cx, line.text, line.pos, content20, cx.lineStart);
            this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content20));
        }
        return false;
    }
    finish(cx, leaf) {
        if (this.rows) {
            this.emit(cx, leaf);
            return true;
        }
        return false;
    }
    emit(cx, leaf) {
        cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
    }
}
const Table = {
    defineNodes: [
        {
            name: "Table",
            block: true
        },
        "TableHeader",
        "TableRow",
        "TableCell",
        "TableDelimiter"
    ],
    parseBlock: [
        {
            name: "Table",
            leaf (_, leaf) {
                return hasPipe(leaf.content, 0) ? new TableParser : null;
            },
            before: "SetextHeading"
        }
    ]
};
class TaskParser {
    nextLine() {
        return false;
    }
    finish(cx, leaf) {
        cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
            cx.elt("TaskMarker", leaf.start, leaf.start + 3),
            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
        ]));
        return true;
    }
}
const TaskList = {
    defineNodes: [
        {
            name: "Task",
            block: true
        },
        "TaskMarker"
    ],
    parseBlock: [
        {
            name: "TaskList",
            leaf (cx, leaf) {
                return /^\[[ xX]\]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser : null;
            },
            after: "SetextHeading"
        }
    ]
};
const GFM = [
    Table,
    TaskList,
    Strikethrough
];
function parseSubSuper(ch, node, mark) {
    return (cx, next, pos)=>{
        if (next != ch || cx.char(pos + 1) == ch) return -1;
        let elts = [
            cx.elt(mark, pos, pos + 1)
        ];
        for(let i192 = pos + 1; i192 < cx.end; i192++){
            let next = cx.char(i192);
            if (next == ch) return cx.addElement(cx.elt(node, pos, i192 + 1, elts.concat(cx.elt(mark, i192, i192 + 1))));
            if (next == 92) elts.push(cx.elt("Escape", i192, (i192++) + 2));
            if (space(next)) break;
        }
        return -1;
    };
}
const Superscript = {
    defineNodes: [
        "Superscript",
        "SuperscriptMark"
    ],
    parseInline: [
        {
            name: "Superscript",
            parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
        }
    ]
};
const Subscript = {
    defineNodes: [
        "Subscript",
        "SubscriptMark"
    ],
    parseInline: [
        {
            name: "Subscript",
            parse: parseSubSuper(126, "Subscript", "SubscriptMark")
        }
    ]
};
const Emoji = {
    defineNodes: [
        "Emoji"
    ],
    parseInline: [
        {
            name: "Emoji",
            parse (cx, next, pos) {
                let match;
                if (next != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end)))) return -1;
                return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
            }
        }
    ]
};
var Action;
(function(Action1) {
    Action1[Action1["ReduceFlag"] = 65536] = "ReduceFlag";
    Action1[Action1["ValueMask"] = 2 ** 16 - 1] = "ValueMask";
    Action1[Action1["ReduceDepthShift"] = 19] = "ReduceDepthShift";
    Action1[Action1["RepeatFlag"] = 131072] = "RepeatFlag";
    Action1[Action1["GotoFlag"] = 131072] = "GotoFlag";
    Action1[Action1["StayFlag"] = 262144] = "StayFlag";
})(Action || (Action = {}));
var StateFlag;
(function(StateFlag1) {
    StateFlag1[StateFlag1["Skipped"] = 1] = "Skipped";
    StateFlag1[StateFlag1["Accepting"] = 2] = "Accepting";
})(StateFlag || (StateFlag = {}));
var Specialize;
(function(Specialize1) {
    Specialize1[Specialize1["Specialize"] = 0] = "Specialize";
    Specialize1[Specialize1["Extend"] = 1] = "Extend";
})(Specialize || (Specialize = {}));
var Term;
(function(Term1) {
    Term1[Term1["Err"] = 0] = "Err";
})(Term || (Term = {}));
var Seq;
(function(Seq1) {
    Seq1[Seq1["End"] = 65535] = "End";
    Seq1[Seq1["Done"] = 0] = "Done";
    Seq1[Seq1["Next"] = 1] = "Next";
    Seq1[Seq1["Other"] = 2] = "Other";
})(Seq || (Seq = {}));
var ParseState;
(function(ParseState1) {
    ParseState1[ParseState1["Flags"] = 0] = "Flags";
    ParseState1[ParseState1["Actions"] = 1] = "Actions";
    ParseState1[ParseState1["Skip"] = 2] = "Skip";
    ParseState1[ParseState1["TokenizerMask"] = 3] = "TokenizerMask";
    ParseState1[ParseState1["DefaultReduce"] = 4] = "DefaultReduce";
    ParseState1[ParseState1["ForcedReduce"] = 5] = "ForcedReduce";
    ParseState1[ParseState1["Size"] = 6] = "Size";
})(ParseState || (ParseState = {}));
var Encode;
(function(Encode1) {
    Encode1[Encode1["BigValCode"] = 126] = "BigValCode";
    Encode1[Encode1["BigVal"] = 65535] = "BigVal";
    Encode1[Encode1["Start"] = 32] = "Start";
    Encode1[Encode1["Gap1"] = 34] = "Gap1";
    Encode1[Encode1["Gap2"] = 92] = "Gap2";
    Encode1[Encode1["Base"] = 46] = "Base";
})(Encode || (Encode = {}));
var File;
(function(File1) {
    File1[File1["Version"] = 13] = "Version";
})(File || (File = {}));
class Stack {
    p;
    stack;
    state;
    reducePos;
    pos;
    score;
    buffer;
    bufferBase;
    curContext;
    lookAhead;
    parent;
    constructor(p24, stack, state152, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent){
        this.p = p24;
        this.stack = stack;
        this.state = state152;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score2;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    toString() {
        return `[${this.stack.filter((_, i193)=>i193 % 3 == 0
        ).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p25, state153, pos = 0) {
        let cx = p25.parser.context;
        return new Stack(p25, [], state153, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
        return this.curContext ? this.curContext.context : null;
    }
    pushState(state154, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state154;
    }
    reduce(action) {
        let depth9 = action >> Action.ReduceDepthShift, type = action & Action.ValueMask;
        let { parser: parser13  } = this.p;
        let dPrec = parser13.dynamicPrecedence(type);
        if (dPrec) this.score += dPrec;
        if (depth9 == 0) {
            this.pushState(parser13.getGoto(this.state, type, true), this.reducePos);
            if (type < parser13.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        let base20 = this.stack.length - (depth9 - 1) * 3 - (action & Action.StayFlag ? 6 : 0);
        let start = this.stack[base20 - 2];
        let bufferBase = this.stack[base20 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        if (type < parser13.minRepeatTerm || action & Action.RepeatFlag) {
            let pos = parser13.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & Action.StayFlag) {
            this.state = this.stack[base20];
        } else {
            let baseStateID = this.stack[base20 - 3];
            this.state = parser13.getGoto(baseStateID, type, true);
        }
        while(this.stack.length > base20)this.stack.pop();
        this.reduceContext(type, start);
    }
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == Term.Err) {
            let cur28 = this, top36 = this.buffer.length;
            if (top36 == 0 && cur28.parent) {
                top36 = cur28.bufferBase - cur28.parent.bufferBase;
                cur28 = cur28.parent;
            }
            if (top36 > 0 && cur28.buffer[top36 - 4] == Term.Err && cur28.buffer[top36 - 1] > -1) {
                if (start == end) return;
                if (cur28.buffer[top36 - 2] >= start) {
                    cur28.buffer[top36 - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) {
            this.buffer.push(term, start, end, size);
        } else {
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != Term.Err) while(index > 0 && this.buffer[index - 2] > end){
                this.buffer[index] = this.buffer[index - 4];
                this.buffer[index + 1] = this.buffer[index - 3];
                this.buffer[index + 2] = this.buffer[index - 2];
                this.buffer[index + 3] = this.buffer[index - 1];
                index -= 4;
                if (size > 4) size -= 4;
            }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & Action.GotoFlag) {
            this.pushState(action & Action.ValueMask, this.pos);
        } else if ((action & Action.StayFlag) == 0) {
            let nextState = action, { parser: parser14  } = this.p;
            if (nextEnd > this.pos || next <= parser14.maxNode) {
                this.pos = nextEnd;
                if (!parser14.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser14.maxNode) this.buffer.push(next, start, nextEnd, 4);
        } else {
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode) this.buffer.push(next, start, nextEnd, 4);
        }
    }
    apply(action, next, nextEnd) {
        if (action & Action.ReduceFlag) this.reduce(action);
        else this.shift(action, next, nextEnd);
    }
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1);
        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
        let parent = this;
        let off = parent.buffer.length;
        while(off > 0 && parent.buffer[off - 2] > parent.reducePos)off -= 4;
        let buffer = parent.buffer.slice(off), base21 = parent.bufferBase + off;
        while(parent && base21 == parent.bufferBase)parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base21, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= Recover.Delete;
    }
    canShift(term) {
        for(let sim = new SimulatedStack(this);;){
            let action = this.p.parser.stateSlot(sim.state, ParseState.DefaultReduce) || this.p.parser.hasAction(sim.state, term);
            if ((action & Action.ReduceFlag) == 0) return true;
            if (action == 0) return false;
            sim.reduce(action);
        }
    }
    recoverByInsert(next) {
        if (this.stack.length >= Recover.MaxInsertStackDepth) return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > Recover.MaxNext << 1 || this.stack.length >= Recover.DampenInsertStackDepth) {
            let best = [];
            for(let i212 = 0, s; i212 < nextStates.length; i212 += 2){
                if ((s = nextStates[i212 + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i212], s);
            }
            if (this.stack.length < Recover.DampenInsertStackDepth) for(let i1 = 0; best.length < Recover.MaxNext << 1 && i1 < nextStates.length; i1 += 2){
                let s = nextStates[i1 + 1];
                if (!best.some((v, i195)=>i195 & 1 && v == s
                )) best.push(nextStates[i1], s);
            }
            nextStates = best;
        }
        let result = [];
        for(let i194 = 0; i194 < nextStates.length && result.length < Recover.MaxNext; i194 += 2){
            let s = nextStates[i194 + 1];
            if (s == this.state) continue;
            let stack = this.split();
            stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i194], this.pos);
            stack.score -= Recover.Insert;
            result.push(stack);
        }
        return result;
    }
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, ParseState.ForcedReduce);
        if ((reduce & Action.ReduceFlag) == 0) return false;
        let { parser: parser15  } = this.p;
        if (!parser15.validAction(this.state, reduce)) {
            let depth10 = reduce >> Action.ReduceDepthShift, term = reduce & Action.ValueMask;
            let target = this.stack.length - depth10 * 3;
            if (target < 0 || parser15.getGoto(this.stack[target], term, false) < 0) return false;
            this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true);
            this.score -= Recover.Reduce;
        }
        this.reduce(reduce);
        return true;
    }
    forceAll() {
        while(!this.p.parser.stateFlag(this.state, StateFlag.Accepting)){
            if (!this.forceReduce()) {
                this.storeNode(Term.Err, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    get deadEnd() {
        if (this.stack.length != 3) return false;
        let { parser: parser16  } = this.p;
        return parser16.data[parser16.stateSlot(this.state, ParseState.Actions)] == Seq.End && !parser16.stateSlot(this.state, ParseState.DefaultReduce);
    }
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length) return false;
        for(let i196 = 0; i196 < this.stack.length; i196 += 3)if (this.stack[i196] != other.stack[i196]) return false;
        return true;
    }
    get parser() {
        return this.p.parser;
    }
    dialectEnabled(dialectID) {
        return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash) this.emitContext();
            this.curContext = newCx;
        }
    }
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    close() {
        if (this.curContext && this.curContext.tracker.strict) this.emitContext();
        if (this.lookAhead > 0) this.emitLookAhead();
    }
}
class StackContext {
    tracker;
    context;
    hash;
    constructor(tracker, context){
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function(Recover1) {
    Recover1[Recover1["Insert"] = 200] = "Insert";
    Recover1[Recover1["Delete"] = 190] = "Delete";
    Recover1[Recover1["Reduce"] = 100] = "Reduce";
    Recover1[Recover1["MaxNext"] = 4] = "MaxNext";
    Recover1[Recover1["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover1[Recover1["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
class SimulatedStack {
    start;
    state;
    stack;
    base;
    constructor(start){
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & Action.ValueMask, depth11 = action >> Action.ReduceDepthShift;
        if (depth11 == 0) {
            if (this.stack == this.start.stack) this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        } else {
            this.base -= (depth11 - 1) * 3;
        }
        let __goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = __goto;
    }
}
class StackBufferCursor {
    stack;
    pos;
    index;
    buffer;
    constructor(stack, pos, index){
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0) this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() {
        return this.buffer[this.index - 4];
    }
    get start() {
        return this.buffer[this.index - 3];
    }
    get end() {
        return this.buffer[this.index - 2];
    }
    get size() {
        return this.buffer[this.index - 1];
    }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0) this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}
class CachedToken {
    start = -1;
    value = -1;
    end = -1;
    extended = -1;
    lookAhead = 0;
    mask = 0;
    context = 0;
}
const nullToken = new CachedToken;
class InputStream {
    input;
    ranges;
    chunk = "";
    chunkOff = 0;
    chunkPos;
    chunk2 = "";
    chunk2Pos = 0;
    next = -1;
    token = nullToken;
    pos;
    end;
    rangeIndex = 0;
    range;
    constructor(input, ranges){
        this.input = input;
        this.ranges = ranges;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while(pos < range.from){
            if (!index) return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while(assoc < 0 ? pos > range.to : pos >= range.to){
            if (index == this.ranges.length - 1) return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        } else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null) return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            } else {
                let i197 = this.rangeIndex, range = this.range;
                while(range.to <= pos)range = this.ranges[++i197];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;
        return result;
    }
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk , chunkPos  } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        } else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length) return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n = 1) {
        this.chunkOff += n;
        while(this.pos + n >= this.range.to){
            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        } else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while(pos < this.range.from)this.range = this.ranges[--this.rangeIndex];
            while(pos >= this.range.to)this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            } else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges){
            if (r.from >= to) break;
            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
class TokenGroup {
    data;
    id;
    contextual;
    fallback;
    extend;
    constructor(data9, id18){
        this.data = data9;
        this.id = id18;
    }
    token(input, stack) {
        readToken(this.data, input, stack, this.id);
    }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
    token;
    contextual;
    fallback;
    extend;
    constructor(token, options = {}){
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
function readToken(data10, input, stack, group) {
    let state155 = 0, groupMask = 1 << group, { parser: parser17  } = stack.p, { dialect  } = parser17;
    scan: for(;;){
        if ((groupMask & data10[state155]) == 0) break;
        let accEnd = data10[state155 + 1];
        for(let i198 = state155 + 3; i198 < accEnd; i198 += 2)if ((data10[i198 + 1] & groupMask) > 0) {
            let term = data10[i198];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser17.overrides(term, input.token.value))) {
                input.acceptToken(term);
                break;
            }
        }
        for(let next = input.next, low = 0, high = data10[state155 + 2]; low < high;){
            let mid = low + high >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data10[index], to = data10[index + 1];
            if (next < from) high = mid;
            else if (next >= to) low = mid + 1;
            else {
                state155 = data10[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}
function decodeArray(input, Type2 = Uint16Array) {
    if (typeof input != "string") return input;
    let array = null;
    for(let pos = 0, out = 0; pos < input.length;){
        let value = 0;
        for(;;){
            let next = input.charCodeAt(pos++), stop = false;
            if (next == Encode.BigValCode) {
                value = Encode.BigVal;
                break;
            }
            if (next >= Encode.Gap2) next--;
            if (next >= Encode.Gap1) next--;
            let digit = next - Encode.Start;
            if (digit >= Encode.Base) {
                digit -= Encode.Base;
                stop = true;
            }
            value += digit;
            if (stop) break;
            value *= Encode.Base;
        }
        if (array) array[out++] = value;
        else array = new Type2(value);
    }
    return array;
}
function addSignalListener(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve3, reject)=>{
        const abort = ()=>{
            clearTimeout(i199);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve3();
        };
        const i199 = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno1  } = globalThis;
typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOf(source, pattern, fromIndex = 0) {
    if (fromIndex >= source.length) {
        return -1;
    }
    if (fromIndex < 0) {
        fromIndex = Math.max(0, source.length + fromIndex);
    }
    const s = pattern[0];
    for(let i200 = fromIndex; i200 < source.length; i200++){
        if (source[i200] !== s) continue;
        const pin = i200;
        let matched = 1;
        let j = i200;
        while(matched < pattern.length){
            j++;
            if (source[j] !== pattern[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === pattern.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
    }
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i201 = 100; i201 > 0; i201--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p26) {
        let rr = p26.byteLength;
        if (p26.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p26.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p26);
                const nread = rr ?? 0;
                assert(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p26, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p27) {
        let bytesRead = 0;
        while(bytesRead < p27.length){
            try {
                const rr = await this.read(p27.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p27.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p27.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p27;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i202 = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i202 >= 0) {
                i202 += s;
                slice = this.#buf.subarray(this.#r, this.#r + i202 + 1);
                this.#r += i202 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p28 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p28.length){
                nwritten += await this.#writer.write(p28.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data11) {
        if (this.err !== null) throw this.err;
        if (data11.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data11.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data11);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data11, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data11 = data11.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data11, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p29 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p29.length){
                nwritten += this.#writer.writeSync(p29.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data12) {
        if (this.err !== null) throw this.err;
        if (data12.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data12.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data12);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data12, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data12 = data12.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data12, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object"
;
const _isFunctionLike = (value)=>value !== null && typeof value === "function"
;
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default1 = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default1
};
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object"
;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod;
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name25 = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name25, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames((value, name26, min1 = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name26, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name26, "an integer", value);
    }
    if (value < min1 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name26, `>= ${min1} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name27, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name27, "Object", value);
    }
});
hideStackFrames((value, name28, min2 = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name28, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name28, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name28, `>= ${min2} && <= ${max}`, value);
    }
    if (value < min2 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name28, `>= ${min2} && <= ${max}`, value);
    }
});
hideStackFrames((value, name29, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name29, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name29, "an integer", value);
        }
        const min3 = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name29, `>= ${min3} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name29, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name30) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name30, "string", value);
    }
}
function validateBoolean(value, name31) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name31, "boolean", value);
    }
}
hideStackFrames((value, name32, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)
        ), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name32, value, reason);
    }
});
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name33)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name33, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name34)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name34, "Function", value);
    }
});
hideStackFrames((value, name35, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name35, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name35, value, reason);
    }
});
function guessHandleType(_fd) {
    notImplemented();
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i203 = 0;
                for(; i203 < length; ++i203){
                    ch = value.charCodeAt(i203);
                    if (i203 === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k)
        );
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod1 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta1 = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined
;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i204 = 0; i204 < optKeys.length; ++i204){
                const key = optKeys[i204];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta1[str.charCodeAt(0)]
;
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i205 = 0; i205 < lastIndex; i205++){
        const point = str.charCodeAt(i205);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i205) {
                result += meta1[point];
            } else {
                result += `${str.slice(last, i205)}${meta1[point]}`;
            }
            last = i205 + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth12 = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth12, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base22 = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i206 = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size = value.length;
            const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base22 = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base22, "special");
            }
        } else if (isRegExp1(value)) {
            base22 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag, "RegExp");
            if (prefix !== "RegExp ") {
                base22 = `${prefix}${base22}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base22, "regexp");
            }
        } else if (isDate1(value)) {
            base22 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag, "Date");
            if (prefix !== "Date ") {
                base22 = `${prefix}${base22}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base22, "date");
            }
        } else if (value instanceof Error) {
            base22 = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base22;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber1(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base22 = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base22;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i206 = 0; i206 < keys.length; i206++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i206], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base22 = base22 === "" ? reference : `${reference} ${base22}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base22, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)
));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth13 = 0;
    let keys;
    let keySet;
    do {
        if (depth13 !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth13 === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key)
            );
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key1 of keys){
            if (key1 === "constructor" || main.hasOwnProperty(key1) || depth13 !== 0 && keySet.has(key1)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key1);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key1, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth13 !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")
            ).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber1(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i207 = 0; i207 < len; i207++){
        if (!value.hasOwnProperty(i207)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i207);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i207, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber1 : formatBigInt;
    for(let i208 = 0; i208 < maxLength; ++i208){
        output[i208] = elementFormatter(ctx.stylize, value[i208]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base23 = `[${type}`;
    if (constructor === null) {
        base23 += " (null prototype)";
    }
    if (value.name === "") {
        base23 += " (anonymous)";
    } else {
        base23 += `: ${value.name}`;
    }
    base23 += "]";
    if (constructor !== type && constructor !== null) {
        base23 += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base23 += ` [${tag}]`;
    }
    return base23;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name36 = err.name != null ? String(err.name) : "Error";
    let len = name36.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name37 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name37);
            if (index !== -1 && stack.includes(err[name37])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name36.endsWith("Error") && stack.startsWith(name36) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name36 !== prefix) {
            if (prefix.includes(name36)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name36}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber1(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state156 , 1: result  } = value;
    if (state156 === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state156 === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name38, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name38 = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name38 = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name38 = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name38 = ctx.stylize(key, "name");
    } else {
        name38 = ctx.stylize(strEscape(key), "string");
    }
    return `${name38}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base24) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i209 = 0; i209 < output.length; i209++){
        if (ctx.colors) {
            totalLength += removeColors(output[i209]).length;
        } else {
            totalLength += output[i209].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base24 === "" || !base24.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i213 = 0; i213 < keys.length; i213++){
        try {
            output[i213] = formatProperty(ctx, value, recurseTimes, keys[i213], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i213]]: ""
            };
            output[i213] = formatProperty(ctx, tmp, recurseTimes, keys[i213], kObjectType);
            const pos = output[i213].lastIndexOf(" ");
            output[i213] = output[i213].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i214) {
    const keys = Object.keys(value);
    let index = i214;
    for(; i214 < keys.length && output.length < maxLength; i214++){
        const key = keys[i214];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base25 = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base25 += " (null prototype)";
        } else {
            base25 += ` (${constructor})`;
        }
    }
    base25 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base25 += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base25;
    }
    return ctx.stylize(base25, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name39 = hasName && value.name || "(anonymous)";
    let base26 = `class ${name39}`;
    if (constructor !== "Function" && constructor !== null) {
        base26 += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base26 += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base26 += ` extends ${superName}`;
        }
    } else {
        base26 += " extends [null prototype]";
    }
    return `[${base26}]`;
}
function reduceToSingleString(ctx, output, base27, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base27.length + 10;
                if (isBelowBreakLength(ctx, output, start, base27)) {
                    return `${base27 ? `${base27} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base27 ? `${base27} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base27)) {
        return `${braces[0]}${base27 ? ` ${base27}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base27 === "" && braces[0].length === 1 ? " " : `${base27 ? ` ${base27}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i215 = 0; i215 < lastIndex; i215++){
            str += output[i215];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i216 = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i216 < outputLength; i216++){
        const len = getStringWidth(output[i216], ctx.colors);
        dataLen[i216] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i217 = 0; i217 < columns; i217++){
            let lineMaxLength = 0;
            for(let j = i217; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i217] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i218 = 0; i218 < output.length; i218++){
                if (typeof value[i218] !== "number" && typeof value[i218] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i1 = 0; i1 < outputLength; i1 += columns){
            const max = Math.min(i1 + columns, outputLength);
            let str = "";
            let j = i1;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state157) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i219 = 0;
    ctx.indentationLvl += 2;
    if (state157 === 0) {
        for(; i219 < maxLength; i219++){
            const pos = i219 * 2;
            output[i219] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i219 < maxLength; i219++){
            const pos = i219 * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes), 
            ];
            output[i219] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state158) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i220 = 0; i220 < maxLength; i220++){
        output[i220] = formatValue(ctx, entries[i220], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state158 === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code11 = __char.codePointAt(0);
        if (isFullWidthCodePoint(code11)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code11)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code12)=>{
    return code12 >= 4352 && (code12 <= 4447 || code12 === 9001 || code12 === 9002 || code12 >= 11904 && code12 <= 12871 && code12 !== 12351 || code12 >= 12880 && code12 <= 19903 || code12 >= 19968 && code12 <= 42182 || code12 >= 43360 && code12 <= 43388 || code12 >= 44032 && code12 <= 55203 || code12 >= 63744 && code12 <= 64255 || code12 >= 65040 && code12 <= 65049 || code12 >= 65072 && code12 <= 65131 || code12 >= 65281 && code12 <= 65376 || code12 >= 65504 && code12 <= 65510 || code12 >= 110592 && code12 <= 110593 || code12 >= 127488 && code12 <= 127569 || code12 >= 127744 && code12 <= 128591 || code12 >= 131072 && code12 <= 262141);
};
const isZeroWidthCodePoint = (code13)=>{
    return code13 <= 31 || code13 >= 127 && code13 <= 159 || code13 >= 768 && code13 <= 879 || code13 >= 8203 && code13 <= 8207 || code13 >= 8400 && code13 <= 8447 || code13 >= 65024 && code13 <= 65039 || code13 >= 65056 && code13 <= 65071 || code13 >= 917760 && code13 <= 917999;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve4;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve4 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve4,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve5, reject)=>{
            args.push((err, ...values18)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values18.length > 1) {
                    const obj = {};
                    for(let i221 = 0; i221 < argumentNames.length; i221++){
                        obj[argumentNames[i221]] = values18[i221];
                    }
                    resolve5(obj);
                } else {
                    resolve5(values18[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data13) {
        this.list[this.top] = data13;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data14) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data14);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i222 = 0; i222 < args.length; i222++){
                    args_[i222] = args[i222];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args)
            );
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
    _nextTick(callback, ...args);
}
var State1;
(function(State3) {
    State3[State3["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State3[State3["PERCENT"] = 1] = "PERCENT";
    State3[State3["POSITIONAL"] = 2] = "POSITIONAL";
    State3[State3["PRECISION"] = 3] = "PRECISION";
    State3[State3["WIDTH"] = 4] = "WIDTH";
})(State1 || (State1 = {}));
var WorP;
(function(WorP1) {
    WorP1[WorP1["WIDTH"] = 0] = "WIDTH";
    WorP1[WorP1["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F1) {
    F1[F1["sign"] = 1] = "sign";
    F1[F1["mantissa"] = 2] = "mantissa";
    F1[F1["fractional"] = 3] = "fractional";
    F1[F1["esign"] = 4] = "esign";
    F1[F1["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State1.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format3, ...args){
        this.format = format3;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State1.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State1.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State1.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i223 = 0; i223 !== this.haveSeen.length; ++i223){
            if (!this.haveSeen[i223]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i223])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State1.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State1.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State1.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State1.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State1.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State1.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State1.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State1.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State1.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State1.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format4 = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format4[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format4[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i224 = 0; i224 !== arg.length; ++i224){
            if (i224 !== 0) str += ", ";
            str += this._handleVerb(arg[i224]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State1.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec1 = this.flags.precision;
        if (prec1 !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec1 === 0 ? "" : num;
            while(num.length < prec1){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n1) {
        const special = this.fmtFloatSpecial(n1);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t20 = n.toExponential().split("e");
            let m = t20[0].replace(".", "");
            const e = parseInt(t20[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i225 = 0; i225 !== Math.abs(e) - 1; ++i225){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n1));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n1 < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec2 = this.flags.precision;
                    const end = prec2 !== -1 ? min(prec2, val.length) : val.length;
                    for(let i226 = 0; i226 !== end; ++i226){
                        if (i226 !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i226) & 255).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p30 = this.flags.precision;
            return p30 === -1 ? val.toString() : val.toString().substr(0, p30);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format5, ...args) {
    const printf1 = new Printf(format5, ...args);
    return printf1.doPrintf();
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null
        ;
    } else {
        testEnabled = ()=>false
        ;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)
                ).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug1 = (...args)=>{
        init();
        debug1 = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug1);
        }
        return debug1(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled
        ;
        return enabled;
    };
    const logger = (...args)=>debug1(...args)
    ;
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let state = "";
if (Deno.permissions) {
    state = (await Deno.permissions.query({
        name: "env",
        variable: "NODE_DEBUG"
    })).state;
}
if (state === "granted") {
    initializeDebugEnv(Deno.env.get("NODE_DEBUG") ?? "");
} else {
    initializeDebugEnv("");
}
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os = {
    UV_UDP_REUSEADDR: 4,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod2 = {
    os: os,
    fs: fs,
    crypto: crypto,
    zlib: zlib,
    trace: trace
};
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]
);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code14]])=>[
        code14,
        status
    ]
);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code15]])=>[
        code15,
        status
    ]
);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code16 = uvTranslateSysError(sysErrno);
        return codeMap.get(code16) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const mod3 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno
};
var Encodings;
(function(Encodings1) {
    Encodings1[Encodings1["ASCII"] = 0] = "ASCII";
    Encodings1[Encodings1["UTF8"] = 1] = "UTF8";
    Encodings1[Encodings1["BASE64"] = 2] = "BASE64";
    Encodings1[Encodings1["UCS2"] = 3] = "UCS2";
    Encodings1[Encodings1["BINARY"] = 4] = "BINARY";
    Encodings1[Encodings1["HEX"] = 5] = "HEX";
    Encodings1[Encodings1["BUFFER"] = 6] = "BUFFER";
    Encodings1[Encodings1["BASE64URL"] = 7] = "BASE64URL";
    Encodings1[Encodings1["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default2 = {
    encodings
};
const mod4 = {
    encodings: encodings,
    default: __default2
};
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOf(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number5, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number5);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number5), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default3 = {
    indexOfBuffer,
    indexOfNumber
};
const mod5 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default3
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data15) {
    const uint8 = typeof data15 === "string" ? new TextEncoder().encode(data15) : data15 instanceof Uint8Array ? data15 : new Uint8Array(data15);
    let result = "", i227;
    const l = uint8.length;
    for(i227 = 2; i227 < l; i227 += 3){
        result += base64abc[uint8[i227 - 2] >> 2];
        result += base64abc[(uint8[i227 - 2] & 3) << 4 | uint8[i227 - 1] >> 4];
        result += base64abc[(uint8[i227 - 1] & 15) << 2 | uint8[i227] >> 6];
        result += base64abc[uint8[i227] & 63];
    }
    if (i227 === l + 1) {
        result += base64abc[uint8[i227 - 2] >> 2];
        result += base64abc[(uint8[i227 - 2] & 3) << 4];
        result += "==";
    }
    if (i227 === l) {
        result += base64abc[uint8[i227 - 2] >> 2];
        result += base64abc[(uint8[i227 - 2] & 3) << 4 | uint8[i227 - 1] >> 4];
        result += base64abc[(uint8[i227 - 1] & 15) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i228 = 0; i228 < size; i228++){
        bytes[i228] = binString.charCodeAt(i228);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data16) {
    return convertBase64ToBase64url(encode(data16));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i229 = 0; i229 < str.length; ++i229){
        byteArray.push(str.charCodeAt(i229) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i230;
    for(i230 = 0; i230 < byteArray.length; i230++){
        const a = Number.parseInt(str[i230 * 2], 16);
        const b = Number.parseInt(str[i230 * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i230] = a << 4 | b;
    }
    return new Uint8Array(i230 === byteArray.length ? byteArray : byteArray.slice(0, i230));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i231 = 0; i231 < str.length; ++i231){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i231);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i232 = 0; i232 < bytes.length; ++i232){
        ret += String.fromCharCode(bytes[i232] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i233 = 0; i233 < bytes.length - 1; i233 += 2){
        res += String.fromCharCode(bytes[i233] + bytes[i233 + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 510;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 510;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 61) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i4 = 0; i4 < encodings.length; ++i4){
    encodingsMap[encodings[i4]] = i4;
}
const encodingOps = {
    ascii: {
        byteLength: (string6)=>string6.length
        ,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir)
        ,
        slice: (buf, start, end)=>buf.asciiSlice(start, end)
        ,
        write: (buf, string7, offset, len)=>buf.asciiWrite(string7, offset, len)
    },
    base64: {
        byteLength: (string8)=>base64ByteLength(string8, string8.length)
        ,
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir)
        ,
        slice: (buf, start, end)=>buf.base64Slice(start, end)
        ,
        write: (buf, string9, offset, len)=>buf.base64Write(string9, offset, len)
    },
    base64url: {
        byteLength: (string10)=>base64ByteLength(string10, string10.length)
        ,
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir)
        ,
        slice: (buf, start, end)=>buf.base64urlSlice(start, end)
        ,
        write: (buf, string11, offset, len)=>buf.base64urlWrite(string11, offset, len)
    },
    hex: {
        byteLength: (string12)=>string12.length >>> 1
        ,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir)
        ,
        slice: (buf, start, end)=>buf.hexSlice(start, end)
        ,
        write: (buf, string13, offset, len)=>buf.hexWrite(string13, offset, len)
    },
    latin1: {
        byteLength: (string14)=>string14.length
        ,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir)
        ,
        slice: (buf, start, end)=>buf.latin1Slice(start, end)
        ,
        write: (buf, string15, offset, len)=>buf.latin1Write(string15, offset, len)
    },
    ucs2: {
        byteLength: (string16)=>string16.length * 2
        ,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string17, offset, len)=>buf.ucs2Write(string17, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir)
        ,
        slice: (buf, start, end)=>buf.utf8Slice(start, end)
        ,
        write: (buf, string18, offset, len)=>buf.utf8Write(string18, offset, len)
    },
    utf16le: {
        byteLength: (string19)=>string19.length * 2
        ,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string20, offset, len)=>buf.ucs2Write(string20, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name40) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name40, "number", value);
    }
}
function checkBounds(buf, offset, byteLength1) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength1] === undefined) {
        boundsError(offset, buf.length - (byteLength1 + 1));
    }
}
function checkInt(value, min4, max, buf, offset, byteLength2) {
    if (value > max || value < min4) {
        const n = typeof min4 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min4 === 0 || min4 === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min4}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min5, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min5) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min5} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min6, max) {
    value = +value;
    checkInt(value, min6, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min7, max) {
    value = +value;
    checkInt(value, min7, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min8, max) {
    value = +value;
    checkInt(value, min8, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min9, max) {
    value = +value;
    checkInt(value, min9, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min10, max) {
    value = +value;
    checkInt(value, min10, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min11, max) {
    value = +value;
    checkInt(value, min11, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min12, max) {
    value = +value;
    checkInt(value, min12, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min13, max) {
    value = +value;
    checkInt(value, min13, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name41, min14 = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name41, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name41, "an integer", value);
    }
    if (value < min14 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name41, `>= ${min14} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min15, max) {
    value = +value;
    checkInt(value, min15, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min16, max) {
    value = +value;
    checkInt(value, min16, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min17, max) {
    value = +value;
    checkInt(value, min17, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min18, max) {
    value = +value;
    checkInt(value, min18, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string21, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string21, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string21, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i234 = 0; i234 < length; i234 += 1){
        buf[i234] = array[i234] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer1.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i235 = 0, len = Math.min(x, y); i235 < len; ++i235){
        if (a[i235] !== b[i235]) {
            x = a[i235];
            y = b[i235];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding1(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i236 = 0; i236 < list.length; i236++){
            if (list[i236].length) {
                length += list[i236].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i237 = 0; i237 < list.length; i237++){
        const buf = list[i237];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i237}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i237]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string22, encoding) {
    if (typeof string22 !== "string") {
        if (isArrayBufferView(string22) || isAnyArrayBuffer1(string22)) {
            return string22.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string22);
    }
    const len = string22.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string22);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string22);
    }
    return ops.byteLength(string22);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b, n, m) {
    const i238 = b[n];
    b[n] = b[m];
    b[m] = i238;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i239 = 0; i239 < len; i239 += 2){
        swap(this, i239, i239 + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i240 = 0; i240 < len; i240 += 4){
        swap(this, i240, i240 + 3);
        swap(this, i240 + 1, i240 + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i241 = 0; i241 < len; i241 += 8){
        swap(this, i241, i241 + 7);
        swap(this, i241 + 1, i241 + 6);
        swap(this, i241 + 2, i241 + 5);
        swap(this, i241 + 3, i241 + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer1.prototype[customInspectSymbol1] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i242 = 0; i242 < len; ++i242){
        if (thisCopy[i242] !== targetCopy[i242]) {
            x = thisCopy[i242];
            y = targetCopy[i242];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string23, offset, length) {
    return blitBuffer(asciiToBytes(string23), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string24, offset, length) {
    return blitBuffer(base64ToBytes(string24), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string25, offset, length) {
    return blitBuffer(base64UrlToBytes(string25), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string26, offset, length) {
    return blitBuffer(hexToBytes(string26, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string27, offset, length) {
    return _hexSlice(this, string27, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string28, offset, length) {
    return _latin1Slice(this, string28, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string29, offset, length) {
    return blitBuffer(asciiToBytes(string29), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string30, offset, length) {
    return blitBuffer(utf16leToBytes(string30, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string31, offset, length) {
    return _utf8Slice(this, string31, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string32, offset, length) {
    return blitBuffer(utf8ToBytes(string32, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string33, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string33, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string33, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string33, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i243 = start;
    while(i243 < end){
        const firstByte = buf[i243];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i243 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i243 + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i243 + 1];
                    thirdByte = buf[i243 + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i243 + 1];
                    thirdByte = buf[i243 + 2];
                    fourthByte = buf[i243 + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i243 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i244 = 0;
    while(i244 < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i244, i244 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i245 = start; i245 < end; ++i245){
        ret += String.fromCharCode(buf[i245]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i246 = start; i246 < end; ++i246){
        out += hexSliceLookupTable[buf[i246]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength1) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength1 === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength1 === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength1 === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength1 === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength1 === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength1 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength1, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength2) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength2 === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength2 === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength2 === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength2 === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength2 === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength2 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength2, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength3) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength3 === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength3 === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength3 === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength3 === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength3 === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength3 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength4) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength4 === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength4 === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength4 === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength4 === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength4 === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength4 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength4, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 33554430;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5) {
    if (byteLength5 === 6) {
        return writeU_Int48LE(this, value, offset, 0, 281474976710655);
    }
    if (byteLength5 === 5) {
        return writeU_Int40LE(this, value, offset, 0, 1099511627775);
    }
    if (byteLength5 === 3) {
        return writeU_Int24LE(this, value, offset, 0, 16777215);
    }
    if (byteLength5 === 4) {
        return writeU_Int32LE(this, value, offset, 0, 4294967295);
    }
    if (byteLength5 === 2) {
        return writeU_Int16LE(this, value, offset, 0, 65535);
    }
    if (byteLength5 === 1) {
        return writeU_Int8(this, value, offset, 0, 255);
    }
    boundsError(byteLength5, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
    if (byteLength6 === 6) {
        return writeU_Int48BE(this, value, offset, 0, 281474976710655);
    }
    if (byteLength6 === 5) {
        return writeU_Int40BE(this, value, offset, 0, 1099511627775);
    }
    if (byteLength6 === 3) {
        return writeU_Int24BE(this, value, offset, 0, 16777215);
    }
    if (byteLength6 === 4) {
        return writeU_Int32BE(this, value, offset, 0, 4294967295);
    }
    if (byteLength6 === 2) {
        return writeU_Int16BE(this, value, offset, 0, 65535);
    }
    if (byteLength6 === 1) {
        return writeU_Int8(this, value, offset, 0, 255);
    }
    boundsError(byteLength6, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 255);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 4294967295);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE(buf, value, offset, min19, max) {
    checkIntBI(value, min19, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min20, max) {
    checkIntBI(value, min20, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7) {
    if (byteLength7 === 6) {
        return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);
    }
    if (byteLength7 === 5) {
        return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
    }
    if (byteLength7 === 3) {
        return writeU_Int24LE(this, value, offset, -8388608, 8388607);
    }
    if (byteLength7 === 4) {
        return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
    }
    if (byteLength7 === 2) {
        return writeU_Int16LE(this, value, offset, -32768, 32767);
    }
    if (byteLength7 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
    }
    boundsError(byteLength7, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8) {
    if (byteLength8 === 6) {
        return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);
    }
    if (byteLength8 === 5) {
        return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
    }
    if (byteLength8 === 3) {
        return writeU_Int24BE(this, value, offset, -8388608, 8388607);
    }
    if (byteLength8 === 4) {
        return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
    }
    if (byteLength8 === 2) {
        return writeU_Int16BE(this, value, offset, -32768, 32767);
    }
    if (byteLength8 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
    }
    boundsError(byteLength8, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -128, 127);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code17 = val.charCodeAt(0);
            if (encoding === "utf8" && code17 < 128 || encoding === "latin1") {
                val = code17;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i247;
    if (typeof val === "number") {
        for(i247 = start; i247 < end; ++i247){
            this[i247] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i247 = 0; i247 < end - start; ++i247){
            this[i247 + start] = bytes[i247 % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min21, max, buf, offset, byteLength2) {
    if (value > max || value < min21) {
        const n = typeof min21 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min21 === 0 || min21 === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min21}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string34, units) {
    units = units || Infinity;
    let codePoint;
    const length = string34.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i248 = 0; i248 < length; ++i248){
        codePoint = string34.charCodeAt(i248);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i248 + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, length) {
    let i249;
    for(i249 = 0; i249 < length; ++i249){
        if (i249 + offset >= dst.length || i249 >= src.length) {
            break;
        }
        dst[i249 + offset] = src[i249];
    }
    return i249;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i250 = 0; i250 < 16; ++i250){
        const i16 = i250 * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i250] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType;
(function(valueType1) {
    valueType1[valueType1["noIterator"] = 0] = "noIterator";
    valueType1[valueType1["isArray"] = 1] = "isArray";
    valueType1[valueType1["isSet"] = 2] = "isSet";
    valueType1[valueType1["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()
            ).toString()
        ;
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i251 = 0;
    for(; i251 < aKeys.length; i251++){
        if (!val2.propertyIsEnumerable(aKeys[i251])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i251 = 0; i251 < symbolKeysA.length; i251++){
                const key = symbolKeysA[i251];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i252 = 0; i252 < arr1.byteLength; i252++){
        if (arr1[i252] !== arr2[i252]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key)
    );
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i253 = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i253 < obj1.length; i253++){
            if (obj1.hasOwnProperty(i253)) {
                if (!obj2.hasOwnProperty(i253) || !innerDeepEqual(obj1[i253], obj2[i253], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i253)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i253 < keys1.length; i253++){
                    const key = keys1[i253];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i253 = 0; i253 < keys.length; i253++){
        const key = keys[i253];
        if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict, memos)) return false;
            } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code18) {
    if (typeof code18 !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code18);
    }
    if (code18 >= 0 || !NumberIsSafeInteger(code18)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code18);
    }
    return errorMap.get(code18)?.[0];
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i254 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i254 >= start + 4; i254 -= 3){
        res = `_${val.slice(i254 - 3, i254)}${res}`;
    }
    return `${val.slice(0, i254)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code19 , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code19}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code19;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code20 = getSystemErrorName(err);
    const message = original ? `${syscall} ${code20} ${original}` : `${syscall} ${code20}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code20;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name42) {
    return errorMap.get(name42);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames(function uvException(ctx) {
    const { 0: code21 , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code21}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path2;
    let dest;
    if (ctx.path) {
        path2 = ctx.path.toString();
        message += ` '${path2}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code21;
    if (path2) {
        err.path = path2;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code22 = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code22}${details}`);
    ex.errno = err;
    ex.code = code22;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code23, syscall, hostname) {
    let errno;
    if (typeof code23 === "number") {
        errno = code23;
        if (code23 === codeMap.get("EAI_NODATA") || code23 === codeMap.get("EAI_NONAME")) {
            code23 = "ENOTFOUND";
        } else {
            code23 = getSystemErrorName(code23);
        }
    }
    const message = `${syscall} ${code23}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code23;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name43, code24, message){
        super(message);
        this.code = code24;
        this.name = name43;
        this.stack = this.stack && `${name43} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code25, message){
        super(Error.prototype.name, code25, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code26, message){
        super(RangeError.prototype.name, code26, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code27, message){
        super(TypeError.prototype.name, code27, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name44, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name44.endsWith(" argument")) {
        msg += `${name44} `;
    } else {
        const type = name44.includes(".") ? "property" : "argument";
        msg += `"${name44}" ${type} `;
    }
    msg += "must be ";
    const types4 = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types4.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types4.indexOf("object");
        if (pos !== -1) {
            types4.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types4.length > 0) {
        if (types4.length > 2) {
            const last = types4.pop();
            msg += `one of type ${types4.join(", ")}, or ${last}`;
        } else if (types4.length === 2) {
            msg += `one of type ${types4[0]} or ${types4[1]}`;
        } else {
            msg += `of type ${types4[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name45, expected, actual){
        const msg = createInvalidArgType(name45, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name46, expected, actual){
        const msg = createInvalidArgType(name46, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name47, value, reason = "is invalid"){
        const type = name47.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name47}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name48, value, reason = "is invalid"){
        const type = name48.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name48}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name: name49  } = this;
        this.name = `${name49} [${this.code}]`;
        this.stack;
        this.name = name49;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name50){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name50 ? `"${name50}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap2 = (a)=>`"${a}"`
        ;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap2).join(" or ") : wrap2(a)
        );
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name51, port, allowZero = true){
        assert(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator1 = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name51} should be ${operator1} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name52, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name52}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
let isEventTarget;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        if (isEventTarget === undefined) {
            isEventTarget = require("internal/event_target").isEventTarget;
        }
        for(let i255 = 0; i255 < eventTargets.length; i255++){
            const target = eventTargets[i255];
            if (isEventTarget(target)) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i256 = 0; i256 < len; ++i256){
            const result = listeners[i256].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state159 = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state159);
    wrapped.listener = listener;
    state159.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i257 = list.length - 1; i257 >= 0; i257--){
            if (list[i257] === listener || list[i257].listener === listener) {
                position = i257;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i258 = listeners.length - 1; i258 >= 0; i258--){
            this.removeListener(type, listeners[i258]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i259 = 0; i259 < ret.length; ++i259){
        const orig = ret[i259].listener;
        if (typeof orig === "function") {
            ret[i259] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    const { isEventTarget: isEventTarget1 , kEvents  } = require("internal/event_target");
    if (isEventTarget1(emitterOrTarget)) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name53, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve6, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name53, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve6(args);
        };
        eventTargetAgnosticAddListener(emitter, name53, resolver, {
            once: true
        });
        if (name53 !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name53, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name54, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name54, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name54, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name55, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name55, listener);
        } else {
            emitter.on(name55, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name55, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished1 = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p31 = Promise.reject(error);
                error = null;
                return p31;
            }
            if (finished1) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve7, reject) {
                unconsumedPromises.push({
                    resolve: resolve7,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished1 = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished1 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key1 = keys[keys.length - 1];
    return key1 in o;
}
function parse(args, { "--": doubleDash = false , alias: alias3 = {} , boolean: __boolean = false , default: defaults3 = {} , stopEarly =false , string: string35 = [] , unknown =(i260)=>i260
  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias3 !== undefined) {
        for(const key in alias3){
            const val = getForce(alias3, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias1 of getForce(aliases, key)){
                aliases[alias1] = [
                    key
                ].concat(aliases[key].filter((y)=>alias1 !== y
                ));
            }
        }
    }
    if (string35 !== undefined) {
        const stringArgs = typeof string35 === "string" ? [
            string35
        ] : string35;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    const argv1 = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, keys, value) {
        let o = obj;
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key4 = keys[keys.length - 1];
        if (get(o, key4) === undefined || get(flags.bools, key4) || typeof get(o, key4) === "boolean") {
            o[key4] = value;
        } else if (Array.isArray(get(o, key4))) {
            o[key4].push(value);
        } else {
            o[key4] = [
                get(o, key4),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv1, key.split("."), value);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv1, x.split("."), value);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean"
        );
    }
    for (const key3 of Object.keys(flags.bools)){
        setArg(key3, defaults3[key3] === undefined ? false : defaults3[key3]);
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i261 = 0; i261 < args.length; i261++){
        const arg = args[i261];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert(m != null);
            const [, key, value] = m;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg)) {
            const m = arg.match(/^--no-(.+)/);
            assert(m != null);
            setArg(m[1], false, arg);
        } else if (/^--.+/.test(arg)) {
            const m = arg.match(/^--(.+)/);
            assert(m != null);
            const [, key] = m;
            const next = args[i261 + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i261++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i261++;
            } else {
                setArg(key, get(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i261 + 1] && !/^(-|--)[^-]/.test(args[i261 + 1]) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i261 + 1], arg);
                    i261++;
                } else if (args[i261 + 1] && /^(true|false)$/.test(args[i261 + 1])) {
                    setArg(key, args[i261 + 1] === "true", arg);
                    i261++;
                } else {
                    setArg(key, get(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv1._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv1._.push(...args.slice(i261 + 1));
                break;
            }
        }
    }
    for (const key2 of Object.keys(defaults3)){
        if (!hasKey(argv1, key2.split("."))) {
            setKey(argv1, key2.split("."), defaults3[key2]);
            if (aliases[key2]) {
                for (const x of aliases[key2]){
                    setKey(argv1, x.split("."), defaults3[key2]);
                }
            }
        }
    }
    if (doubleDash) {
        argv1["--"] = [];
        for (const key of notFlags){
            argv1["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv1._.push(key);
        }
    }
    return argv1;
}
function getOptions() {
    const args = parse(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]
    ));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path3) {
    if (typeof path3 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path3)}`);
    }
}
function isPosixPathSeparator(code28) {
    return code28 === 47;
}
function isPathSeparator(code29) {
    return isPosixPathSeparator(code29) || code29 === 92;
}
function isWindowsDeviceRoot(code30) {
    return code30 >= 97 && code30 <= 122 || code30 >= 65 && code30 <= 90;
}
function normalizeString(path4, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code31;
    for(let i262 = 0, len = path4.length; i262 <= len; ++i262){
        if (i262 < len) code31 = path4.charCodeAt(i262);
        else if (isPathSeparator1(code31)) break;
        else code31 = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code31)) {
            if (lastSlash === i262 - 1 || dots === 1) {} else if (lastSlash !== i262 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i262;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i262;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path4.slice(lastSlash + 1, i262);
                else res = path4.slice(lastSlash + 1, i262);
                lastSegmentLength = i262 - lastSlash - 1;
            }
            lastSlash = i262;
            dots = 0;
        } else if (code31 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep3, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base28 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base28;
    if (dir === pathObject.root) return dir + base28;
    return dir + sep3 + base28;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string36) {
    return string36.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i263 = pathSegments.length - 1; i263 >= -1; i263--){
        let path5;
        const { Deno  } = globalThis;
        if (i263 >= 0) {
            path5 = pathSegments[i263];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path5 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path5 = Deno.cwd();
            if (path5 === undefined || path5.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path5 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path5);
        const len = path5.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code32 = path5.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code32)) {
                isAbsolute1 = true;
                if (isPathSeparator(path5.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path5.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path5.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path5.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path5.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path5.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code32)) {
                if (path5.charCodeAt(1) === 58) {
                    device = path5.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path5.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code32)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path5.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path6) {
    assertPath(path6);
    const len = path6.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code33 = path6.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code33)) {
            isAbsolute2 = true;
            if (isPathSeparator(path6.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path6.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path6.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path6.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path6.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path6.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code33)) {
            if (path6.charCodeAt(1) === 58) {
                device = path6.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path6.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code33)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path6.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path7) {
    assertPath(path7);
    const len = path7.length;
    if (len === 0) return false;
    const code34 = path7.charCodeAt(0);
    if (isPathSeparator(code34)) {
        return true;
    } else if (isWindowsDeviceRoot(code34)) {
        if (len > 2 && path7.charCodeAt(1) === 58) {
            if (isPathSeparator(path7.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i264 = 0; i264 < pathsCount; ++i264){
        const path8 = paths[i264];
        assertPath(path8);
        if (path8.length > 0) {
            if (joined === undefined) joined = firstPart = path8;
            else joined += `\\${path8}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i265 = 0;
    for(; i265 <= length; ++i265){
        if (i265 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i265) === 92) {
                    return toOrig.slice(toStart + i265 + 1);
                } else if (i265 === 2) {
                    return toOrig.slice(toStart + i265);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i265) === 92) {
                    lastCommonSep = i265;
                } else if (i265 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i265);
        const toCode = to.charCodeAt(toStart + i265);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i265;
    }
    if (i265 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i265 = fromStart + lastCommonSep + 1; i265 <= fromEnd; ++i265){
        if (i265 === fromEnd || from.charCodeAt(i265) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path9) {
    if (typeof path9 !== "string") return path9;
    if (path9.length === 0) return "";
    const resolvedPath = resolve(path9);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code35 = resolvedPath.charCodeAt(2);
                if (code35 !== 63 && code35 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path9;
}
function dirname(path10) {
    assertPath(path10);
    const len = path10.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code36 = path10.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code36)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path10.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path10.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path10.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path10.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path10;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code36)) {
            if (path10.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path10.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code36)) {
        return path10;
    }
    for(let i266 = len - 1; i266 >= offset; --i266){
        if (isPathSeparator(path10.charCodeAt(i266))) {
            if (!matchedSlash) {
                end = i266;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path10.slice(0, end);
}
function basename(path11, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path11);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i267;
    if (path11.length >= 2) {
        const drive = path11.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path11.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path11.length) {
        if (ext.length === path11.length && ext === path11) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i267 = path11.length - 1; i267 >= start; --i267){
            const code37 = path11.charCodeAt(i267);
            if (isPathSeparator(code37)) {
                if (!matchedSlash) {
                    start = i267 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i267 + 1;
                }
                if (extIdx >= 0) {
                    if (code37 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i267;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path11.length;
        return path11.slice(start, end);
    } else {
        for(i267 = path11.length - 1; i267 >= start; --i267){
            if (isPathSeparator(path11.charCodeAt(i267))) {
                if (!matchedSlash) {
                    start = i267 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i267 + 1;
            }
        }
        if (end === -1) return "";
        return path11.slice(start, end);
    }
}
function extname(path12) {
    assertPath(path12);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path12.length >= 2 && path12.charCodeAt(1) === 58 && isWindowsDeviceRoot(path12.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i268 = path12.length - 1; i268 >= start; --i268){
        const code38 = path12.charCodeAt(i268);
        if (isPathSeparator(code38)) {
            if (!matchedSlash) {
                startPart = i268 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i268 + 1;
        }
        if (code38 === 46) {
            if (startDot === -1) startDot = i268;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path12.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse1(path13) {
    assertPath(path13);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path13.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code39 = path13.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code39)) {
            rootEnd = 1;
            if (isPathSeparator(path13.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path13.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path13.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path13.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code39)) {
            if (path13.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path13.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path13;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path13;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code39)) {
        ret.root = ret.dir = path13;
        return ret;
    }
    if (rootEnd > 0) ret.root = path13.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i269 = path13.length - 1;
    let preDotState = 0;
    for(; i269 >= rootEnd; --i269){
        code39 = path13.charCodeAt(i269);
        if (isPathSeparator(code39)) {
            if (!matchedSlash) {
                startPart = i269 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i269 + 1;
        }
        if (code39 === 46) {
            if (startDot === -1) startDot = i269;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path13.slice(startPart, end);
        }
    } else {
        ret.name = path13.slice(startPart, startDot);
        ret.base = path13.slice(startPart, end);
        ret.ext = path13.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path13.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path14 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path14 = `\\\\${url.hostname}${path14}`;
    }
    return path14;
}
function toFileUrl(path15) {
    if (!isAbsolute(path15)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path15.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod6 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i270 = pathSegments.length - 1; i270 >= -1 && !resolvedAbsolute; i270--){
        let path16;
        if (i270 >= 0) path16 = pathSegments[i270];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path16 = Deno.cwd();
        }
        assertPath(path16);
        if (path16.length === 0) {
            continue;
        }
        resolvedPath = `${path16}/${resolvedPath}`;
        resolvedAbsolute = path16.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path17) {
    assertPath(path17);
    if (path17.length === 0) return ".";
    const isAbsolute1 = path17.charCodeAt(0) === 47;
    const trailingSeparator = path17.charCodeAt(path17.length - 1) === 47;
    path17 = normalizeString(path17, !isAbsolute1, "/", isPosixPathSeparator);
    if (path17.length === 0 && !isAbsolute1) path17 = ".";
    if (path17.length > 0 && trailingSeparator) path17 += "/";
    if (isAbsolute1) return `/${path17}`;
    return path17;
}
function isAbsolute1(path18) {
    assertPath(path18);
    return path18.length > 0 && path18.charCodeAt(0) === 47;
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i271 = 0, len = paths.length; i271 < len; ++i271){
        const path19 = paths[i271];
        assertPath(path19);
        if (path19.length > 0) {
            if (!joined) joined = path19;
            else joined += `/${path19}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i272 = 0;
    for(; i272 <= length; ++i272){
        if (i272 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i272) === 47) {
                    return to.slice(toStart + i272 + 1);
                } else if (i272 === 0) {
                    return to.slice(toStart + i272);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i272) === 47) {
                    lastCommonSep = i272;
                } else if (i272 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i272);
        const toCode = to.charCodeAt(toStart + i272);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i272;
    }
    let out = "";
    for(i272 = fromStart + lastCommonSep + 1; i272 <= fromEnd; ++i272){
        if (i272 === fromEnd || from.charCodeAt(i272) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path20) {
    return path20;
}
function dirname1(path21) {
    assertPath(path21);
    if (path21.length === 0) return ".";
    const hasRoot = path21.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i273 = path21.length - 1; i273 >= 1; --i273){
        if (path21.charCodeAt(i273) === 47) {
            if (!matchedSlash) {
                end = i273;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path21.slice(0, end);
}
function basename1(path22, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path22);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i274;
    if (ext !== undefined && ext.length > 0 && ext.length <= path22.length) {
        if (ext.length === path22.length && ext === path22) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i274 = path22.length - 1; i274 >= 0; --i274){
            const code40 = path22.charCodeAt(i274);
            if (code40 === 47) {
                if (!matchedSlash) {
                    start = i274 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i274 + 1;
                }
                if (extIdx >= 0) {
                    if (code40 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i274;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path22.length;
        return path22.slice(start, end);
    } else {
        for(i274 = path22.length - 1; i274 >= 0; --i274){
            if (path22.charCodeAt(i274) === 47) {
                if (!matchedSlash) {
                    start = i274 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i274 + 1;
            }
        }
        if (end === -1) return "";
        return path22.slice(start, end);
    }
}
function extname1(path23) {
    assertPath(path23);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i275 = path23.length - 1; i275 >= 0; --i275){
        const code41 = path23.charCodeAt(i275);
        if (code41 === 47) {
            if (!matchedSlash) {
                startPart = i275 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i275 + 1;
        }
        if (code41 === 46) {
            if (startDot === -1) startDot = i275;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path23.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse2(path24) {
    assertPath(path24);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path24.length === 0) return ret;
    const isAbsolute2 = path24.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i276 = path24.length - 1;
    let preDotState = 0;
    for(; i276 >= start; --i276){
        const code42 = path24.charCodeAt(i276);
        if (code42 === 47) {
            if (!matchedSlash) {
                startPart = i276 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i276 + 1;
        }
        if (code42 === 46) {
            if (startDot === -1) startDot = i276;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path24.slice(1, end);
            } else {
                ret.base = ret.name = path24.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path24.slice(1, startDot);
            ret.base = path24.slice(1, end);
        } else {
            ret.name = path24.slice(startPart, startDot);
            ret.base = path24.slice(startPart, end);
        }
        ret.ext = path24.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path24.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path25) {
    if (!isAbsolute1(path25)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path25.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod7 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod6 : mod7;
const { join: join3 , normalize: normalize2  } = path;
const path1 = isWindows ? mod6 : mod7;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
const nextTick1 = nextTick2;
const env = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject())
    ,
    getOwnPropertyDescriptor: (_target, name56)=>{
        const e = Deno.env.toObject();
        if (name56 in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name56 === "string") {
                o.value = e[name56];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.11.1";
const versions = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1000000 - sec * 1000000000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state160 = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state160 && state160.autoDestroy && state160.emitClose && state160.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick2(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick2(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name57)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name57, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort)
        );
    }
    return stream;
}
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self, err1, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick2(emitErrorCloseNT, self, err);
        } else {
            nextTick2(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err1 || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onDestroy, null);
                }, function(err) {
                    nextTick2(onDestroy, err);
                });
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}
function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self.emit("error", err);
}
function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick2(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick2(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick2(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onConstruct, null);
                }, function(err) {
                    nextTick2(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default4 = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state161 = wState || rState;
    return !!(stream.destroyed || state161?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable1, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer1) {
        return new Readable1({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable1({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error, cb) {
        close(error).then(()=>nextTick1(cb, error)
        , (e)=>nextTick1(cb, e || error)
        );
    };
    async function close(error) {
        const hadError = error !== undefined && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value  } = await iterator.return();
            await value;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state162, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name58 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name58, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state162.objectMode);
}
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented1) {
    NotImplemented1[NotImplemented1["ascii"] = 0] = "ascii";
    NotImplemented1[NotImplemented1["latin1"] = 1] = "latin1";
    NotImplemented1[NotImplemented1["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 127) return 0;
    else if (__byte >> 5 === 6) return 2;
    else if (__byte >> 4 === 14) return 3;
    else if (__byte >> 3 === 30) return 4;
    return __byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i277) {
    let j = buf.length - 1;
    if (j < i277) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i277 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i277 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p32 = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p32, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p32, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i278) {
    const total = utf8CheckIncomplete(this, buf, i278);
    if (!this.lastNeed) return buf.toString("utf8", i278);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i278, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i279;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i279 = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i279 = 0;
    }
    if (i279 < buf.length) return r ? r + this.text(buf, i279) : this.text(buf, i279);
    return r || "";
}
function base64Text(buf, i280) {
    const n = (buf.length - i280) % 3;
    if (n === 0) return buf.toString("base64", i280);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i280, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    encoding;
    lastChar;
    lastNeed = 0;
    lastTotal = 0;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastChar = Buffer1.allocUnsafe(nb);
    }
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p33 = this.head;
        let ret = "" + p33.data;
        while(p33 = p33.next){
            ret += s + p33.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer1.alloc(0);
        }
        const ret = Buffer1.allocUnsafe(n >>> 0);
        let p34 = this.head;
        let i281 = 0;
        while(p34){
            ret.set(p34.data, i281);
            i281 += p34.data.length;
            p34 = p34.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data17 = this.head.data;
        if (n < data17.length) {
            const slice = data17.slice(0, n);
            this.head.data = data17.slice(n);
            return slice;
        }
        if (n === data17.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p35 = this.head; p35; p35 = p35.next){
            yield p35.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p36 = this.head;
        let c = 0;
        do {
            const str = p36.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p36.next) {
                        this.head = p36.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p36;
                    p36.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p36 = p36.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer1.allocUnsafe(n);
        const retLen = n;
        let p37 = this.head;
        let c = 0;
        do {
            const buf = p37.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p37.next) {
                        this.head = p37.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p37;
                    p37.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p37 = p37.next)
        this.length -= c;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default4;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default4.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default4.destroy;
Readable.prototype._undestroy = __default4.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state163 = stream._readableState;
    let err;
    if (!state163.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state163.defaultEncoding;
            if (state163.encoding !== encoding) {
                if (addToFront && state163.encoding) {
                    chunk = Buffer1.from(chunk, encoding).toString(state163.encoding);
                } else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy1(stream, err);
    } else if (chunk === null) {
        state163.reading = false;
        onEofChunk(stream, state163);
    } else if (state163.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state163.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state163, chunk, true);
            }
        } else if (state163.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state163.destroyed || state163.errored) {
            return false;
        } else {
            state163.reading = false;
            if (state163.decoder && !encoding) {
                chunk = state163.decoder.write(chunk);
                if (state163.objectMode || chunk.length !== 0) {
                    addChunk(stream, state163, chunk, false);
                } else {
                    maybeReadMore(stream, state163);
                }
            } else {
                addChunk(stream, state163, chunk, false);
            }
        }
    } else if (!addToFront) {
        state163.reading = false;
        maybeReadMore(stream, state163);
    }
    return !state163.ended && (state163.length < state163.highWaterMark || state163.length === 0);
}
function addChunk(stream, state164, chunk, addToFront) {
    if (state164.flowing && state164.length === 0 && !state164.sync && stream.listenerCount("data") > 0) {
        if (state164.multiAwaitDrain) {
            state164.awaitDrainWriters.clear();
        } else {
            state164.awaitDrainWriters = null;
        }
        state164.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state164.length += state164.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state164.buffer.unshift(chunk);
        } else {
            state164.buffer.push(chunk);
        }
        if (state164.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state164);
}
Readable.prototype.isPaused = function() {
    const state165 = this._readableState;
    return state165[kPaused] === true || state165.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content21 = "";
    for (const data18 of buffer){
        content21 += decoder.write(data18);
    }
    buffer.clear();
    if (content21 !== "") {
        buffer.push(content21);
    }
    this._readableState.length = content21.length;
    return this;
};
const MAX_HWM = 1073741824;
function computeNewHighWaterMark(n) {
    if (n >= 1073741824) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state166) {
    if (n <= 0 || state166.length === 0 && state166.ended) {
        return 0;
    }
    if (state166.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state166.flowing && state166.length) {
            return state166.buffer.first().length;
        }
        return state166.length;
    }
    if (n <= state166.length) {
        return n;
    }
    return state166.ended ? state166.length : 0;
}
Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state167 = this._readableState;
    const nOrig = n;
    if (n > state167.highWaterMark) {
        state167.highWaterMark = computeNewHighWaterMark(n);
    }
    if (n !== 0) {
        state167.emittedReadable = false;
    }
    if (n === 0 && state167.needReadable && ((state167.highWaterMark !== 0 ? state167.length >= state167.highWaterMark : state167.length > 0) || state167.ended)) {
        debug("read: emitReadable", state167.length, state167.ended);
        if (state167.length === 0 && state167.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n = howMuchToRead(n, state167);
    if (n === 0 && state167.ended) {
        if (state167.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state167.needReadable;
    debug("need readable", doRead);
    if (state167.length === 0 || state167.length - n < state167.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state167.ended || state167.reading || state167.destroyed || state167.errored || !state167.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state167.reading = true;
        state167.sync = true;
        if (state167.length === 0) {
            state167.needReadable = true;
        }
        this._read(state167.highWaterMark);
        state167.sync = false;
        if (!state167.reading) {
            n = howMuchToRead(nOrig, state167);
        }
    }
    let ret;
    if (n > 0) {
        ret = fromList(n, state167);
    } else {
        ret = null;
    }
    if (ret === null) {
        state167.needReadable = state167.length <= state167.highWaterMark;
        n = 0;
    } else {
        state167.length -= n;
        if (state167.multiAwaitDrain) {
            state167.awaitDrainWriters.clear();
        } else {
            state167.awaitDrainWriters = null;
        }
    }
    if (state167.length === 0) {
        if (!state167.ended) {
            state167.needReadable = true;
        }
        if (nOrig !== n && state167.ended) {
            endReadable(this);
        }
    }
    if (ret !== null) {
        state167.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk(stream, state168) {
    debug("onEofChunk");
    if (state168.ended) return;
    if (state168.decoder) {
        const chunk = state168.decoder.end();
        if (chunk && chunk.length) {
            state168.buffer.push(chunk);
            state168.length += state168.objectMode ? 1 : chunk.length;
        }
    }
    state168.ended = true;
    if (state168.sync) {
        emitReadable(stream);
    } else {
        state168.needReadable = false;
        state168.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state169 = stream._readableState;
    debug("emitReadable", state169.needReadable, state169.emittedReadable);
    state169.needReadable = false;
    if (!state169.emittedReadable) {
        debug("emitReadable", state169.flowing);
        state169.emittedReadable = true;
        nextTick2(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state170 = stream._readableState;
    debug("emitReadable_", state170.destroyed, state170.length, state170.ended);
    if (!state170.destroyed && !state170.errored && (state170.length || state170.ended)) {
        stream.emit("readable");
        state170.emittedReadable = false;
    }
    state170.needReadable = !state170.flowing && !state170.ended && state170.length <= state170.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state171) {
    if (!state171.readingMore && state171.constructed) {
        state171.readingMore = true;
        nextTick2(maybeReadMore_, stream, state171);
    }
}
function maybeReadMore_(stream, state172) {
    while(!state172.reading && !state172.ended && (state172.length < state172.highWaterMark || state172.flowing && state172.length === 0)){
        const len = state172.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state172.length) {
            break;
        }
    }
    state172.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state173 = this._readableState;
    if (state173.pipes.length === 1) {
        if (!state173.multiAwaitDrain) {
            state173.multiAwaitDrain = true;
            state173.awaitDrainWriters = new Set(state173.awaitDrainWriters ? [
                state173.awaitDrainWriters
            ] : []);
        }
    }
    state173.pipes.push(dest);
    debug("pipe count=%d opts=%j", state173.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state173.endEmitted) {
        nextTick2(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state173.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state173.pipes.length === 1 && state173.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state173.awaitDrainWriters = dest;
                state173.multiAwaitDrain = false;
            } else if (state173.pipes.length > 1 && state173.pipes.includes(dest)) {
                debug("false write response, pause", state173.awaitDrainWriters.size);
                state173.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state173.flowing) {
            pause();
        }
    } else if (!state173.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state174 = src._readableState;
        if (state174.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state174.awaitDrainWriters = null;
        } else if (state174.multiAwaitDrain) {
            debug("pipeOnDrain", state174.awaitDrainWriters.size);
            state174.awaitDrainWriters.delete(dest);
        }
        if ((!state174.awaitDrainWriters || state174.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state174.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state175 = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state175.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state175.pipes;
        state175.pipes = [];
        this.pause();
        for(let i282 = 0; i282 < dests.length; i282++){
            dests[i282].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state175.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state175.pipes.splice(index, 1);
    if (state175.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state176 = this._readableState;
    if (ev === "data") {
        state176.readableListening = this.listenerCount("readable") > 0;
        if (state176.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state176.endEmitted && !state176.readableListening) {
            state176.readableListening = state176.needReadable = true;
            state176.flowing = false;
            state176.emittedReadable = false;
            debug("on readable", state176.length, state176.reading);
            if (state176.length) {
                emitReadable(this);
            } else if (!state176.reading) {
                nextTick2(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    const state177 = self._readableState;
    state177.readableListening = self.listenerCount("readable") > 0;
    if (state177.resumeScheduled && state177[kPaused] === false) {
        state177.flowing = true;
    } else if (self.listenerCount("data") > 0) {
        self.resume();
    } else if (!state177.readableListening) {
        state177.flowing = null;
    }
}
function nReadingNextTick(self) {
    debug("readable nexttick read 0");
    self.read(0);
}
Readable.prototype.resume = function() {
    const state178 = this._readableState;
    if (!state178.flowing) {
        debug("resume");
        state178.flowing = !state178.readableListening;
        resume(this, state178);
    }
    state178[kPaused] = false;
    return this;
};
function resume(stream, state179) {
    if (!state179.resumeScheduled) {
        state179.resumeScheduled = true;
        nextTick2(resume_, stream, state179);
    }
}
function resume_(stream, state180) {
    debug("resume", state180.reading);
    if (!state180.reading) {
        stream.read(0);
    }
    state180.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state180.flowing && !state180.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state181 = stream._readableState;
    debug("flow", state181.flowing);
    while(state181.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy1(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i283 = streamKeys[j];
        if (this[i283] === undefined && typeof stream[i283] === "function") {
            this[i283] = stream[i283].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve8) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve8;
        }
    }
    const state182 = stream._readableState;
    let error = state182.errored;
    let errorEmitted = state182.errorEmitted;
    let endEmitted = state182.endEmitted;
    let closeEmitted = state182.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default4.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state182.autoDestroy || !endEmitted) {
                __default4.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state183) {
            if (this._readableState) {
                this._readableState.flowing = state183;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n, state184) {
    if (state184.length === 0) {
        return null;
    }
    let ret;
    if (state184.objectMode) {
        ret = state184.buffer.shift();
    } else if (!n || n >= state184.length) {
        if (state184.decoder) {
            ret = state184.buffer.join("");
        } else if (state184.buffer.length === 1) {
            ret = state184.buffer.first();
        } else {
            ret = state184.buffer.concat(state184.length);
        }
        state184.buffer.clear();
    } else {
        ret = state184.buffer.consume(n, state184.decoder);
    }
    return ret;
}
function endReadable(stream) {
    const state185 = stream._readableState;
    debug("endReadable", state185.endEmitted);
    if (!state185.endEmitted) {
        state185.ended = true;
        nextTick2(endReadableNT, state185, stream);
    }
}
function endReadableNT(state186, stream) {
    debug("endReadableNT", state186.endEmitted, state186.length);
    if (!state186.errorEmitted && !state186.closeEmitted && !state186.endEmitted && state186.length === 0) {
        state186.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick2(endWritableNT, stream);
        } else if (state186.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default4.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default4;
function isDuplexStream(maybe_duplex) {
    const isReadable2 = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable2 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state187) {
    state187.buffered = [];
    state187.bufferedIndex = 0;
    state187.allBuffers = true;
    state187.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default4.construct(this, ()=>{
        const state188 = this._writableState;
        if (!state188.writing) {
            clearBuffer(this, state188);
        }
        finishMaybe(this, state188);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state189 = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state189.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state189.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer1.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state189.objectMode) {
        if (typeof chunk === "string") {
            if (state189.decodeStrings !== false) {
                chunk = Buffer1.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state189.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state189.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        nextTick2(cb, err);
        errorOrDestroy2(stream, err, true);
        return err;
    }
    state189.pendingcb++;
    return writeOrBuffer(stream, state189, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state190 = this._writableState;
    if (state190.corked) {
        state190.corked--;
        if (!state190.writing) {
            clearBuffer(this, state190);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state191, chunk, encoding, callback) {
    const len = state191.objectMode ? 1 : chunk.length;
    state191.length += len;
    const ret = state191.length < state191.highWaterMark;
    if (!ret) {
        state191.needDrain = true;
    }
    if (state191.writing || state191.corked || state191.errored || !state191.constructed) {
        state191.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state191.allBuffers && encoding !== "buffer") {
            state191.allBuffers = false;
        }
        if (state191.allNoop && callback !== nop2) {
            state191.allNoop = false;
        }
    } else {
        state191.writelen = len;
        state191.writecb = callback;
        state191.writing = true;
        state191.sync = true;
        stream._write(chunk, encoding, state191.onwrite);
        state191.sync = false;
    }
    return ret && !state191.errored && !state191.destroyed;
}
function doWrite(stream, state192, writev, len, chunk, encoding, cb) {
    state192.writelen = len;
    state192.writecb = cb;
    state192.writing = true;
    state192.sync = true;
    if (state192.destroyed) {
        state192.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev) {
        stream._writev(chunk, state192.onwrite);
    } else {
        stream._write(chunk, encoding, state192.onwrite);
    }
    state192.sync = false;
}
function onwriteError(stream, state193, er, cb) {
    --state193.pendingcb;
    cb(er);
    errorBuffer(state193);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state194 = stream._writableState;
    const sync = state194.sync;
    const cb = state194.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state194.writing = false;
    state194.writecb = null;
    state194.length -= state194.writelen;
    state194.writelen = 0;
    if (er) {
        er.stack;
        if (!state194.errored) {
            state194.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick2(onwriteError, stream, state194, er, cb);
        } else {
            onwriteError(stream, state194, er, cb);
        }
    } else {
        if (state194.buffered.length > state194.bufferedIndex) {
            clearBuffer(stream, state194);
        }
        if (sync) {
            if (state194.afterWriteTickInfo !== null && state194.afterWriteTickInfo.cb === cb) {
                state194.afterWriteTickInfo.count++;
            } else {
                state194.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state: state194
                };
                nextTick2(afterWriteTick, state194.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state194, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state: state195 , count , cb  }) {
    state195.afterWriteTickInfo = null;
    return afterWrite(stream, state195, count, cb);
}
function afterWrite(stream, state196, count, cb) {
    const needDrain = !state196.ending && !stream.destroyed && state196.length === 0 && state196.needDrain;
    if (needDrain) {
        state196.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state196.pendingcb--;
        cb();
    }
    if (state196.destroyed) {
        errorBuffer(state196);
    }
    finishMaybe(stream, state196);
}
function errorBuffer(state197) {
    if (state197.writing) {
        return;
    }
    for(let n = state197.bufferedIndex; n < state197.buffered.length; ++n){
        const { chunk , callback  } = state197.buffered[n];
        const len = state197.objectMode ? 1 : chunk.length;
        state197.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state197[kOnFinished].splice(0);
    for(let i284 = 0; i284 < onfinishCallbacks.length; i284++){
        onfinishCallbacks[i284](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state197);
}
function clearBuffer(stream, state198) {
    if (state198.corked || state198.bufferProcessing || state198.destroyed || !state198.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state198;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i285 = bufferedIndex;
    state198.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state198.pendingcb -= bufferedLength - 1;
        const callback = state198.allNoop ? nop2 : (err)=>{
            for(let n = i285; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state198.allNoop && i285 === 0 ? buffered : buffered.slice(i285);
        chunks.allBuffers = state198.allBuffers;
        doWrite(stream, state198, true, state198.length, chunks, "", callback);
        resetBuffer(state198);
    } else {
        do {
            const { chunk , encoding , callback  } = buffered[i285];
            buffered[i285++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state198, false, len, chunk, encoding, callback);
        }while (i285 < buffered.length && !state198.writing)
        if (i285 === buffered.length) {
            resetBuffer(state198);
        } else if (i285 > 256) {
            buffered.splice(0, i285);
            state198.bufferedIndex = 0;
        } else {
            state198.bufferedIndex = i285;
        }
    }
    state198.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state199 = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }
    if (state199.corked) {
        state199.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state199.errored && !state199.ending) {
        state199.ending = true;
        finishMaybe(this, state199, true);
        state199.ended = true;
    } else if (state199.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state199.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err || state199.finished) {
            nextTick1(cb, err);
        } else {
            state199[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state200) {
    return state200.ending && state200.constructed && state200.length === 0 && !state200.errored && state200.buffered.length === 0 && !state200.finished && !state200.writing && !state200.errorEmitted && !state200.closeEmitted;
}
function callFinal(stream, state201) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state201.pendingcb--;
        if (err) {
            const onfinishCallbacks = state201[kOnFinished].splice(0);
            for(let i286 = 0; i286 < onfinishCallbacks.length; i286++){
                onfinishCallbacks[i286](err);
            }
            errorOrDestroy2(stream, err, state201.sync);
        } else if (needFinish(state201)) {
            state201.prefinished = true;
            stream.emit("prefinish");
            state201.pendingcb++;
            nextTick2(finish, stream, state201);
        }
    }
    state201.sync = true;
    state201.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onFinish, null);
                }, function(err) {
                    nextTick2(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state201, err);
    }
    state201.sync = false;
}
function prefinish(stream, state202) {
    if (!state202.prefinished && !state202.finalCalled) {
        if (typeof stream._final === "function" && !state202.destroyed) {
            state202.finalCalled = true;
            callFinal(stream, state202);
        } else {
            state202.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state203, sync) {
    if (needFinish(state203)) {
        prefinish(stream, state203);
        if (state203.pendingcb === 0 && needFinish(state203)) {
            state203.pendingcb++;
            if (sync) {
                nextTick2(finish, stream, state203);
            } else {
                finish(stream, state203);
            }
        }
    }
}
function finish(stream, state204) {
    state204.pendingcb--;
    state204.finished = true;
    const onfinishCallbacks = state204[kOnFinished].splice(0);
    for(let i287 = 0; i287 < onfinishCallbacks.length; i287++){
        onfinishCallbacks[i287]();
    }
    stream.emit("finish");
    if (state204.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy1 = __default4.destroy;
Writable.prototype.destroy = function(err, cb) {
    const state205 = this._writableState;
    if (!state205.destroyed && (state205.bufferedIndex < state205.buffered.length || state205[kOnFinished].length)) {
        nextTick1(errorBuffer, state205);
    }
    destroy1.call(this, err, cb);
    return this;
};
Writable.prototype._undestroy = __default4.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name59) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write , final: __final1 , destroy: destroy2  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write,
                final: __final1,
                destroy: destroy2
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err)=>{
                destroyer(d, err);
            });
            return d = new Duplexify({
                objectMode: true,
                readable: false,
                write,
                final (cb) {
                    __final1(async ()=>{
                        try {
                            await promise;
                            nextTick1(cb, null);
                        } catch (err) {
                            nextTick1(cb, err);
                        }
                    });
                },
                destroy: destroy2
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name59, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then = body?.then;
    if (typeof then === "function") {
        let d;
        then.call(body, (val)=>{
            if (val != null) {
                d.push(val);
            }
            d.push(null);
        }, (err)=>{
            destroyer(d, err);
        });
        return d = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name59, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve: resolve9  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick2(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve: resolve9  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve9;
            resolve9 = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve9;
            resolve9 = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify(pair3) {
    const r = pair3.readable && typeof pair3.readable.read !== "function" ? Readable.wrap(pair3.readable) : pair3.readable;
    const w = pair3.writable;
    let readable = !!isReadable1(r);
    let writable = !!isWritable1(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w, (err)=>{
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r, (err)=>{
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };
    return d;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data19)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data19 != null) {
                this.push(data19);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data20)=>{
                        if (called) {
                            return;
                        }
                        if (data20 != null) {
                            this.push(data20);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick2(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick2(cb, err);
                        } else {
                            nextTick2(()=>this.destroy(err)
                            );
                        }
                    });
                }
            } catch (err) {
                nextTick2(()=>this.destroy(err)
                );
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick1(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err)=>{
                    nextTick1(callback, err);
                });
            }
        } catch (err) {
            nextTick1(callback, err);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished2 = false;
    stream.on("close", ()=>{
        finished2 = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished2 = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished2) return;
        finished2 = true;
        __default4.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish3) {
    let error;
    let onresolve = null;
    const resume1 = (err)=>{
        if (err) {
            error = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve10, reject)=>{
            if (error) {
                reject(error);
            } else {
                onresolve = ()=>{
                    if (error) {
                        reject(error);
                    } else {
                        resolve10();
                    }
                };
            }
        })
    ;
    writable.on("drain", resume1);
    const cleanup = eos(writable, {
        readable: false
    }, resume1);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish3();
    } catch (err) {
        finish3(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume1);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish4(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final2) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
        }
        if (!error && !__final2) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final2) {
            callback(error, value);
        }
    }
    let ret;
    for(let i288 = 0; i288 < streams.length; i288++){
        const stream = streams[i288];
        const reading = i288 < streams.length - 1;
        const writing = i288 > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish4));
        }
        if (i288 === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i288 - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish4);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer1(ret, false, true, finish4));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret.on("end", ()=>stream.end()
                    );
                }
            } else {
                ret = makeAsyncIterable(ret);
                finishCount++;
                pump(ret, stream, finish4);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick2(abort);
    }
    return ret;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };
    return d;
}
function pipeline1(...streams) {
    return new Promise((resolve11, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve11(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve12, reject)=>{
        eos(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve12();
            }
        });
    });
}
const __default5 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default5;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default5.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default5.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
function createWritableStdioStream(writer, name60) {
    const stream = new Writable({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name60} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer1.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close")
                );
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close()
    );
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Readable({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p38 = Buffer1.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p38).then((length)=>{
            this.push(length === null ? null : p38.slice(0, length));
        }, (error)=>{
            this.destroy(error);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close()
);
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    setRaw?.(Deno.stdin?.rid, enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants;
(function(constants3) {
    constants3[constants3["kInit"] = 0] = "kInit";
    constants3[constants3["kBefore"] = 1] = "kBefore";
    constants3[constants3["kAfter"] = 2] = "kAfter";
    constants3[constants3["kDestroy"] = 3] = "kDestroy";
    constants3[constants3["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants3[constants3["kTotals"] = 5] = "kTotals";
    constants3[constants3["kCheck"] = 6] = "kCheck";
    constants3[constants3["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants3[constants3["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants3[constants3["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants3[constants3["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants3[constants3["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants3[constants3["kStackLength"] = 12] = "kStackLength";
})(constants || (constants = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants).length);
function newAsyncId() {
    return ++asyncIdFields[constants.kAsyncIdCounter];
}
var UidFields;
(function(UidFields1) {
    UidFields1[UidFields1["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields1[UidFields1["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields1[UidFields1["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields1[UidFields1["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields1[UidFields1["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType1) {
    providerType1[providerType1["NONE"] = 0] = "NONE";
    providerType1[providerType1["GETADDRINFOREQWRAP"] = 1] = "GETADDRINFOREQWRAP";
    providerType1[providerType1["PIPECONNECTWRAP"] = 2] = "PIPECONNECTWRAP";
    providerType1[providerType1["PIPESERVERWRAP"] = 3] = "PIPESERVERWRAP";
    providerType1[providerType1["PIPEWRAP"] = 4] = "PIPEWRAP";
    providerType1[providerType1["SHUTDOWNWRAP"] = 5] = "SHUTDOWNWRAP";
    providerType1[providerType1["TCPCONNECTWRAP"] = 6] = "TCPCONNECTWRAP";
    providerType1[providerType1["TCPSERVERWRAP"] = 7] = "TCPSERVERWRAP";
    providerType1[providerType1["TCPWRAP"] = 8] = "TCPWRAP";
    providerType1[providerType1["WRITEWRAP"] = 9] = "WRITEWRAP";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod8 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod9 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
const ARES_AI_CANONNAME = 1 << 0;
const ARES_AI_NUMERICHOST = 1 << 1;
const ARES_AI_PASSIVE = 1 << 2;
const ARES_AI_NUMERICSERV = 1 << 3;
const AI_V4MAPPED = 1 << 4;
const AI_ALL = 1 << 5;
const AI_ADDRCONFIG = 1 << 6;
const ARES_AI_NOSORT = 1 << 7;
const ARES_AI_ENVHOSTS = 1 << 8;
class GetAddrInfoReqWrap extends AsyncWrap {
    callback;
    family;
    hostname;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname, family, _hints, verbatim) {
    (async ()=>{
        const addresses = [];
        const recordTypes = [];
        if (family === 0 || family === 4) {
            recordTypes.push("A");
        }
        if (family === 0 || family === 6) {
            recordTypes.push("AAAA");
        }
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record)
                );
            })
        ));
        const error = addresses.length ? null : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        req.oncomplete(error, addresses);
    })();
}
const mod10 = {
    ARES_AI_CANONNAME: ARES_AI_CANONNAME,
    ARES_AI_NUMERICHOST: ARES_AI_NUMERICHOST,
    ARES_AI_PASSIVE: ARES_AI_PASSIVE,
    ARES_AI_NUMERICSERV: ARES_AI_NUMERICSERV,
    AI_V4MAPPED: AI_V4MAPPED,
    AI_ALL: AI_ALL,
    AI_ADDRCONFIG: AI_ADDRCONFIG,
    ARES_AI_NOSORT: ARES_AI_NOSORT,
    ARES_AI_ENVHOSTS: ARES_AI_ENVHOSTS,
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo
};
const mod11 = {};
const mod12 = {};
const mod13 = {};
const mod14 = {};
const mod15 = {};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    async close(cb = ()=>{}) {
        await this._onClose();
        nextTick2(cb);
    }
    ref() {
        notImplemented();
    }
    unref() {
        notImplemented();
    }
    async _onClose() {}
}
var StreamBaseStateFields;
(function(StreamBaseStateFields1) {
    StreamBaseStateFields1[StreamBaseStateFields1["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields1[StreamBaseStateFields1["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields1[StreamBaseStateFields1["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields1[StreamBaseStateFields1["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields1[StreamBaseStateFields1["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    #currentReads = new Set();
    #currentWrites = new Set();
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise)
            , ()=>this.#currentReads.delete(readPromise)
            );
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        (async ()=>{
            const status = await this._onClose();
            try {
                req.oncomplete(status);
            } catch  {}
        })();
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented();
    }
    writeBuffer(req, data21) {
        const currentWrite = this.#write(req, data21);
        this.#currentWrites.add(currentWrite);
        currentWrite.then(()=>this.#currentWrites.delete(currentWrite)
        , ()=>this.#currentWrites.delete(currentWrite)
        );
        return 0;
    }
    writev(_req, _chunks, _allBuffers) {
        notImplemented();
    }
    writeAsciiString(req, data22) {
        const buffer = new TextEncoder().encode(data22);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data23) {
        const buffer = new TextEncoder().encode(data23);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented();
    }
    writeLatin1String(req, data24) {
        const buffer = Buffer1.from(data24, "latin1");
        return this.writeBuffer(req, buffer);
    }
    async _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        await Promise.allSettled(this.#currentWrites);
        await Promise.allSettled(this.#currentReads);
        return status;
    }
     #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise)
            , ()=>this.#currentReads.delete(readPromise)
            );
        }
    }
    async #write(req, data25) {
        const { byteLength  } = data25;
        try {
            await writeAll(this[kStreamBaseField], data25);
        } catch  {
            const status = codeMap.get("UNKNOWN");
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod29 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req1, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req1.oncomplete(status, this, req1, readable, writable);
        } catch  {}
        return;
    }
}
var socketType;
(function(socketType2) {
    socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
    socketType2[socketType2["SERVER"] = 1] = "SERVER";
    socketType2[socketType2["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    constructor(type){
        let provider;
        let ipc;
        switch(type){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider);
        this.ipc = ipc;
    }
    bind() {
        notImplemented();
    }
    listen() {
        notImplemented();
    }
    connect(_req, _address, _afterConnect) {
        notImplemented();
    }
    open(_fd) {
        notImplemented();
    }
    setPendingInstances(_instances) {
        notImplemented();
    }
    fchmod() {
        notImplemented();
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants1;
(function(constants4) {
    constants4[constants4["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants4[constants4["SERVER"] = socketType.SERVER] = "SERVER";
    constants4[constants4["IPC"] = socketType.IPC] = "IPC";
    constants4[constants4["UV_READABLE"] = 0] = "UV_READABLE";
    constants4[constants4["UV_WRITABLE"] = 1] = "UV_WRITABLE";
})(constants1 || (constants1 = {}));
const mod30 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants1
};
const mod31 = {};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod37 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod38 = {};
var socketType1;
(function(socketType3) {
    socketType3[socketType3["SOCKET"] = 0] = "SOCKET";
    socketType3[socketType3["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
function _ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants2;
(function(constants5) {
    constants5[constants5["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants5[constants5["SERVER"] = socketType1.SERVER] = "SERVER";
    constants5[constants5["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants2 || (constants2 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4";
        }
    }
    open(_fd) {
        notImplemented();
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req2, address, port) {
        return this.#connect(req2, address, port);
    }
    connect6(req3, address, port) {
        return this.#connect(req3, address, port);
    }
    listen(backlog) {
        this.#backlog = _ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address) === 6 ? "IPv6" : "IPv4";
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented();
    }
     #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
     #connect(req4, address1, port1) {
        this.#remoteAddress = address1;
        this.#remotePort = port1;
        this.#remoteFamily = isIP(address1) === 6 ? "IPv6" : "IPv4";
        const connectOptions = {
            hostname: address1,
            port: port1,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req4.localAddress = localAddr.hostname;
            this.#port = req4.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req4, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req4, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    async _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return await LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod39 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants2,
    TCP: TCP
};
const mod40 = {};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const mod45 = {};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const modules = {
    "async_wrap": mod8,
    buffer: mod5,
    "cares_wrap": mod10,
    config: mod9,
    constants: mod2,
    contextify: mod11,
    credentials: mod13,
    crypto: mod12,
    errors: mod14,
    fs: mod15,
    "fs_dir": mod16,
    "fs_event_wrap": mod17,
    "heap_utils": mod18,
    "http_parser": mod19,
    icu: mod20,
    inspector: mod21,
    "js_stream": mod22,
    messaging: mod23,
    "module_wrap": mod24,
    "native_module": mod25,
    natives: mod26,
    options: mod27,
    os: mod28,
    performance: mod31,
    "pipe_wrap": mod30,
    "process_methods": mod32,
    report: mod33,
    serdes: mod34,
    "signal_wrap": mod35,
    "spawn_sync": mod36,
    "stream_wrap": mod29,
    "string_decoder": mod4,
    symbols: mod37,
    "task_queue": mod38,
    "tcp_wrap": mod39,
    timers: mod40,
    "tls_wrap": mod41,
    "trace_events": mod42,
    "tty_wrap": mod43,
    types: mod,
    "udp_wrap": mod44,
    url: mod45,
    util: mod1,
    uv: mod3,
    v8: mod46,
    worker: mod47,
    zlib: mod48
};
function getBinding(name61) {
    const mod52 = modules[name61];
    if (!mod52) {
        throw new Error(`No such module: ${name61}`);
    }
    return mod52;
}
const notImplementedEvents = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection", 
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>fromFileUrl2(Deno.mainModule)
});
const exit = (code43)=>{
    if (code43 || code43 === 0) {
        if (typeof code43 === "string") {
            const parsedCode = parseInt(code43);
            process2.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process2.exitCode = code43;
        }
    }
    if (!process2._exiting) {
        process2._exiting = true;
        process2.emit("exit", process2.exitCode || 0);
    }
    Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name62, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process2, name62, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type, code44, ctor, detail) {
    assert(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code44 !== undefined) {
        warningErr.code = code44;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process2.emit("warning", warning);
}
function emitWarning(warning, type, code45, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code45 = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code45 = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString(type, "type");
    }
    if (typeof code45 === "function") {
        ctor = code45;
        code45 = undefined;
    } else if (code45 !== undefined) {
        validateString(code45, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type, code45, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process2.noDeprecation) {
            return;
        }
        if (process2.throwDeprecation) {
            return process2.nextTick(()=>{
                throw warning;
            });
        }
    }
    process2.nextTick(doEmitWarning, warning);
}
function hrtime1(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1000000 - sec * 1000000000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime1.bigint = function() {
    const [sec, nano] = hrtime1();
    return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage1() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage1.rss = function() {
    return memoryUsage1().rss;
};
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process2._exiting) {
                process2._exiting = true;
                super.emit("exit", process2.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick2;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
        } else if (event.startsWith("SIG")) {
            addSignalListener(event, listener);
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
        } else if (event.startsWith("SIG")) {
            removeSignalListener(event, listener);
        } else {
            super.off(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    removeAllListeners(eventName) {
        return super.removeAllListeners(eventName);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
            return this;
        }
        super.removeListener("exit", listener);
        return this;
    }
    hrtime = hrtime1;
    memoryUsage = memoryUsage1;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name63) {
        return getBinding(name63);
    }
    umask() {
        return 18;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
}
const process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
const verbose = typeof process2 != "undefined" && /\bparse\b/.test(process2.env.LOG);
let stackIDs = null;
var Safety;
(function(Safety1) {
    Safety1[Safety1["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for(;;){
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for(;;){
            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - Safety.Margin)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + Safety.Margin));
            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
            if (!cursor.parent()) return side < 0 ? 0 : tree.length;
        }
    }
}
class FragmentCursor2 {
    fragments;
    nodeSet;
    i = 0;
    fragment = null;
    safeFrom = -1;
    safeTo = -1;
    trees = [];
    start = [];
    index = [];
    nextStart;
    constructor(fragments, nodeSet){
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while(this.trees.length){
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        } else {
            this.nextStart = 1000000000;
        }
    }
    nodeAt(pos) {
        if (pos < this.nextStart) return null;
        while(this.fragment && this.safeTo <= pos)this.nextFragment();
        if (!this.fragment) return null;
        for(;;){
            let last = this.trees.length - 1;
            if (last < 0) {
                this.nextFragment();
                return null;
            }
            let top37 = this.trees[last], index = this.index[last];
            if (index == top37.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top37.children[index];
            let start = this.start[last] + top37.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof Tree1) {
                if (start == pos) {
                    if (start < this.safeFrom) return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to) return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) {
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            } else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    stream;
    tokens = [];
    mainToken = null;
    actions = [];
    constructor(parser18, stream1){
        this.stream = stream1;
        this.tokens = parser18.tokenizers.map((_)=>new CachedToken
        );
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser: parser19  } = stack.p, { tokenizers  } = parser19;
        let mask = parser19.stateSlot(stack.state, ParseState.TokenizerMask);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for(let i289 = 0; i289 < tokenizers.length; i289++){
            if ((1 << i289 & mask) == 0) continue;
            let tokenizer = tokenizers[i289], token = this.tokens[i289];
            if (main && !tokenizer.fallback) continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + Safety.Margin) lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != Term.Err) {
                let startIndex = actionIndex;
                if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex) break;
                }
            }
        }
        while(this.actions.length > actionIndex)this.actions.pop();
        if (lookAhead) stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken) return this.mainToken;
        let main = new CachedToken, { pos , p: p39  } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p39.stream.end);
        main.value = pos == p39.stream.end ? p39.parser.eofTerm : Term.Err;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser: parser20  } = stack.p;
            for(let i290 = 0; i290 < parser20.specialized.length; i290++)if (parser20.specialized[i290] == token.value) {
                let result = parser20.specializers[i290](this.stream.read(token.start, token.end), stack);
                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                    if ((result & 1) == Specialize.Specialize) token.value = result >> 1;
                    else token.extended = result >> 1;
                    break;
                }
            }
        } else {
            token.value = Term.Err;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        for(let i291 = 0; i291 < index; i291 += 3)if (this.actions[i291] == action) return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state: state206  } = stack, { parser: parser21  } = stack.p, { data: data26  } = parser21;
        for(let set = 0; set < 2; set++){
            for(let i292 = parser21.stateSlot(state206, set ? ParseState.Skip : ParseState.Actions);; i292 += 3){
                if (data26[i292] == Seq.End) {
                    if (data26[i292 + 1] == Seq.Next) {
                        i292 = pair(data26, i292 + 2);
                    } else {
                        if (index == 0 && data26[i292 + 1] == Seq.Other) index = this.putAction(pair(data26, i292 + 2), token, end, index);
                        break;
                    }
                }
                if (data26[i292] == token) index = this.putAction(pair(data26, i292 + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function(Rec1) {
    Rec1[Rec1["Distance"] = 5] = "Distance";
    Rec1[Rec1["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec1[Rec1["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec1[Rec1["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    Rec1[Rec1["CutDepth"] = 15000] = "CutDepth";
    Rec1[Rec1["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    parser;
    input;
    ranges;
    stacks;
    recovering = 0;
    fragments;
    nextStackID = 9812;
    minStackPos = 0;
    reused = [];
    stream;
    tokens;
    topTerm;
    stoppedAt = null;
    constructor(parser22, input, fragments, ranges){
        this.parser = parser22;
        this.input = input;
        this.ranges = ranges;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser22, this.stream);
        this.topTerm = parser22.top[1];
        let { from  } = ranges[0];
        this.stacks = [
            Stack.start(this, parser22.top[0], from)
        ];
        this.fragments = fragments.length && this.stream.end - from > parser22.bufferLength * 4 ? new FragmentCursor2(fragments, parser22.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        for(let i293 = 0; i293 < stacks.length; i293++){
            let stack = stacks[i293];
            for(;;){
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                } else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                } else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished3 = stopped && findFinished(stopped);
            if (finished3) return this.stackToTree(finished3);
            if (this.parser.strict) {
                if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering) this.recovering = Rec.Distance;
        }
        if (this.recovering && stopped) {
            let finished4 = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished4) return this.stackToTree(finished4.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * Rec.MaxRemainingPerStep;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b)=>b.score - a.score
                );
                while(newStacks.length > maxRemaining)newStacks.pop();
            }
            if (newStacks.some((s)=>s.reducePos > pos
            )) this.recovering--;
        } else if (newStacks.length > 1) {
            outer: for(let i294 = 0; i294 < newStacks.length - 1; i294++){
                let stack = newStacks[i294];
                for(let j = i294 + 1; j < newStacks.length; j++){
                    let other = newStacks[j];
                    if (stack.sameState(other) || stack.buffer.length > Rec.MinBufferLengthPrune && other.buffer.length > Rec.MinBufferLengthPrune) {
                        if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                            newStacks.splice(j--, 1);
                        } else {
                            newStacks.splice(i294--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for(let i1 = 1; i1 < newStacks.length; i1++)if (newStacks[i1].pos < this.minStackPos) this.minStackPos = newStacks[i1].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser: parser23  } = this;
        let base29 = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for(let cached = this.fragments.nodeAt(start); cached;){
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser23.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose) console.log(base29 + this.stackID(stack) + ` (via reuse of ${parser23.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof Tree1) || cached.children.length == 0 || cached.positions[0] > 0) break;
                let inner = cached.children[0];
                if (inner instanceof Tree1 && cached.positions[0] == 0) cached = inner;
                else break;
            }
        }
        let defaultReduce = parser23.stateSlot(stack.state, ParseState.DefaultReduce);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose) console.log(base29 + this.stackID(stack) + ` (via always-reduce ${parser23.getName(defaultReduce & Action.ValueMask)})`);
            return true;
        }
        if (stack.stack.length >= Rec.CutDepth) {
            while(stack.stack.length > Rec.CutTo && stack.forceReduce()){}
        }
        let actions = this.tokens.getActions(stack);
        for(let i295 = 0; i295 < actions.length;){
            let action = actions[i295++], term = actions[i295++], end = actions[i295++];
            let last = i295 == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose) console.log(base29 + this.stackID(localStack) + ` (via ${(action & Action.ReduceFlag) == 0 ? "shift" : `reduce of ${parser23.getName(action & Action.ValueMask)}`} for ${parser23.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last) return true;
            else if (localStack.pos > start) stacks.push(localStack);
            else split.push(localStack);
        }
        return false;
    }
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for(;;){
            if (!this.advanceStack(stack, null, null)) return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished5 = null, restarted = false;
        for(let i296 = 0; i296 < stacks.length; i296++){
            let stack = stacks[i296], token = tokens[i296 << 1], tokenEnd = tokens[(i296 << 1) + 1];
            let base30 = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted) continue;
                restarted = true;
                stack.restart();
                if (verbose) console.log(base30 + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done) continue;
            }
            let force = stack.split(), forceBase = base30;
            for(let j = 0; force.forceReduce() && j < Rec.ForceReduceLimit; j++){
                if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done) break;
                if (verbose) forceBase = this.stackID(force) + " -> ";
            }
            for (let insert10 of stack.recoverByInsert(token)){
                if (verbose) console.log(base30 + this.stackID(insert10) + " (via recover-insert)");
                this.advanceFully(insert10, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = Term.Err;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose) console.log(base30 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            } else if (!finished5 || finished5.score < stack.score) {
                finished5 = stack;
            }
        }
        return finished5;
    }
    stackToTree(stack) {
        stack.close();
        return Tree1.build({
            buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm
        });
    }
    stackID(stack) {
        let id1 = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id1) stackIDs.set(stack, id1 = String.fromCodePoint(this.nextStackID++));
        return id1 + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for(let i297 = 0; i297 < newStacks.length; i297++){
        let other = newStacks[i297];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i297].score < stack.score) newStacks[i297] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    source;
    flags;
    disabled;
    constructor(source, flags, disabled){
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) {
        return !this.disabled || this.disabled[term] == 0;
    }
}
const id = (x)=>x
;
class ContextTracker {
    start;
    shift;
    reduce;
    reuse;
    hash;
    strict;
    constructor(spec){
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (()=>0
        );
        this.strict = spec.strict !== false;
    }
}
class LRParser extends Parser {
    states;
    data;
    goto;
    maxTerm;
    minRepeatTerm;
    tokenizers;
    topRules;
    context;
    dialects;
    dynamicPrecedences;
    specialized;
    specializers;
    tokenPrecTable;
    termNames;
    maxNode;
    dialect;
    wrappers = [];
    top;
    bufferLength;
    strict;
    nodeSet;
    constructor(spec){
        super();
        if (spec.version != File.Version) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${File.Version})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for(let i410 = 0; i410 < spec.repeatNodeCount; i410++)nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map((r)=>spec.topRules[r][1]
        );
        let nodeProps = [];
        for(let i298 = 0; i298 < nodeNames.length; i298++)nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([
                prop,
                prop.deserialize(String(value))
            ]);
        }
        if (spec.nodeProps) for (let propSpec of spec.nodeProps){
            let prop = propSpec[0];
            for(let i299 = 1; i299 < propSpec.length;){
                let next = propSpec[i299++];
                if (next >= 0) {
                    setProp(next, prop, propSpec[i299++]);
                } else {
                    let value = propSpec[i299 + -next];
                    for(let j = -next; j > 0; j--)setProp(propSpec[i299++], prop, value);
                    i299++;
                }
            }
        }
        this.nodeSet = new NodeSet(nodeNames.map((name64, i300)=>NodeType.define({
                name: i300 >= this.minRepeatTerm ? undefined : name64,
                id: i300,
                props: nodeProps[i300],
                top: topTerms.indexOf(i300) > -1,
                error: i300 == 0,
                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i300) > -1
            })
        ));
        this.strict = false;
        this.bufferLength = DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized) for(let i310 = 0; i310 < spec.specialized.length; i310++){
            this.specialized[i310] = spec.specialized[i310].term;
            this.specializers[i310] = spec.specialized[i310].get;
        }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map((value)=>typeof value == "number" ? new TokenGroup(tokenArray, value) : value
        );
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse9 = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)parse9 = w(parse9, input, fragments, ranges);
        return parse9;
    }
    getGoto(state207, term, loose = false) {
        let table = this.goto;
        if (term >= table[0]) return -1;
        for(let pos = table[term + 1];;){
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose) return target;
            for(let end = pos + (groupTag >> 1); pos < end; pos++)if (table[pos] == state207) return target;
            if (last) return -1;
        }
    }
    hasAction(state208, terminal) {
        let data27 = this.data;
        for(let set = 0; set < 2; set++){
            for(let i301 = this.stateSlot(state208, set ? ParseState.Skip : ParseState.Actions), next;; i301 += 3){
                if ((next = data27[i301]) == Seq.End) {
                    if (data27[i301 + 1] == Seq.Next) next = data27[i301 = pair(data27, i301 + 2)];
                    else if (data27[i301 + 1] == Seq.Other) return pair(data27, i301 + 2);
                    else break;
                }
                if (next == terminal || next == Term.Err) return pair(data27, i301 + 1);
            }
        }
        return 0;
    }
    stateSlot(state209, slot) {
        return this.states[state209 * ParseState.Size + slot];
    }
    stateFlag(state210, flag) {
        return (this.stateSlot(state210, ParseState.Flags) & flag) > 0;
    }
    validAction(state211, action) {
        if (action == this.stateSlot(state211, ParseState.DefaultReduce)) return true;
        for(let i302 = this.stateSlot(state211, ParseState.Actions);; i302 += 3){
            if (this.data[i302] == Seq.End) {
                if (this.data[i302 + 1] == Seq.Next) i302 = pair(this.data, i302 + 2);
                else return false;
            }
            if (action == pair(this.data, i302 + 1)) return true;
        }
    }
    nextStates(state212) {
        let result = [];
        for(let i5 = this.stateSlot(state212, ParseState.Actions);; i5 += 3){
            if (this.data[i5] == Seq.End) {
                if (this.data[i5 + 1] == Seq.Next) i5 = pair(this.data, i5 + 2);
                else break;
            }
            if ((this.data[i5 + 2] & Action.ReduceFlag >> 16) == 0) {
                let value = this.data[i5 + 1];
                if (!result.some((v, i303)=>i303 & 1 && v == value
                )) result.push(this.data[i5], value);
            }
        }
        return result;
    }
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config35) {
        let copy5 = Object.assign(Object.create(LRParser.prototype), this);
        if (config35.props) copy5.nodeSet = this.nodeSet.extend(...config35.props);
        if (config35.top) {
            let info = this.topRules[config35.top];
            if (!info) throw new RangeError(`Invalid top rule name ${config35.top}`);
            copy5.top = info;
        }
        if (config35.tokenizers) copy5.tokenizers = this.tokenizers.map((t21)=>{
            let found = config35.tokenizers.find((r)=>r.from == t21
            );
            return found ? found.to : t21;
        });
        if (config35.contextTracker) copy5.context = config35.contextTracker;
        if (config35.dialect) copy5.dialect = this.parseDialect(config35.dialect);
        if (config35.strict != null) copy5.strict = config35.strict;
        if (config35.wrap) copy5.wrappers = copy5.wrappers.concat(config35.wrap);
        if (config35.bufferLength != null) copy5.bufferLength = config35.bufferLength;
        return copy5;
    }
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
        return this.maxNode + 1;
    }
    get topNode() {
        return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
        let prec3 = this.dynamicPrecedences;
        return prec3 == null ? 0 : prec3[term] || 0;
    }
    parseDialect(dialect) {
        let values19 = Object.keys(this.dialects), flags = values19.map(()=>false
        );
        if (dialect) for (let part of dialect.split(" ")){
            let id2 = values19.indexOf(part);
            if (id2 >= 0) flags[id2] = true;
        }
        let disabled = null;
        for(let i304 = 0; i304 < values19.length; i304++)if (!flags[i304]) {
            for(let j = this.dialects[values19[i304]], id3; (id3 = this.data[j++]) != Seq.End;)(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id3] = 1;
        }
        return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data28, off) {
    return data28[off] | data28[off + 1] << 16;
}
function findOffset(data29, start, term) {
    for(let i305 = start, next; (next = data29[i305]) != Seq.End; i305++)if (next == term) return i305 - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks){
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, StateFlag.Accepting) && (!best || best.score < stack.score)) best = stack;
    }
    return best;
}
const selfClosers = {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
    menuitem: true
};
const implicitlyClosed = {
    dd: true,
    li: true,
    optgroup: true,
    option: true,
    p: true,
    rp: true,
    rt: true,
    tbody: true,
    td: true,
    tfoot: true,
    th: true,
    tr: true
};
const closeOnOpen = {
    dd: {
        dd: true,
        dt: true
    },
    dt: {
        dd: true,
        dt: true
    },
    li: {
        li: true
    },
    option: {
        option: true,
        optgroup: true
    },
    optgroup: {
        optgroup: true
    },
    p: {
        address: true,
        article: true,
        aside: true,
        blockquote: true,
        dir: true,
        div: true,
        dl: true,
        fieldset: true,
        footer: true,
        form: true,
        h1: true,
        h2: true,
        h3: true,
        h4: true,
        h5: true,
        h6: true,
        header: true,
        hgroup: true,
        hr: true,
        menu: true,
        nav: true,
        ol: true,
        p: true,
        pre: true,
        section: true,
        table: true,
        ul: true
    },
    rp: {
        rp: true,
        rt: true
    },
    rt: {
        rp: true,
        rt: true
    },
    tbody: {
        tbody: true,
        tfoot: true
    },
    td: {
        td: true,
        th: true
    },
    tfoot: {
        tbody: true
    },
    th: {
        td: true,
        th: true
    },
    thead: {
        tbody: true,
        tfoot: true
    },
    tr: {
        tr: true
    }
};
function nameChar(ch) {
    return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
    return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
    let pos = input.pos + offset;
    if (cachedPos == pos && cachedInput == input) return cachedName;
    let next = input.peek(offset);
    while(isSpace(next))next = input.peek(++offset);
    let name65 = "";
    for(;;){
        if (!nameChar(next)) break;
        name65 += String.fromCharCode(next);
        next = input.peek(++offset);
    }
    cachedInput = input;
    cachedPos = pos;
    return cachedName = name65 ? name65.toLowerCase() : next == question || next == bang ? undefined : null;
}
const question = 63, bang = 33;
function ElementContext(name66, parent) {
    this.name = name66;
    this.parent = parent;
    this.hash = parent ? parent.hash : 0;
    for(let i306 = 0; i306 < name66.length; i306++)this.hash += (this.hash << 4) + name66.charCodeAt(i306) + (name66.charCodeAt(i306) << 8);
}
const startTagTerms = [
    4,
    8,
    5,
    6,
    7
];
const elementContext = new ContextTracker({
    start: null,
    shift (context, term, stack, input) {
        return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
    },
    reduce (context, term) {
        return term == 18 && context ? context.parent : context;
    },
    reuse (context, node, stack, input) {
        let type = node.type.id;
        return type == 4 || type == 35 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
    },
    hash (context) {
        return context ? context.hash : 0;
    },
    strict: false
});
const tagStart = new ExternalTokenizer((input, stack)=>{
    if (input.next != 60) {
        if (input.next < 0 && stack.context) input.acceptToken(56);
        return;
    }
    input.advance();
    let close = input.next == 47;
    if (close) input.advance();
    let name67 = tagNameAfter(input, 0);
    if (name67 === undefined) return;
    if (!name67) return input.acceptToken(close ? 12 : 4);
    let parent = stack.context ? stack.context.name : null;
    if (close) {
        if (name67 == parent) return input.acceptToken(9);
        if (parent && implicitlyClosed[parent]) return input.acceptToken(56, -2);
        if (stack.dialectEnabled(0)) return input.acceptToken(10);
        for(let cx = stack.context; cx; cx = cx.parent)if (cx.name == name67) return;
        input.acceptToken(11);
    } else {
        if (name67 == "script") return input.acceptToken(5);
        if (name67 == "style") return input.acceptToken(6);
        if (name67 == "textarea") return input.acceptToken(7);
        if (selfClosers.hasOwnProperty(name67)) return input.acceptToken(8);
        if (parent && closeOnOpen[parent] && closeOnOpen[parent][name67]) input.acceptToken(56, -1);
        else input.acceptToken(4);
    }
}, {
    contextual: true
});
const commentContent = new ExternalTokenizer((input)=>{
    for(let endPos = 0, i307 = 0;; i307++){
        if (input.next < 0) {
            if (i307) input.acceptToken(57);
            break;
        }
        if (input.next == "-->".charCodeAt(endPos)) {
            endPos++;
            if (endPos == 3) {
                if (i307 > 3) input.acceptToken(57, -2);
                break;
            }
        } else {
            endPos = 0;
        }
        input.advance();
    }
});
function contentTokenizer(tag, textToken, endToken) {
    let lastState = 2 + tag.length;
    return new ExternalTokenizer((input)=>{
        for(let state213 = 0, matchedLen = 0, i308 = 0;; i308++){
            if (input.next < 0) {
                if (i308) input.acceptToken(textToken);
                break;
            }
            if (state213 == 0 && input.next == 60 || state213 == 1 && input.next == 47 || state213 >= 2 && state213 < lastState && input.next == tag.charCodeAt(state213 - 2)) {
                state213++;
                matchedLen++;
            } else if ((state213 == 2 || state213 == lastState) && isSpace(input.next)) {
                matchedLen++;
            } else if (state213 == lastState && input.next == 62) {
                if (i308 > matchedLen) input.acceptToken(textToken, -matchedLen);
                else input.acceptToken(endToken, -(matchedLen - 2));
                break;
            } else if ((input.next == 10 || input.next == 13) && i308) {
                input.acceptToken(textToken, 1);
                break;
            } else {
                state213 = matchedLen = 0;
            }
            input.advance();
        }
    });
}
const scriptTokens = contentTokenizer("script", 53, 1);
const styleTokens = contentTokenizer("style", 54, 2);
const textareaTokens = contentTokenizer("textarea", 55, 3);
const parser1 = LRParser.deserialize({
    version: 13,
    states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*WO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*fO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*tO7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
    stateData: "+[~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uO!_!wO!`!uO~O_!xO`!xO!a!wO!b!xO~O_!uO`!uO!_!{O!`!uO~O_!xO`!xO!a!{O!b!xO~O`_a!cwz!c~",
    goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
    nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
    maxTerm: 66,
    context: elementContext,
    nodeProps: [
        [
            NodeProp.closedBy,
            -11,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            "EndTag",
            -4,
            19,
            29,
            32,
            35,
            "CloseTag"
        ],
        [
            NodeProp.group,
            -9,
            12,
            15,
            16,
            17,
            18,
            38,
            39,
            40,
            41,
            "Entity",
            14,
            "Entity TextContent",
            -3,
            27,
            30,
            33,
            "TextContent Entity"
        ],
        [
            NodeProp.openedBy,
            26,
            "StartTag StartCloseTag",
            -4,
            28,
            31,
            34,
            36,
            "OpenTag"
        ]
    ],
    skippedNodes: [
        0
    ],
    repeatNodeCount: 9,
    tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWaPOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
    tokenizers: [
        scriptTokens,
        styleTokens,
        textareaTokens,
        tagStart,
        commentContent,
        0,
        1,
        2,
        3,
        4,
        5
    ],
    topRules: {
        "Document": [
            0,
            13
        ]
    },
    dialects: {
        noMatch: 0
    },
    tokenPrec: 464
});
function getAttrs(element, input) {
    let attrs = Object.create(null);
    for (let att of element.firstChild.getChildren("Attribute")){
        let name68 = att.getChild("AttributeName"), value = att.getChild("AttributeValue") || att.getChild("UnquotedAttributeValue");
        if (name68) attrs[input.read(name68.from, name68.to)] = !value ? "" : value.name == "AttributeValue" ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
    }
    return attrs;
}
function maybeNest(node, input, tags2) {
    let attrs;
    for (let tag of tags2){
        if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input)))) return {
            parser: tag.parser
        };
    }
    return null;
}
function configureNesting(tags3) {
    let script = [], style = [], textarea = [];
    for (let tag of tags3){
        let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
        if (!array) throw new RangeError("Only script, style, and textarea tags can host nested parsers");
        array.push(tag);
    }
    return parseMixed((node, input)=>{
        let id19 = node.type.id;
        if (id19 == 27) return maybeNest(node, input, script);
        if (id19 == 30) return maybeNest(node, input, style);
        if (id19 == 33) return maybeNest(node, input, textarea);
        return null;
    });
}
const space1 = [
    9,
    10,
    11,
    12,
    13,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
];
function isAlpha(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
    return ch >= 48 && ch <= 57;
}
const identifiers = new ExternalTokenizer((input, stack)=>{
    for(let inside3 = false, dashes = 0, i309 = 0;; i309++){
        let { next  } = input;
        if (isAlpha(next) || next == 45 || next == 95 || inside3 && isDigit(next)) {
            if (!inside3 && (next != 45 || i309 > 0)) inside3 = true;
            if (dashes === i309 && next == 45) dashes++;
            input.advance();
        } else {
            if (inside3) input.acceptToken(next == 40 ? 94 : dashes == 2 && stack.canShift(2) ? 2 : 95);
            break;
        }
    }
});
const descendant = new ExternalTokenizer((input)=>{
    if (space1.includes(input.peek(-1))) {
        let { next  } = input;
        if (isAlpha(next) || next == 95 || next == 35 || next == 46 || next == 91 || next == 58 || next == 45) input.acceptToken(93);
    }
});
const unitToken = new ExternalTokenizer((input)=>{
    if (!space1.includes(input.peek(-1))) {
        let { next  } = input;
        if (next == 37) {
            input.advance();
            input.acceptToken(1);
        }
        if (isAlpha(next)) {
            do {
                input.advance();
            }while (isAlpha(input.next))
            input.acceptToken(1);
        }
    }
});
const spec_callee = {
    __proto__: null,
    lang: 32,
    "nth-child": 32,
    "nth-last-child": 32,
    "nth-of-type": 32,
    dir: 32,
    url: 60,
    "url-prefix": 60,
    domain: 60,
    regexp: 60,
    selector: 134
};
const spec_AtKeyword = {
    __proto__: null,
    "@import": 114,
    "@media": 138,
    "@charset": 142,
    "@namespace": 146,
    "@keyframes": 152,
    "@supports": 164
};
const spec_identifier = {
    __proto__: null,
    not: 128,
    only: 128,
    from: 158,
    to: 160
};
const parser2 = LRParser.deserialize({
    version: 13,
    states: "7WOYQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!ZQ[O'#CfO!}QXO'#CaO#UQ[O'#ChO#aQ[O'#DPO#fQ[O'#DTOOQP'#Ec'#EcO#kQdO'#DeO$VQ[O'#DrO#kQdO'#DtO$hQ[O'#DvO$sQ[O'#DyO$xQ[O'#EPO%WQ[O'#EROOQS'#Eb'#EbOOQS'#ES'#ESQYQ[OOOOQP'#Cg'#CgOOQP,59Q,59QO!ZQ[O,59QO%_Q[O'#EVO%yQWO,58{O&RQ[O,59SO#aQ[O,59kO#fQ[O,59oO%_Q[O,59sO%_Q[O,59uO%_Q[O,59vO'bQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'iQWO,59SO'nQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO'sQ`O,59oOOQS'#Cp'#CpO#kQdO'#CqO'{QvO'#CsO)VQtO,5:POOQO'#Cx'#CxO'iQWO'#CwO)kQWO'#CyOOQS'#Ef'#EfOOQO'#Dh'#DhO)pQ[O'#DoO*OQWO'#EiO$xQ[O'#DmO*^QWO'#DpOOQO'#Ej'#EjO%|QWO,5:^O*cQpO,5:`OOQS'#Dx'#DxO*kQWO,5:bO*pQ[O,5:bOOQO'#D{'#D{O*xQWO,5:eO*}QWO,5:kO+VQWO,5:mOOQS-E8Q-E8QOOQP1G.l1G.lO+yQXO,5:qOOQO-E8T-E8TOOQS1G.g1G.gOOQP1G.n1G.nO'iQWO1G.nO'nQWO1G.nOOQP1G/V1G/VO,WQ`O1G/ZO,qQXO1G/_O-XQXO1G/aO-oQXO1G/bO.VQXO'#CdO.zQWO'#DaOOQS,59z,59zO/PQWO,59zO/XQ[O,59zO/`QdO'#CoO/gQ[O'#DOOOQP1G/Z1G/ZO#kQdO1G/ZO/nQpO,59]OOQS,59_,59_O#kQdO,59aO/vQWO1G/kOOQS,59c,59cO/{Q!bO,59eO0TQWO'#DhO0`QWO,5:TO0eQWO,5:ZO$xQ[O,5:VO$xQ[O'#EYO0mQWO,5;TO0xQWO,5:XO%_Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1ZQWO1G/|O1`QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XOOQP7+$Y7+$YOOQP7+$u7+$uO#kQdO7+$uO#kQdO,59{O1nQ[O'#EXO1xQWO1G/fOOQS1G/f1G/fO1xQWO1G/fO2QQtO'#ETO2uQdO'#EeO3PQWO,59ZO3UQXO'#EhO3]QWO,59jO3bQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO3jQWO1G/PO#kQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO3oQWO,5:tOOQO-E8W-E8WO3}QXO1G/vOOQS7+%h7+%hO4UQYO'#CsO%|QWO'#EZO4^QdO,5:hOOQS,5:h,5:hO4lQpO<<HaO4tQtO1G/gOOQO,5:s,5:sO5XQ[O,5:sOOQO-E8V-E8VOOQS7+%Q7+%QO5cQWO7+%QOOQS-E8R-E8RO#kQdO'#EUO5kQWO,5;POOQT1G.u1G.uO5sQWO,5;SOOQP1G/U1G/UOOQP<<Ha<<HaOOQS7+$k7+$kO5{QdO7+%ZOOQO7+%b7+%bOOQS,5:u,5:uOOQS-E8X-E8XOOQS1G0S1G0SOOQPAN={AN={O6SQtO'#EWO#kQdO'#EWO6}QdO7+%ROOQO7+%R7+%ROOQO1G0_1G0_OOQS<<Hl<<HlO7_QdO,5:pOOQO-E8S-E8SOOQO<<Hu<<HuO7iQtO,5:rOOQS-E8U-E8UOOQO<<Hm<<Hm",
    stateData: "8j~O#TOSROS~OUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#RPO#WRO~O#RcO~O]hO^hOpfOtiOxjO|kO!PmO#PlO#WeO~O!RnO~P!`O`sO#QqO#RpO~O#RuO~O#RwO~OQ!QObzOf!QOh!QOn!PO#Q}O#RyO#Z{O~Ob!SO!b!UO!e!VO#R!RO!R#]P~Oh![On!PO#R!ZO~O#R!^O~Ob!SO!b!UO!e!VO#R!RO~O!W#]P~P$VOUWOXWO]TO^TOtUOxVO#RPO#WRO~OpfO!RnO~O`!hO#QqO#RpO~OQ!pOUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#R!oO#WRO~O!Q!qO~P&^Ob!tO~Ob!uO~Ov!vOz!wO~OP!yObgXjgX!WgX!bgX!egX#RgXagXQgXfgXhgXngXpgX#QgX#ZgXvgX!QgX!VgX~Ob!SOj!zO!b!UO!e!VO#R!RO!W#]P~Ob!}O~Ob!SO!b!UO!e!VO#R#OO~Op#SO!`#RO!R#]X!W#]X~Ob#VO~Oj!zO!W#XO~O!W#YO~Oh#ZOn!PO~O!R#[O~O!RnO!`#RO~O!RnO!W#_O~O]hO^hOtiOxjO|kO!PmO#PlO#WeO~Op!ya!R!yaa!ya~P+_Ov#aOz#bO~O]hO^hOtiOxjO#WeO~Op{i|{i!P{i!R{i#P{ia{i~P,`Op}i|}i!P}i!R}i#P}ia}i~P,`Op!Oi|!Oi!P!Oi!R!Oi#P!Oia!Oi~P,`O]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#PWX#WWX~O]#cO~O!Q#fO!W#dO~O!Q#fO~P&^Oa#XP~P#kOa#[P~P%_Oa#nOj!zO~O!W#pO~Oh#qOo#qO~O]!^Xa![X!`![X~O]#rO~Oa#sO!`#RO~Op#SO!R#]a!W#]a~O!`#ROp!aa!R!aa!W!aaa!aa~O!W#xO~O!Q#|O!q#zO!r#zO#Z#yO~O!Q!{X!W!{X~P&^O!Q$SO!W#dO~Oj!zOQ!wXa!wXb!wXf!wXh!wXn!wXp!wX#Q!wX#R!wX#Z!wX~Op$VOa#XX~P#kOa$XO~Oa#[X~P!`Oa$ZO~Oj!zOv$[O~Oa$]O~O!`#ROp!|a!R!|a!W!|a~Oa$_O~P+_OP!yO!RgX~O!Q$bO!q#zO!r#zO#Z#yO~Oj!zOv$cO~Oj!zOp$eO!V$gO!Q!Ti!W!Ti~P#kO!Q!{a!W!{a~P&^O!Q$iO!W#dO~Op$VOa#Xa~OpfOa#[a~Oa$lO~P#kOj!zOQ!zXb!zXf!zXh!zXn!zXp!zX!Q!zX!V!zX!W!zX#Q!zX#R!zX#Z!zX~Op$eO!V$oO!Q!Tq!W!Tq~P#kOa!xap!xa~P#kOj!zOQ!zab!zaf!zah!zan!zap!za!Q!za!V!za!W!za#Q!za#R!za#Z!za~Oo#Zj!Pj~",
    goto: ",O#_PPPPP#`P#h#vP#h$U#hPP$[PPP$b$k$kP$}P$kP$k%e%wPPP&a&g#hP&mP#hP&sP#hP#h#hPPP&y']'iPP#`PP'o'o'y'oP'oP'o'oP#`P#`P#`P'|#`P(P(SPP#`P#`(V(e(s(y)T)Z)e)kPPPPPP)q)yP*e*hP+^+a+j]`Obn!s#d$QiWObfklmn!s!u#V#d$QiQObfklmn!s!u#V#d$QQdRR!ceQrTR!ghQ!gsQ!|!OR#`!hq!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jT#z#[#{q!OXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jQ![[R#Z!]QtTR!ihQ!gtR#`!iQvUR!jiQxVR!kjQoSQ!fgQ#W!XQ#^!`Q#_!aR$`#zQ!rnQ#g!sQ$P#dR$h$QX!pn!s#d$Qa!WY^_|!S!U#R#SR#P!SR!][R!_]R#]!_QbOU!bb!s$QQ!snR$Q#dQ#i!tU$U#i$^$jQ$^#rR$j$VQ$W#iR$k$WQgSS!eg$YR$Y#kQ$f$OR$n$fQ#e!rS$R#e$TR$T#gQ#T!TR#v#TQ#{#[R$a#{]aObn!s#d$Q[SObn!s#d$QQ!dfQ!lkQ!mlQ!nmQ#k!uR#w#VR#j!tQ|XQ!YZQ!xz[#h!t#i#r$V$^$jQ#m!wQ#o!zQ#}#bQ$O#cS$d$O$fR$m$eR#l!uQ!XYQ!a_R!{|U!TY_|Q!`^Q#Q!SQ#U!UQ#t#RR#u#S",
    nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule",
    maxTerm: 106,
    nodeProps: [
        [
            NodeProp.openedBy,
            17,
            "(",
            48,
            "{"
        ],
        [
            NodeProp.closedBy,
            18,
            ")",
            49,
            "}"
        ]
    ],
    skippedNodes: [
        0,
        3
    ],
    repeatNodeCount: 8,
    tokenData: "Ay~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8U}!O8a!O!P8x!P!Q9Z!Q![;e![!]<Y!]!^<x!^!_$w!_!`=T!`!a=`!a!b$w!b!c>O!c!}$w!}#O?[#O#P$w#P#Q?g#Q#R2U#R#T$w#T#U?r#U#c$w#c#d@q#d#o$w#o#pAQ#p#q2U#q#rA]#r#sAh#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQoWOy%Qz~%Q~%bf#T~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#T~oWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSoWOy%Qz#a%Q#a#b)T#b~%Q^)YSoWOy%Qz#d%Q#d#e)f#e~%Q^)kSoWOy%Qz#c%Q#c#d)w#d~%Q^)|SoWOy%Qz#f%Q#f#g*Y#g~%Q^*_SoWOy%Qz#h%Q#h#i*k#i~%Q^*pSoWOy%Qz#T%Q#T#U*|#U~%Q^+RSoWOy%Qz#b%Q#b#c+_#c~%Q^+dSoWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!VUoWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOh~~,lPO~+}_,tWtPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWoWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWoWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWfUoWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWfUoWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWoWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWfUoWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WoWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQfUoWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQzQoWOy%Qz~%QX2wQXPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQbVOy%Qz~%Q~3zOa~_4RSUPjSOy%Qz!_%Q!_!`2e!`~%Q_4fUjS!PPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SoWOy%Qz!Q%Q!Q![5Z![~%Q^5bWoW#ZUOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWoWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSoWOy%Qz!Q%Q!Q![6z![~%Q^7RSoW#ZUOy%Qz!Q%Q!Q![6z![~%Q^7fYoW#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8ZQpVOy%Qz~%Q^8fUjSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_8}S#WPOy%Qz!Q%Q!Q![5Z![~%Q~9`RjSOy%Qz{9i{~%Q~9nSoWOy9iyz9zz{:o{~9i~9}ROz9zz{:W{~9z~:ZTOz9zz{:W{!P9z!P!Q:j!Q~9z~:oOR~~:tUoWOy9iyz9zz{:o{!P9i!P!Q;W!Q~9i~;_QR~oWOy%Qz~%Q^;jY#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX<_S]POy%Qz![%Q![!]<k!]~%QX<rQ^PoWOy%Qz~%Q_<}Q!WVOy%Qz~%QY=YQzQOy%Qz~%QX=eS|POy%Qz!`%Q!`!a=q!a~%QX=xQ|PoWOy%Qz~%QX>RUOy%Qz!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX>lY!YPoWOy%Qz}%Q}!O>e!O!Q%Q!Q![>e![!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX?aQxPOy%Qz~%Q^?lQvUOy%Qz~%QX?uSOy%Qz#b%Q#b#c@R#c~%QX@WSoWOy%Qz#W%Q#W#X@d#X~%QX@kQ!`PoWOy%Qz~%QX@tSOy%Qz#f%Q#f#g@d#g~%QXAVQ!RPOy%Qz~%Q_AbQ!QVOy%Qz~%QZAmS!PPOy%Qz!_%Q!_!`2e!`~%Q",
    tokenizers: [
        descendant,
        unitToken,
        identifiers,
        0,
        1,
        2,
        3
    ],
    topRules: {
        "StyleSheet": [
            0,
            4
        ]
    },
    specialized: [
        {
            term: 94,
            get: (value)=>spec_callee[value] || -1
        },
        {
            term: 56,
            get: (value)=>spec_AtKeyword[value] || -1
        },
        {
            term: 95,
            get: (value)=>spec_identifier[value] || -1
        }
    ],
    tokenPrec: 1078
});
let _properties = null;
function properties() {
    if (!_properties && typeof document == "object" && document.body) {
        let names = [];
        for(let prop in document.body.style){
            if (!/[A-Z]|^-|^(item|length)$/.test(prop)) names.push(prop);
        }
        _properties = names.sort().map((name69)=>({
                type: "property",
                label: name69
            })
        );
    }
    return _properties || [];
}
const pseudoClasses = [
    "active",
    "after",
    "before",
    "checked",
    "default",
    "disabled",
    "empty",
    "enabled",
    "first-child",
    "first-letter",
    "first-line",
    "first-of-type",
    "focus",
    "hover",
    "in-range",
    "indeterminate",
    "invalid",
    "lang",
    "last-child",
    "last-of-type",
    "link",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-of-type",
    "only-child",
    "optional",
    "out-of-range",
    "placeholder",
    "read-only",
    "read-write",
    "required",
    "root",
    "selection",
    "target",
    "valid",
    "visited"
].map((name70)=>({
        type: "class",
        label: name70
    })
);
const values = [
    "above",
    "absolute",
    "activeborder",
    "additive",
    "activecaption",
    "after-white-space",
    "ahead",
    "alias",
    "all",
    "all-scroll",
    "alphabetic",
    "alternate",
    "always",
    "antialiased",
    "appworkspace",
    "asterisks",
    "attr",
    "auto",
    "auto-flow",
    "avoid",
    "avoid-column",
    "avoid-page",
    "avoid-region",
    "axis-pan",
    "background",
    "backwards",
    "baseline",
    "below",
    "bidi-override",
    "blink",
    "block",
    "block-axis",
    "bold",
    "bolder",
    "border",
    "border-box",
    "both",
    "bottom",
    "break",
    "break-all",
    "break-word",
    "bullets",
    "button",
    "button-bevel",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "calc",
    "capitalize",
    "caps-lock-indicator",
    "caption",
    "captiontext",
    "caret",
    "cell",
    "center",
    "checkbox",
    "circle",
    "cjk-decimal",
    "clear",
    "clip",
    "close-quote",
    "col-resize",
    "collapse",
    "color",
    "color-burn",
    "color-dodge",
    "column",
    "column-reverse",
    "compact",
    "condensed",
    "contain",
    "content",
    "contents",
    "content-box",
    "context-menu",
    "continuous",
    "copy",
    "counter",
    "counters",
    "cover",
    "crop",
    "cross",
    "crosshair",
    "currentcolor",
    "cursive",
    "cyclic",
    "darken",
    "dashed",
    "decimal",
    "decimal-leading-zero",
    "default",
    "default-button",
    "dense",
    "destination-atop",
    "destination-in",
    "destination-out",
    "destination-over",
    "difference",
    "disc",
    "discard",
    "disclosure-closed",
    "disclosure-open",
    "document",
    "dot-dash",
    "dot-dot-dash",
    "dotted",
    "double",
    "down",
    "e-resize",
    "ease",
    "ease-in",
    "ease-in-out",
    "ease-out",
    "element",
    "ellipse",
    "ellipsis",
    "embed",
    "end",
    "ethiopic-abegede-gez",
    "ethiopic-halehame-aa-er",
    "ethiopic-halehame-gez",
    "ew-resize",
    "exclusion",
    "expanded",
    "extends",
    "extra-condensed",
    "extra-expanded",
    "fantasy",
    "fast",
    "fill",
    "fill-box",
    "fixed",
    "flat",
    "flex",
    "flex-end",
    "flex-start",
    "footnotes",
    "forwards",
    "from",
    "geometricPrecision",
    "graytext",
    "grid",
    "groove",
    "hand",
    "hard-light",
    "help",
    "hidden",
    "hide",
    "higher",
    "highlight",
    "highlighttext",
    "horizontal",
    "hsl",
    "hsla",
    "hue",
    "icon",
    "ignore",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infinite",
    "infobackground",
    "infotext",
    "inherit",
    "initial",
    "inline",
    "inline-axis",
    "inline-block",
    "inline-flex",
    "inline-grid",
    "inline-table",
    "inset",
    "inside",
    "intrinsic",
    "invert",
    "italic",
    "justify",
    "keep-all",
    "landscape",
    "large",
    "larger",
    "left",
    "level",
    "lighter",
    "lighten",
    "line-through",
    "linear",
    "linear-gradient",
    "lines",
    "list-item",
    "listbox",
    "listitem",
    "local",
    "logical",
    "loud",
    "lower",
    "lower-hexadecimal",
    "lower-latin",
    "lower-norwegian",
    "lowercase",
    "ltr",
    "luminosity",
    "manipulation",
    "match",
    "matrix",
    "matrix3d",
    "medium",
    "menu",
    "menutext",
    "message-box",
    "middle",
    "min-intrinsic",
    "mix",
    "monospace",
    "move",
    "multiple",
    "multiple_mask_images",
    "multiply",
    "n-resize",
    "narrower",
    "ne-resize",
    "nesw-resize",
    "no-close-quote",
    "no-drop",
    "no-open-quote",
    "no-repeat",
    "none",
    "normal",
    "not-allowed",
    "nowrap",
    "ns-resize",
    "numbers",
    "numeric",
    "nw-resize",
    "nwse-resize",
    "oblique",
    "opacity",
    "open-quote",
    "optimizeLegibility",
    "optimizeSpeed",
    "outset",
    "outside",
    "outside-shape",
    "overlay",
    "overline",
    "padding",
    "padding-box",
    "painted",
    "page",
    "paused",
    "perspective",
    "pinch-zoom",
    "plus-darker",
    "plus-lighter",
    "pointer",
    "polygon",
    "portrait",
    "pre",
    "pre-line",
    "pre-wrap",
    "preserve-3d",
    "progress",
    "push-button",
    "radial-gradient",
    "radio",
    "read-only",
    "read-write",
    "read-write-plaintext-only",
    "rectangle",
    "region",
    "relative",
    "repeat",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "repeat-x",
    "repeat-y",
    "reset",
    "reverse",
    "rgb",
    "rgba",
    "ridge",
    "right",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "round",
    "row",
    "row-resize",
    "row-reverse",
    "rtl",
    "run-in",
    "running",
    "s-resize",
    "sans-serif",
    "saturation",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "screen",
    "scroll",
    "scrollbar",
    "scroll-position",
    "se-resize",
    "self-start",
    "self-end",
    "semi-condensed",
    "semi-expanded",
    "separate",
    "serif",
    "show",
    "single",
    "skew",
    "skewX",
    "skewY",
    "skip-white-space",
    "slide",
    "slider-horizontal",
    "slider-vertical",
    "sliderthumb-horizontal",
    "sliderthumb-vertical",
    "slow",
    "small",
    "small-caps",
    "small-caption",
    "smaller",
    "soft-light",
    "solid",
    "source-atop",
    "source-in",
    "source-out",
    "source-over",
    "space",
    "space-around",
    "space-between",
    "space-evenly",
    "spell-out",
    "square",
    "start",
    "static",
    "status-bar",
    "stretch",
    "stroke",
    "stroke-box",
    "sub",
    "subpixel-antialiased",
    "svg_masks",
    "super",
    "sw-resize",
    "symbolic",
    "symbols",
    "system-ui",
    "table",
    "table-caption",
    "table-cell",
    "table-column",
    "table-column-group",
    "table-footer-group",
    "table-header-group",
    "table-row",
    "table-row-group",
    "text",
    "text-bottom",
    "text-top",
    "textarea",
    "textfield",
    "thick",
    "thin",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "to",
    "top",
    "transform",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ",
    "transparent",
    "ultra-condensed",
    "ultra-expanded",
    "underline",
    "unidirectional-pan",
    "unset",
    "up",
    "upper-latin",
    "uppercase",
    "url",
    "var",
    "vertical",
    "vertical-text",
    "view-box",
    "visible",
    "visibleFill",
    "visiblePainted",
    "visibleStroke",
    "visual",
    "w-resize",
    "wait",
    "wave",
    "wider",
    "window",
    "windowframe",
    "windowtext",
    "words",
    "wrap",
    "wrap-reverse",
    "x-large",
    "x-small",
    "xor",
    "xx-large",
    "xx-small"
].map((name71)=>({
        type: "keyword",
        label: name71
    })
).concat([
    "aliceblue",
    "antiquewhite",
    "aqua",
    "aquamarine",
    "azure",
    "beige",
    "bisque",
    "black",
    "blanchedalmond",
    "blue",
    "blueviolet",
    "brown",
    "burlywood",
    "cadetblue",
    "chartreuse",
    "chocolate",
    "coral",
    "cornflowerblue",
    "cornsilk",
    "crimson",
    "cyan",
    "darkblue",
    "darkcyan",
    "darkgoldenrod",
    "darkgray",
    "darkgreen",
    "darkkhaki",
    "darkmagenta",
    "darkolivegreen",
    "darkorange",
    "darkorchid",
    "darkred",
    "darksalmon",
    "darkseagreen",
    "darkslateblue",
    "darkslategray",
    "darkturquoise",
    "darkviolet",
    "deeppink",
    "deepskyblue",
    "dimgray",
    "dodgerblue",
    "firebrick",
    "floralwhite",
    "forestgreen",
    "fuchsia",
    "gainsboro",
    "ghostwhite",
    "gold",
    "goldenrod",
    "gray",
    "grey",
    "green",
    "greenyellow",
    "honeydew",
    "hotpink",
    "indianred",
    "indigo",
    "ivory",
    "khaki",
    "lavender",
    "lavenderblush",
    "lawngreen",
    "lemonchiffon",
    "lightblue",
    "lightcoral",
    "lightcyan",
    "lightgoldenrodyellow",
    "lightgray",
    "lightgreen",
    "lightpink",
    "lightsalmon",
    "lightseagreen",
    "lightskyblue",
    "lightslategray",
    "lightsteelblue",
    "lightyellow",
    "lime",
    "limegreen",
    "linen",
    "magenta",
    "maroon",
    "mediumaquamarine",
    "mediumblue",
    "mediumorchid",
    "mediumpurple",
    "mediumseagreen",
    "mediumslateblue",
    "mediumspringgreen",
    "mediumturquoise",
    "mediumvioletred",
    "midnightblue",
    "mintcream",
    "mistyrose",
    "moccasin",
    "navajowhite",
    "navy",
    "oldlace",
    "olive",
    "olivedrab",
    "orange",
    "orangered",
    "orchid",
    "palegoldenrod",
    "palegreen",
    "paleturquoise",
    "palevioletred",
    "papayawhip",
    "peachpuff",
    "peru",
    "pink",
    "plum",
    "powderblue",
    "purple",
    "rebeccapurple",
    "red",
    "rosybrown",
    "royalblue",
    "saddlebrown",
    "salmon",
    "sandybrown",
    "seagreen",
    "seashell",
    "sienna",
    "silver",
    "skyblue",
    "slateblue",
    "slategray",
    "snow",
    "springgreen",
    "steelblue",
    "tan",
    "teal",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "white",
    "whitesmoke",
    "yellow",
    "yellowgreen"
].map((name72)=>({
        type: "constant",
        label: name72
    })
));
const tags1 = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "b",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "figcaption",
    "figure",
    "footer",
    "form",
    "header",
    "hgroup",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "meter",
    "nav",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "tr",
    "u",
    "ul"
].map((name73)=>({
        type: "type",
        label: name73
    })
);
const span = /^[\w-]*/;
const cssCompletionSource = (context)=>{
    let { state: state214 , pos  } = context, node = syntaxTree(state214).resolveInner(pos, -1);
    if (node.name == "PropertyName") return {
        from: node.from,
        options: properties(),
        span
    };
    if (node.name == "ValueName") return {
        from: node.from,
        options: values,
        span
    };
    if (node.name == "PseudoClassName") return {
        from: node.from,
        options: pseudoClasses,
        span
    };
    if (node.name == "TagName") {
        for(let { parent  } = node; parent; parent = parent.parent)if (parent.name == "Block") return {
            from: node.from,
            options: properties(),
            span
        };
        return {
            from: node.from,
            options: tags1,
            span
        };
    }
    if (!context.explicit) return null;
    let above = node.resolve(pos), before = above.childBefore(pos);
    if (before && before.name == ":" && above.name == "PseudoClassSelector") return {
        from: pos,
        options: pseudoClasses,
        span
    };
    if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList") return {
        from: pos,
        options: values,
        span
    };
    if (above.name == "Block") return {
        from: pos,
        options: properties(),
        span
    };
    return null;
};
const cssLanguage = LRLanguage.define({
    parser: parser2.configure({
        props: [
            indentNodeProp.add({
                Declaration: continuedIndent()
            }),
            foldNodeProp.add({
                Block: foldInside
            }),
            styleTags({
                "import charset namespace keyframes": tags.definitionKeyword,
                "media supports": tags.controlKeyword,
                "from to selector": tags.keyword,
                NamespaceName: tags.namespace,
                KeyframeName: tags.labelName,
                TagName: tags.tagName,
                ClassName: tags.className,
                PseudoClassName: tags.constant(tags.className),
                IdName: tags.labelName,
                "FeatureName PropertyName": tags.propertyName,
                AttributeName: tags.attributeName,
                NumberLiteral: tags.number,
                KeywordQuery: tags.keyword,
                UnaryQueryOp: tags.operatorKeyword,
                "CallTag ValueName": tags.atom,
                VariableName: tags.variableName,
                Callee: tags.operatorKeyword,
                Unit: tags.unit,
                "UniversalSelector NestingSelector": tags.definitionOperator,
                AtKeyword: tags.keyword,
                MatchOp: tags.compareOperator,
                "ChildOp SiblingOp, LogicOp": tags.logicOperator,
                BinOp: tags.arithmeticOperator,
                Important: tags.modifier,
                Comment: tags.blockComment,
                ParenthesizedContent: tags.special(tags.name),
                ColorLiteral: tags.color,
                StringLiteral: tags.string,
                ":": tags.punctuation,
                "PseudoOp #": tags.derefOperator,
                "; ,": tags.separator,
                "( )": tags.paren,
                "[ ]": tags.squareBracket,
                "{ }": tags.brace
            })
        ]
    }),
    languageData: {
        commentTokens: {
            block: {
                open: "/*",
                close: "*/"
            }
        },
        indentOnInput: /^\s*\}$/,
        wordChars: "-"
    }
});
const cssCompletion = cssLanguage.data.of({
    autocomplete: cssCompletionSource
});
function css() {
    return new LanguageSupport(cssLanguage, cssCompletion);
}
const space2 = [
    9,
    10,
    11,
    12,
    13,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
];
const dollar = 36;
const trackNewline = new ContextTracker({
    start: false,
    shift (context, term) {
        return term == 5 || term == 6 || term == 284 ? context : term == 285;
    },
    strict: false
});
const insertSemicolon = new ExternalTokenizer((input, stack)=>{
    let { next  } = input;
    if ((next == 125 || next == -1 || stack.context) && stack.canShift(282)) input.acceptToken(282);
}, {
    contextual: true,
    fallback: true
});
const noSemicolon = new ExternalTokenizer((input, stack)=>{
    let { next  } = input, after;
    if (space2.indexOf(next) > -1) return;
    if (next == 47 && ((after = input.peek(1)) == 47 || after == 42)) return;
    if (next != 125 && next != 59 && next != -1 && !stack.context && stack.canShift(279)) input.acceptToken(279);
}, {
    contextual: true
});
const incdecToken = new ExternalTokenizer((input, stack)=>{
    let { next  } = input;
    if (next == 43 || next == 45) {
        input.advance();
        if (next == input.next) {
            input.advance();
            let mayPostfix = !stack.context && stack.canShift(1);
            input.acceptToken(mayPostfix ? 1 : 2);
        }
    }
}, {
    contextual: true
});
const template = new ExternalTokenizer((input)=>{
    for(let afterDollar = false, i311 = 0;; i311++){
        let { next  } = input;
        if (next < 0) {
            if (i311) input.acceptToken(280);
            break;
        } else if (next == 96) {
            if (i311) input.acceptToken(280);
            else input.acceptToken(281, 1);
            break;
        } else if (next == 123 && afterDollar) {
            if (i311 == 1) input.acceptToken(3, 1);
            else input.acceptToken(280, -1);
            break;
        } else if (next == 10 && i311) {
            input.advance();
            input.acceptToken(280);
            break;
        } else if (next == 92) {
            input.advance();
        }
        afterDollar = next == dollar;
        input.advance();
    }
});
function tsExtends(value, stack) {
    return value == "extends" && stack.dialectEnabled(1) ? 4 : -1;
}
const spec_identifier1 = {
    __proto__: null,
    export: 18,
    as: 23,
    from: 29,
    default: 32,
    async: 37,
    function: 38,
    this: 48,
    true: 56,
    false: 56,
    void: 66,
    typeof: 70,
    null: 86,
    super: 88,
    new: 122,
    await: 139,
    yield: 141,
    delete: 142,
    class: 152,
    extends: 154,
    public: 197,
    private: 197,
    protected: 197,
    readonly: 199,
    instanceof: 220,
    in: 222,
    const: 224,
    import: 256,
    keyof: 307,
    unique: 311,
    infer: 317,
    is: 351,
    abstract: 371,
    implements: 373,
    type: 375,
    let: 378,
    var: 380,
    interface: 387,
    enum: 391,
    namespace: 397,
    module: 399,
    declare: 403,
    global: 407,
    for: 428,
    of: 437,
    while: 440,
    with: 444,
    do: 448,
    if: 452,
    else: 454,
    switch: 458,
    case: 464,
    try: 470,
    catch: 472,
    finally: 474,
    return: 478,
    throw: 482,
    break: 486,
    continue: 490,
    debugger: 494
};
const spec_word = {
    __proto__: null,
    async: 109,
    get: 111,
    set: 113,
    public: 161,
    private: 161,
    protected: 161,
    static: 163,
    abstract: 165,
    override: 167,
    readonly: 173,
    new: 355
};
const spec_LessThan = {
    __proto__: null,
    "<": 129
};
const parser3 = LRParser.deserialize({
    version: 13,
    states: "$1jO`QYOOO'QQ!LdO'#ChO'XOSO'#DVO)dQYO'#D]O)tQYO'#DhO){QYO'#DrO-xQYO'#DxOOQO'#E]'#E]O.]QWO'#E[O.bQWO'#E[OOQ!LS'#Ef'#EfO0aQ!LdO'#IrO2wQ!LdO'#IsO3eQWO'#EzO3jQpO'#FaOOQ!LS'#FS'#FSO3rO!bO'#FSO4QQWO'#FhO5_QWO'#FgOOQ!LS'#Is'#IsOOQ!LQ'#Ir'#IrOOQQ'#J['#J[O5dQWO'#HnO5iQ!LYO'#HoOOQQ'#If'#IfOOQQ'#Hp'#HpQ`QYOOO){QYO'#DjO5qQWO'#G[O5vQ#tO'#CmO6UQWO'#EZO6aQWO'#EgO6fQ#tO'#FRO7QQWO'#G[O7VQWO'#G`O7bQWO'#G`O7pQWO'#GcO7pQWO'#GdO7pQWO'#GfO5qQWO'#GiO8aQWO'#GlO9oQWO'#CdO:PQWO'#GyO:XQWO'#HPO:XQWO'#HRO`QYO'#HTO:XQWO'#HVO:XQWO'#HYO:^QWO'#H`O:cQ!LZO'#HdO){QYO'#HfO:nQ!LZO'#HhO:yQ!LZO'#HjO5iQ!LYO'#HlO){QYO'#DWOOOS'#Hr'#HrO;UOSO,59qOOQ!LS,59q,59qO=gQbO'#ChO=qQYO'#HsO>UQWO'#ItO@TQbO'#ItO'dQYO'#ItO@[QWO,59wO@rQ&jO'#DbOAkQWO'#E]OAxQWO'#JPOBTQWO'#JOOBTQWO'#JOOB]QWO,5:yOBbQWO'#I}OBiQWO'#DyO5vQ#tO'#EZOBwQWO'#EZOCSQ`O'#FROOQ!LS,5:S,5:SOC[QYO,5:SOEYQ!LdO,5:^OEvQWO,5:dOFaQ!LYO'#I|O7VQWO'#I{OFhQWO'#I{OFpQWO,5:xOFuQWO'#I{OGTQYO,5:vOITQWO'#EWOJ_QWO,5:vOKnQWO'#DlOKuQYO'#DqOLPQ&jO,5;PO){QYO,5;POOQQ'#Er'#ErOOQQ'#Et'#EtO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;ROOQQ'#Ex'#ExOLXQYO,5;cOOQ!LS,5;h,5;hOOQ!LS,5;i,5;iONXQWO,5;iOOQ!LS,5;j,5;jO){QYO'#H}ON^Q!LYO,5<TONxQWO,5;RO){QYO,5;fO! bQpO'#JTO! PQpO'#JTO! iQpO'#JTO! zQpO,5;qOOOO,5;{,5;{O!!YQYO'#FcOOOO'#H|'#H|O3rO!bO,5;nO!!aQpO'#FeOOQ!LS,5;n,5;nO!!}Q,UO'#CrOOQ!LS'#Cu'#CuO!#bQWO'#CuO!#gOSO'#CyO!$TQ#tO,5<QO!$[QWO,5<SO!%hQWO'#FrO!%uQWO'#FsO!%zQWO'#FwO!&|Q&jO'#F{O!'oQ,UO'#IoOOQ!LS'#Io'#IoO!'yQWO'#InO!(XQWO'#ImOOQ!LS'#Cs'#CsOOQ!LS'#C|'#C|O!(aQWO'#DOOJdQWO'#FjOJdQWO'#FlO!(fQWO'#FnO!(kQWO'#FoO!(pQWO'#FuOJdQWO'#FzO!(uQWO'#E^O!)^QWO,5<RO`QYO,5>YOOQQ'#Ii'#IiOOQQ,5>Z,5>ZOOQQ-E;n-E;nO!+YQ!LdO,5:UOOQ!LQ'#Cp'#CpO!+yQ#tO,5<vOOQO'#Cf'#CfO!,[QWO'#CqO!,dQ!LYO'#IjO5_QWO'#IjO:^QWO,59XO!,rQpO,59XO!,zQ#tO,59XO5vQ#tO,59XO!-VQWO,5:vO!-_QWO'#GxO!-mQWO'#J`O){QYO,5;kO!-uQ&jO,5;mO!-zQWO,5=cO!.PQWO,5=cO!.UQWO,5=cO5iQ!LYO,5=cO5qQWO,5<vO!.dQWO'#E_O!.xQ&jO'#E`OOQ!LQ'#I}'#I}O!/ZQ!LYO'#J]O5iQ!LYO,5<zO7pQWO,5=QOOQO'#Cr'#CrO!/fQpO,5<}O!/nQ#tO,5=OO!/yQWO,5=QO!0OQ`O,5=TO:^QWO'#GnO5qQWO'#GpO!0WQWO'#GpO5vQ#tO'#GsO!0]QWO'#GsOOQQ,5=W,5=WO!0bQWO'#GtO!0jQWO'#CmO!0oQWO,59OO!0yQWO,59OO!2{QYO,59OOOQQ,59O,59OO!3YQ!LYO,59OO){QYO,59OO!3eQYO'#G{OOQQ'#G|'#G|OOQQ'#G}'#G}O`QYO,5=eO!3uQWO,5=eO){QYO'#DxO`QYO,5=kO`QYO,5=mO!3zQWO,5=oO`QYO,5=qO!4PQWO,5=tO!4UQYO,5=zOOQQ,5>O,5>OO){QYO,5>OO5iQ!LYO,5>QOOQQ,5>S,5>SO!8VQWO,5>SOOQQ,5>U,5>UO!8VQWO,5>UOOQQ,5>W,5>WO!8[Q`O,59rOOOS-E;p-E;pOOQ!LS1G/]1G/]O!8aQbO,5>_O'dQYO,5>_OOQO,5>d,5>dO!8kQYO'#HsOOQO-E;q-E;qO!8xQWO,5?`O!9QQbO,5?`O!9XQWO,5?jOOQ!LS1G/c1G/cO!9aQpO'#DTOOQO'#Iv'#IvO){QYO'#IvO!:OQpO'#IvO!:mQpO'#DcO!;OQ&jO'#DcO!=ZQYO'#DcO!=bQWO'#IuO!=jQWO,59|O!=oQWO'#EaO!=}QWO'#JQO!>VQWO,5:zO!>mQ&jO'#DcO){QYO,5?kO!>wQWO'#HxOOQO-E;v-E;vO!9XQWO,5?jOOQ!LQ1G0e1G0eO!@TQ&jO'#D|OOQ!LS,5:e,5:eO){QYO,5:eOITQWO,5:eO!@[QWO,5:eO:^QWO,5:uO!,rQpO,5:uO!,zQ#tO,5:uO5vQ#tO,5:uOOQ!LS1G/n1G/nOOQ!LS1G0O1G0OOOQ!LQ'#EV'#EVO){QYO,5?hO!@gQ!LYO,5?hO!@xQ!LYO,5?hO!APQWO,5?gO!AXQWO'#HzO!APQWO,5?gOOQ!LQ1G0d1G0dO7VQWO,5?gOOQ!LS1G0b1G0bO!AsQ!LdO1G0bO!BdQ!LbO,5:rOOQ!LS'#Fq'#FqO!CQQ!LdO'#IoOGTQYO1G0bO!EPQ#tO'#IwO!EZQWO,5:WO!E`QbO'#IxO){QYO'#IxO!EjQWO,5:]OOQ!LS'#DT'#DTOOQ!LS1G0k1G0kO!EoQWO1G0kO!HQQ!LdO1G0mO!HXQ!LdO1G0mO!JlQ!LdO1G0mO!JsQ!LdO1G0mO!LzQ!LdO1G0mO!M_Q!LdO1G0mO#!OQ!LdO1G0mO#!VQ!LdO1G0mO#$jQ!LdO1G0mO#$qQ!LdO1G0mO#&fQ!LdO1G0mO#)`Q7^O'#ChO#+ZQ7^O1G0}O#-UQ7^O'#IsOOQ!LS1G1T1G1TO#-iQ!LdO,5>iOOQ!LQ-E;{-E;{O#.YQ!LdO1G0mOOQ!LS1G0m1G0mO#0[Q!LdO1G1QO#0{QpO,5;sO#1QQpO,5;tO#1VQpO'#F[O#1kQWO'#FZOOQO'#JU'#JUOOQO'#H{'#H{O#1pQpO1G1]OOQ!LS1G1]1G1]OOOO1G1f1G1fO#2OQ7^O'#IrO#2YQWO,5;}OLXQYO,5;}OOOO-E;z-E;zOOQ!LS1G1Y1G1YOOQ!LS,5<P,5<PO#2_QpO,5<POOQ!LS,59a,59aOITQWO'#C{OOOS'#Hq'#HqO#2dOSO,59eOOQ!LS,59e,59eO){QYO1G1lO!(kQWO'#IPO#2oQWO,5<eOOQ!LS,5<b,5<bOOQO'#GV'#GVOJdQWO,5<pOOQO'#GX'#GXOJdQWO,5<rOJdQWO,5<tOOQO1G1n1G1nO#2zQ`O'#CpO#3_Q`O,5<^O#3fQWO'#JXO5qQWO'#JXO#3tQWO,5<`OJdQWO,5<_O#3yQ`O'#FqO#4WQ`O'#JYO#4bQWO'#JYOITQWO'#JYO#4gQWO,5<cOOQ!LQ'#Dg'#DgO#4lQWO'#FtO#4wQpO'#F|O!&wQ&jO'#F|O!&wQ&jO'#GOO#5YQWO'#GPO!(pQWO'#GSOOQO'#IR'#IRO#5_Q&jO,5<gOOQ!LS,5<g,5<gO#5fQ&jO'#F|O#5tQ&jO'#F}O#5|Q&jO'#F}OOQ!LS,5<u,5<uOJdQWO,5?YOJdQWO,5?YO#6RQWO'#ISO#6^QWO,5?XOOQ!LS'#Ch'#ChO#7QQ#tO,59jOOQ!LS,59j,59jO#7sQ#tO,5<UO#8fQ#tO,5<WO#8pQWO,5<YOOQ!LS,5<Z,5<ZO#8uQWO,5<aO#8zQ#tO,5<fOGTQYO1G1mO#9[QWO1G1mOOQQ1G3t1G3tOOQ!LS1G/p1G/pONXQWO1G/pOOQQ1G2b1G2bOITQWO1G2bO){QYO1G2bOITQWO1G2bO#9aQWO1G2bO#9oQWO,59]O#:xQWO'#EWOOQ!LQ,5?U,5?UO#;SQ!LYO,5?UOOQQ1G.s1G.sO:^QWO1G.sO!,rQpO1G.sO!,zQ#tO1G.sO#;bQWO1G0bO#;gQWO'#ChO#;rQWO'#JaO#;zQWO,5=dO#<PQWO'#JaO#<UQWO'#JaO#<^QWO'#I[O#<lQWO,5?zO#<tQbO1G1VOOQ!LS1G1X1G1XO5qQWO1G2}O#<{QWO1G2}O#=QQWO1G2}O#=VQWO1G2}OOQQ1G2}1G2}O#=[Q#tO1G2bO7VQWO'#JOO7VQWO'#EaO7VQWO'#IUO#=mQ!LYO,5?wOOQQ1G2f1G2fO!/yQWO1G2lOITQWO1G2iO#=xQWO1G2iOOQQ1G2j1G2jOITQWO1G2jO#=}QWO1G2jO#>VQ&jO'#GhOOQQ1G2l1G2lO!&wQ&jO'#IWO!0OQ`O1G2oOOQQ1G2o1G2oOOQQ,5=Y,5=YO#>_Q#tO,5=[O5qQWO,5=[O#5YQWO,5=_O5_QWO,5=_O!,rQpO,5=_O!,zQ#tO,5=_O5vQ#tO,5=_O#>pQWO'#J_O#>{QWO,5=`OOQQ1G.j1G.jO#?QQ!LYO1G.jO#?]QWO1G.jO#?bQWO1G.jO5iQ!LYO1G.jO#?jQbO,5?|O#?tQWO,5?|O#@PQYO,5=gO#@WQWO,5=gO7VQWO,5?|OOQQ1G3P1G3PO`QYO1G3POOQQ1G3V1G3VOOQQ1G3X1G3XO:XQWO1G3ZO#@]QYO1G3]O#DWQYO'#H[OOQQ1G3`1G3`O:^QWO1G3fO#DeQWO1G3fO5iQ!LYO1G3jOOQQ1G3l1G3lOOQ!LQ'#Fx'#FxO5iQ!LYO1G3nO5iQ!LYO1G3pOOOS1G/^1G/^O#DmQ`O,5<TO#DuQbO1G3yOOQO1G4O1G4OO){QYO,5>_O#EPQWO1G4zO#EXQWO1G5UO#EaQWO,5?bOLXQYO,5:{O7VQWO,5:{O:^QWO,59}OLXQYO,59}O!,rQpO,59}O#EfQ7^O,59}OOQO,5:{,5:{O#EpQ&jO'#HtO#FWQWO,5?aOOQ!LS1G/h1G/hO#F`Q&jO'#HyO#FtQWO,5?lOOQ!LQ1G0f1G0fO!;OQ&jO,59}O#F|QbO1G5VO7VQWO,5>dOOQ!LQ'#ES'#ESO#GWQ!LrO'#ETO!?{Q&jO'#D}OOQO'#Hw'#HwO#GrQ&jO,5:hOOQ!LS,5:h,5:hO#GyQ&jO'#D}O#H[Q&jO'#D}O#HcQ&jO'#EYO#HfQ&jO'#ETO#HsQ&jO'#ETO!?{Q&jO'#ETO#IWQWO1G0PO#I]Q`O1G0POOQ!LS1G0P1G0PO){QYO1G0POITQWO1G0POOQ!LS1G0a1G0aO:^QWO1G0aO!,rQpO1G0aO!,zQ#tO1G0aO#IdQ!LdO1G5SO){QYO1G5SO#ItQ!LYO1G5SO#JVQWO1G5RO7VQWO,5>fOOQO,5>f,5>fO#J_QWO,5>fOOQO-E;x-E;xO#JVQWO1G5RO#JmQ!LdO,59jO#LlQ!LdO,5<UO#NnQ!LdO,5<WO$!pQ!LdO,5<fOOQ!LS7+%|7+%|O$$xQ!LdO7+%|O$%iQWO'#HuO$%sQWO,5?cOOQ!LS1G/r1G/rO$%{QYO'#HvO$&YQWO,5?dO$&bQbO,5?dOOQ!LS1G/w1G/wOOQ!LS7+&V7+&VO$&lQ7^O,5:^O){QYO7+&iO$&vQ7^O,5:UOOQO1G1_1G1_OOQO1G1`1G1`O$'TQMhO,5;vOLXQYO,5;uOOQO-E;y-E;yOOQ!LS7+&w7+&wOOOO7+'Q7+'QOOOO1G1i1G1iO$'`QWO1G1iOOQ!LS1G1k1G1kO$'eQ`O,59gOOOS-E;o-E;oOOQ!LS1G/P1G/PO$'lQ!LdO7+'WOOQ!LS,5>k,5>kO$(]QWO,5>kOOQ!LS1G2P1G2PP$(bQWO'#IPPOQ!LS-E;}-E;}O$)RQ#tO1G2[O$)tQ#tO1G2^O$*OQ#tO1G2`OOQ!LS1G1x1G1xO$*VQWO'#IOO$*eQWO,5?sO$*eQWO,5?sO$*mQWO,5?sO$*xQWO,5?sOOQO1G1z1G1zO$+WQ#tO1G1yO$+hQWO'#IQO$+xQWO,5?tOITQWO,5?tO$,QQ`O,5?tOOQ!LS1G1}1G1}O5iQ!LYO,5<hO5iQ!LYO,5<iO$,[QWO,5<iO#5TQWO,5<iO!,rQpO,5<hO$,aQWO,5<jO5iQ!LYO,5<kO$,[QWO,5<nOOQO-E<P-E<POOQ!LS1G2R1G2RO!&wQ&jO,5<hO$,iQWO,5<iO!&wQ&jO,5<jO!&wQ&jO,5<iO$,tQ#tO1G4tO$-OQ#tO1G4tOOQO,5>n,5>nOOQO-E<Q-E<QO!-uQ&jO,59lO){QYO,59lO$-]QWO1G1tOJdQWO1G1{O$-bQ!LdO7+'XOOQ!LS7+'X7+'XOGTQYO7+'XOOQ!LS7+%[7+%[O$.RQ`O'#JZO#IWQWO7+'|O$.]QWO7+'|O$.eQ`O7+'|OOQQ7+'|7+'|OITQWO7+'|O){QYO7+'|OITQWO7+'|OOQO1G.w1G.wO$.oQ!LbO'#ChO$/PQ!LbO,5<lO$/nQWO,5<lOOQ!LQ1G4p1G4pOOQQ7+$_7+$_O:^QWO7+$_O!,rQpO7+$_OGTQYO7+%|O$/sQWO'#IZO$0UQWO,5?{OOQO1G3O1G3OO5qQWO,5?{O$0UQWO,5?{O$0^QWO,5?{OOQO,5>v,5>vOOQO-E<Y-E<YOOQ!LS7+&q7+&qO$0cQWO7+(iO5iQ!LYO7+(iO5qQWO7+(iO$0hQWO7+(iO$0mQWO7+'|OOQ!LQ,5>p,5>pOOQ!LQ-E<S-E<SOOQQ7+(W7+(WO$0{Q!LbO7+(TOITQWO7+(TO$1VQ`O7+(UOOQQ7+(U7+(UOITQWO7+(UO$1^QWO'#J^O$1iQWO,5=SOOQO,5>r,5>rOOQO-E<U-E<UOOQQ7+(Z7+(ZO$2cQ&jO'#GqOOQQ1G2v1G2vOITQWO1G2vO){QYO1G2vOITQWO1G2vO$2jQWO1G2vO$2xQ#tO1G2vO5iQ!LYO1G2yO#5YQWO1G2yO5_QWO1G2yO!,rQpO1G2yO!,zQ#tO1G2yO$3ZQWO'#IYO$3fQWO,5?yO$3nQ&jO,5?yOOQ!LQ1G2z1G2zOOQQ7+$U7+$UO$3vQWO7+$UO5iQ!LYO7+$UO$3{QWO7+$UO){QYO1G5hO){QYO1G5iO$4QQYO1G3RO$4XQWO1G3RO$4^QYO1G3RO$4eQ!LYO1G5hOOQQ7+(k7+(kO5iQ!LYO7+(uO`QYO7+(wOOQQ'#Jd'#JdOOQQ'#I]'#I]O$4oQYO,5=vOOQQ,5=v,5=vO){QYO'#H]O$4|QWO'#H_OOQQ7+)Q7+)QO$5RQYO7+)QO7VQWO7+)QOOQQ7+)U7+)UOOQQ7+)Y7+)YOOQQ7+)[7+)[OOQO1G4|1G4|O$9PQ7^O1G0gO$9ZQWO1G0gOOQO1G/i1G/iO$9fQ7^O1G/iO:^QWO1G/iOLXQYO'#DcOOQO,5>`,5>`OOQO-E;r-E;rOOQO,5>e,5>eOOQO-E;w-E;wO!,rQpO1G/iO:^QWO,5:iOOQO,5:o,5:oO){QYO,5:oO$9pQ!LYO,5:oO$9{Q!LYO,5:oO!,rQpO,5:iOOQO-E;u-E;uOOQ!LS1G0S1G0SO!?{Q&jO,5:iO$:ZQ&jO,5:iO$:lQ!LrO,5:oO$;WQ&jO,5:iO!?{Q&jO,5:oOOQO,5:t,5:tO$;_Q&jO,5:oO$;lQ!LYO,5:oOOQ!LS7+%k7+%kO#IWQWO7+%kO#I]Q`O7+%kOOQ!LS7+%{7+%{O:^QWO7+%{O!,rQpO7+%{O$<QQ!LdO7+*nO){QYO7+*nOOQO1G4Q1G4QO7VQWO1G4QO$<bQWO7+*mO$<jQ!LdO1G2[O$>lQ!LdO1G2^O$@nQ!LdO1G1yO$BvQ#tO,5>aOOQO-E;s-E;sO$CQQbO,5>bO){QYO,5>bOOQO-E;t-E;tO$C[QWO1G5OO$CdQ7^O1G0bO$EkQ7^O1G0mO$ErQ7^O1G0mO$GsQ7^O1G0mO$GzQ7^O1G0mO$IoQ7^O1G0mO$JSQ7^O1G0mO$LaQ7^O1G0mO$LhQ7^O1G0mO$NiQ7^O1G0mO$NpQ7^O1G0mO%!eQ7^O1G0mO%!xQ!LdO<<JTO%#iQ7^O1G0mO%%XQ7^O'#IoO%'UQ7^O1G1QOLXQYO'#F^OOQO'#JV'#JVOOQO1G1b1G1bO%'cQWO1G1aO%'hQ7^O,5>iOOOO7+'T7+'TOOOS1G/R1G/ROOQ!LS1G4V1G4VOJdQWO7+'zO%'rQWO,5>jO5qQWO,5>jOOQO-E;|-E;|O%(QQWO1G5_O%(QQWO1G5_O%(YQWO1G5_O%(eQ`O,5>lO%(oQWO,5>lOITQWO,5>lOOQO-E<O-E<OO%(tQ`O1G5`O%)OQWO1G5`OOQO1G2S1G2SOOQO1G2T1G2TO5iQ!LYO1G2TO$,[QWO1G2TO5iQ!LYO1G2SO%)WQWO1G2UOITQWO1G2UOOQO1G2V1G2VO5iQ!LYO1G2YO!,rQpO1G2SO#5TQWO1G2TO%)]QWO1G2UO%)eQWO1G2TOJdQWO7+*`OOQ!LS1G/W1G/WO%)pQWO1G/WOOQ!LS7+'`7+'`O%)uQ#tO7+'gO%*VQ!LdO<<JsOOQ!LS<<Js<<JsOITQWO'#ITO%*vQWO,5?uOOQQ<<Kh<<KhOITQWO<<KhO#IWQWO<<KhO%+OQWO<<KhO%+WQ`O<<KhOITQWO1G2WOOQQ<<Gy<<GyO:^QWO<<GyO%+bQ!LdO<<IhOOQ!LS<<Ih<<IhOOQO,5>u,5>uO%,RQWO,5>uO%,WQWO,5>uOOQO-E<X-E<XO%,`QWO1G5gO%,`QWO1G5gO5qQWO1G5gO%,hQWO<<LTOOQQ<<LT<<LTO%,mQWO<<LTO5iQ!LYO<<LTO){QYO<<KhOITQWO<<KhOOQQ<<Ko<<KoO$0{Q!LbO<<KoOOQQ<<Kp<<KpO$1VQ`O<<KpO%,rQ&jO'#IVO%,}QWO,5?xOLXQYO,5?xOOQQ1G2n1G2nO#GWQ!LrO'#ETO!?{Q&jO'#GrOOQO'#IX'#IXO%-VQ&jO,5=]OOQQ,5=],5=]O%-^Q&jO'#ETO%-iQ&jO'#ETO%.QQ&jO'#ETO%.[Q&jO'#GrO%.mQWO7+(bO%.rQWO7+(bO%.zQ`O7+(bOOQQ7+(b7+(bOITQWO7+(bO){QYO7+(bOITQWO7+(bO%/UQWO7+(bOOQQ7+(e7+(eO5iQ!LYO7+(eO#5YQWO7+(eO5_QWO7+(eO!,rQpO7+(eO%/dQWO,5>tOOQO-E<W-E<WOOQO'#Gu'#GuO%/oQWO1G5eO5iQ!LYO<<GpOOQQ<<Gp<<GpO%/wQWO<<GpO%/|QWO7++SO%0RQWO7++TOOQQ7+(m7+(mO%0WQWO7+(mO%0]QYO7+(mO%0dQWO7+(mO){QYO7++SO){QYO7++TOOQQ<<La<<LaOOQQ<<Lc<<LcOOQQ-E<Z-E<ZOOQQ1G3b1G3bO%0iQWO,5=wOOQQ,5=y,5=yO:^QWO<<LlO%0nQWO<<LlOLXQYO7+&ROOQO7+%T7+%TO%0sQ7^O1G5VO:^QWO7+%TOOQO1G0T1G0TO%0}Q!LdO1G0ZOOQO1G0Z1G0ZO){QYO1G0ZO%1XQ!LYO1G0ZO:^QWO1G0TO!,rQpO1G0TO!?{Q&jO1G0TO%1dQ!LYO1G0ZO%1rQ&jO1G0TO%2TQ!LYO1G0ZO%2iQ!LrO1G0ZO%2sQ&jO1G0TO!?{Q&jO1G0ZOOQ!LS<<IV<<IVOOQ!LS<<Ig<<IgO:^QWO<<IgO%2zQ!LdO<<NYOOQO7+)l7+)lO%3[Q!LdO7+'gO%5dQbO1G3|O%5nQ7^O7+%|O%5{Q7^O,59jO%7xQ7^O,5<UO%9uQ7^O,5<WO%;rQ7^O,5<fO%=bQ7^O7+'WO%=oQ7^O7+'XO%=|QWO,5;xOOQO7+&{7+&{O%>RQ#tO<<KfOOQO1G4U1G4UO%>cQWO1G4UO%>nQWO1G4UO%>|QWO7+*yO%>|QWO7+*yOITQWO1G4WO%?UQ`O1G4WO%?`QWO7+*zOOQO7+'o7+'oO5iQ!LYO7+'oOOQO7+'n7+'nO$,[QWO7+'pO%?hQ`O7+'pOOQO7+'t7+'tO5iQ!LYO7+'nO$,[QWO7+'oO%?oQWO7+'pOITQWO7+'pO#5TQWO7+'oO%?tQ#tO<<MzOOQ!LS7+$r7+$rO%@OQ`O,5>oOOQO-E<R-E<RO#IWQWOANASOOQQANASANASOITQWOANASO%@YQ!LbO7+'rOOQQAN=eAN=eO5qQWO1G4aOOQO1G4a1G4aO%@gQWO1G4aO%@lQWO7++RO%@lQWO7++RO5iQ!LYOANAoO%@tQWOANAoOOQQANAoANAoO%@yQWOANASO%ARQ`OANASOOQQANAZANAZOOQQANA[ANA[O%A]QWO,5>qOOQO-E<T-E<TO%AhQ7^O1G5dO#5YQWO,5=^O5_QWO,5=^O!,rQpO,5=^OOQO-E<V-E<VOOQQ1G2w1G2wO$:lQ!LrO,5:oO!?{Q&jO,5=^O%ArQ&jO,5=^O%BTQ&jO,5:oOOQQ<<K|<<K|OITQWO<<K|O%.mQWO<<K|O%B_QWO<<K|O%BgQ`O<<K|O){QYO<<K|OITQWO<<K|OOQQ<<LP<<LPO5iQ!LYO<<LPO#5YQWO<<LPO5_QWO<<LPO%BqQ&jO1G4`O%ByQWO7++POOQQAN=[AN=[O5iQ!LYOAN=[OOQQ<<Nn<<NnOOQQ<<No<<NoOOQQ<<LX<<LXO%CRQWO<<LXO%CWQYO<<LXO%C_QWO<<NnO%CdQWO<<NoOOQQ1G3c1G3cOOQQANBWANBWO:^QWOANBWO%CiQ7^O<<ImOOQO<<Ho<<HoOOQO7+%u7+%uO%0}Q!LdO7+%uO){QYO7+%uOOQO7+%o7+%oO:^QWO7+%oO!,rQpO7+%oO%CsQ!LYO7+%uO!?{Q&jO7+%oO%DOQ!LYO7+%uO%D^Q&jO7+%oO%DoQ!LYO7+%uOOQ!LSAN?RAN?RO%ETQ!LdO<<KfO%G]Q7^O<<JTO%GjQ7^O1G1yO%IYQ7^O1G2[O%KVQ7^O1G2^O%MSQ7^O<<JsO%MaQ7^O<<IhOOQO1G1d1G1dOOQO7+)p7+)pO%MnQWO7+)pO%MyQWO<<NeO%NRQ`O7+)rOOQO<<KZ<<KZO5iQ!LYO<<K[O$,[QWO<<K[OOQO<<KY<<KYO5iQ!LYO<<KZO%N]Q`O<<K[O$,[QWO<<KZOOQQG26nG26nO#IWQWOG26nOOQO7+){7+){O5qQWO7+){O%NdQWO<<NmOOQQG27ZG27ZO5iQ!LYOG27ZOITQWOG26nOLXQYO1G4]O%NlQWO7++OO5iQ!LYO1G2xO#5YQWO1G2xO5_QWO1G2xO!,rQpO1G2xO!?{Q&jO1G2xO%2iQ!LrO1G0ZO%NtQ&jO1G2xO%.mQWOANAhOOQQANAhANAhOITQWOANAhO& VQWOANAhO& _Q`OANAhOOQQANAkANAkO5iQ!LYOANAkO#5YQWOANAkOOQO'#Gv'#GvOOQO7+)z7+)zOOQQG22vG22vOOQQANAsANAsO& iQWOANAsOOQQANDYANDYOOQQANDZANDZO& nQYOG27rOOQO<<Ia<<IaO%0}Q!LdO<<IaOOQO<<IZ<<IZO:^QWO<<IZO){QYO<<IaO!,rQpO<<IZO&%lQ!LYO<<IaO!?{Q&jO<<IZO&%wQ!LYO<<IaO&&VQ7^O7+'gOOQO<<M[<<M[OOQOAN@vAN@vO5iQ!LYOAN@vOOQOAN@uAN@uO$,[QWOAN@vO5iQ!LYOAN@uOOQQLD,YLD,YOOQO<<Mg<<MgOOQQLD,uLD,uO#IWQWOLD,YO&'uQ7^O7+)wOOQO7+(d7+(dO5iQ!LYO7+(dO#5YQWO7+(dO5_QWO7+(dO!,rQpO7+(dO!?{Q&jO7+(dOOQQG27SG27SO%.mQWOG27SOITQWOG27SOOQQG27VG27VO5iQ!LYOG27VOOQQG27_G27_O:^QWOLD-^OOQOAN>{AN>{OOQOAN>uAN>uO%0}Q!LdOAN>{O:^QWOAN>uO){QYOAN>{O!,rQpOAN>uO&(PQ!LYOAN>{O&([Q7^O<<KfOOQOG26bG26bO5iQ!LYOG26bOOQOG26aG26aOOQQ!$( t!$( tOOQO<<LO<<LOO5iQ!LYO<<LOO#5YQWO<<LOO5_QWO<<LOO!,rQpO<<LOOOQQLD,nLD,nO%.mQWOLD,nOOQQLD,qLD,qOOQQ!$(!x!$(!xOOQOG24gG24gOOQOG24aG24aO%0}Q!LdOG24gO:^QWOG24aO){QYOG24gOOQOLD+|LD+|OOQOANAjANAjO5iQ!LYOANAjO#5YQWOANAjO5_QWOANAjOOQQ!$(!Y!$(!YOOQOLD*RLD*ROOQOLD){LD){O%0}Q!LdOLD*ROOQOG27UG27UO5iQ!LYOG27UO#5YQWOG27UOOQO!$'Mm!$'MmOOQOLD,pLD,pO5iQ!LYOLD,pOOQO!$(![!$(![OLXQYO'#DrO&)zQbO'#IrOLXQYO'#DjO&*RQ!LdO'#ChO&*lQbO'#ChO&*|QYO,5:vOLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO'#H}O&,|QWO,5<TO&.`QWO,5;ROLXQYO,5;fO!(aQWO'#DOO!(aQWO'#DOOITQWO'#FjO&-UQWO'#FjOITQWO'#FlO&-UQWO'#FlOITQWO'#FzO&-UQWO'#FzOLXQYO,5?kO&*|QYO1G0bO&.gQ7^O'#ChOLXQYO1G1lOITQWO,5<pO&-UQWO,5<pOITQWO,5<rO&-UQWO,5<rOITQWO,5<_O&-UQWO,5<_O&*|QYO1G1mOLXQYO7+&iOITQWO1G1{O&-UQWO1G1{O&*|QYO7+'XO&*|QYO7+%|OITQWO7+'zO&-UQWO7+'zO&.qQWO'#E[O&.vQWO'#E[O&/OQWO'#EzO&/TQWO'#EgO&/YQWO'#JPO&/eQWO'#I}O&/pQWO,5:vO&/uQ#tO,5<QO&/|QWO'#FsO&0RQWO'#FsO&0WQWO,5<RO&0`QWO,5:vO&0hQ7^O1G0}O&0oQWO,5<aO&0tQWO,5<aO&0yQWO1G1mO&1OQWO1G0bO&1TQ#tO1G2`O&1[Q#tO1G2`O4QQWO'#FhO5_QWO'#FgOBwQWO'#EZOLXQYO,5;cO!(pQWO'#FuO!(pQWO'#FuOJdQWO,5<tOJdQWO,5<t",
    stateData: "&2X~O'WOS'XOSTOSUOS~OPTOQTOXyO]cO_hObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#dsO#tpO#x^O%PqO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO%axO%nzO%t{O%v|O%x}O%z!OO%}!PO&T!QO&X!RO&Z!SO&]!TO&_!UO&a!VO'ZPO'dQO'mYO'zaO~OP[XZ[X_[Xj[Xu[Xv[Xx[X!R[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'U[X'd[X'n[X'u[X'v[X~O!]$lX~P$zOR!WO'S!XO'T!ZO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z![O'dQO'mYO'zaO~O!Q!`O!R!]O!O'hP!O'rP~P'dO!S!mO~P`OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'dQO'mYO'zaO~O!Q!rO#U!uO#V!rO'Z9ZO!c'oP~P+{O#W!vO~O!]!wO#W!vO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R#bO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_'fX'U'fX!c'fX!O'fX!T'fX%Q'fX!]'fX~P.jO!{#eO#o#eOP'gXZ'gX_'gXj'gXu'gXv'gXx'gX!R'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX~O#c'gX'U'gX!O'gX!c'gXn'gX!T'gX%Q'gX!]'gX~P0zO!{#eO~O#z#fO$R#jO~O!T#kO#x^O$U#lO$W#nO~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z#pO'd#sO'_'aP~O!d$XO~O!]$ZO~O_$[O'U$[O~O'Z$`O~O!d$XO'Z$`O'[$bO'`$cO~Oc$iO!d$XO'Z$`O~O#c#TO~O]$rOu$nO!T$kO!d$mO%R$qO'Z$`O'[$bO^(SP~O!n$sO~Ox$tO!T$uO'Z$`O~Ox$tO!T$uO%Z$yO'Z$`O~O'Z$zO~O#dsO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO~Ob%TOc%SO!n%QO%P%RO%c%PO~P7uOb%WOcmO!T%VO!nlO#dsO%PqO%TrO%UrO%XuO%ZvO%^wO%_wO%axO~O`%ZO!{%^O%R%XO'[$bO~P8tO!d%_O!g%cO~O!d%dO~O!TSO~O_$[O'R%lO'U$[O~O_$[O'R%oO'U$[O~O_$[O'R%qO'U$[O~OR!WO'S!XO'T%uO~OP[XZ[Xj[Xu[Xv[Xx[X!R[X!RdX!a[X!b[X!d[X!j[X!{[X!{dX#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X~O!O[X!OdX~P;aO!Q%wO!O&gX!O&lX!R&gX!R&lX~P'dO!R%yO!O'hX~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R%yO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O!O'hX~P>^O!O&OO~Ox&RO!W&]O!X&UO!Y&UO'[$bO~O]&SOk&SO!Q&VO'e&PO!S'iP!S'tP~P@aO!O'qX!R'qX!]'qX!c'qX'n'qX~O!{'qX#W#PX!S'qX~PAYO!{&^O!O'sX!R'sX~O!R&_O!O'rX~O!O&bO~O!{#eO~PAYOS&fO!T&cO!o&eO'Z$`O~Oc&kO!d$XO'Z$`O~Ou$nO!d$mO~O!S&lO~P`Ou!{Ov!{Ox!|O!b!yO!d!zO'dQOP!faZ!faj!fa!R!fa!a!fa!j!fa#[!fa#]!fa#^!fa#_!fa#`!fa#a!fa#b!fa#c!fa#e!fa#g!fa#i!fa#j!fa'n!fa'u!fa'v!fa~O_!fa'U!fa!O!fa!c!fan!fa!T!fa%Q!fa!]!fa~PCcO!c&mO~O!]!wO!{&oO'n&nO!R'pX_'pX'U'pX~O!c'pX~PE{O!R&sO!c'oX~O!c&uO~Ox$tO!T$uO#V&vO'Z$`O~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'Z&zO'd#sO~O#W&|O~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z&zO'd#sO~O'_'kP~PJdO!Q'QO!c'lP~P){O'e'SO'mYO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!d!zO~O!R#bO_$]a'U$]a!c$]a!O$]a!T$]a%Q$]a!]$]a~O#d'iO~PITO!]'kO!T'wX#w'wX#z'wX$R'wX~Ou'lO~P! POu'lO!T'wX#w'wX#z'wX$R'wX~O!T'nO#w'rO#z'mO$R'sO~O!Q'vO~PLXO#z#fO$R'yO~Ou$eXx$eX!b$eX'n$eX'u$eX'v$eX~OSfX!RfX!{fX'_fX'_$eX~P!!iOk'{O~OR'|O'S'}O'T(PO~Ou(ROx(SO'n#[O'u(UO'v(WO~O'_(QO~P!#rO'_(ZO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~O!Q(_O'Z([O!c'{P~P!$aO#W(aO~O!Q(eO'Z(bO!O'|P~P!$aO_(nOj(sOx(kO!W(qO!X(jO!Y(jO!d(hO!x(rO$w(mO'[$bO'e(gO~O!S(pO~P!&XO!b!yOu'cXx'cX'n'cX'u'cX'v'cX!R'cX!{'cX~O'_'cX#m'cX~P!'TOS(vO!{(uO!R'bX'_'bX~O!R(wO'_'aX~O'Z(yO~O!d)OO~O'Z&zO~O!d(hO~Ox$tO!Q!rO!T$uO#U!uO#V!rO'Z$`O!c'oP~O!]!wO#W)SO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_!^a!R!^a'U!^a!O!^a!c!^an!^a!T!^a%Q!^a!]!^a~P!)fOS)[O!T&cO!o)ZO%Q)YO'`$cO~O'Z$zO'_'aP~O!])_O!T'^X_'^X'U'^X~O!d$XO'`$cO~O!d$XO'Z$`O'`$cO~O!]!wO#W&|O~O])jO%R)kO'Z)gO!S(TP~O!R)lO^(SX~O'e'SO~OZ)pO~O^)qO~O!T$kO'Z$`O'[$bO^(SP~Ox$tO!Q)vO!R&_O!T$uO'Z$`O!O'rP~O]&YOk&YO!Q)wO'e'SO!S'tP~O!R)xO_(PX'U(PX~O!{)|O'`$cO~OS*PO!T#yO'`$cO~O!T*RO~Ou*TO!TSO~O!n*YO~Oc*_O~O'Z(yO!S(RP~Oc$iO~O%RtO'Z$zO~P8tOZ*eO^*dO~OPTOQTO]cObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#x^O%PqO'dQO'mYO'zaO~O!T!bO#t!lO'Z9YO~P!1RO^*dO_$[O'U$[O~O_*iO#d*kO%T*kO%U*kO~P){O!d%_O~O%t*pO~O!T*rO~O&U*uO&V*tOP&SaQ&SaX&Sa]&Sa_&Sab&Sac&Sah&Saj&Sak&Sal&Saq&Sas&Sax&Sa{&Sa|&Sa}&Sa!T&Sa!_&Sa!d&Sa!g&Sa!h&Sa!i&Sa!j&Sa!k&Sa!n&Sa#d&Sa#t&Sa#x&Sa%P&Sa%R&Sa%T&Sa%U&Sa%X&Sa%Z&Sa%^&Sa%_&Sa%a&Sa%n&Sa%t&Sa%v&Sa%x&Sa%z&Sa%}&Sa&T&Sa&X&Sa&Z&Sa&]&Sa&_&Sa&a&Sa'Q&Sa'Z&Sa'd&Sa'm&Sa'z&Sa!S&Sa%{&Sa`&Sa&Q&Sa~O'Z*xO~On*{O~O!O&ga!R&ga~P!)fO!Q+PO!O&gX!R&gX~P){O!R%yO!O'ha~O!O'ha~P>^O!R&_O!O'ra~O!RwX!R!ZX!SwX!S!ZX!]wX!]!ZX!d!ZX!{wX'`!ZX~O!]+UO!{+TO!R#TX!R'jX!S#TX!S'jX!]'jX!d'jX'`'jX~O!]+WO!d$XO'`$cO!R!VX!S!VX~O]&QOk&QOx&RO'e(gO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'dQO'mYO'z:kO~O'Z9vO~P!;^O!R+[O!S'iX~O!S+^O~O!]+UO!{+TO!R#TX!S#TX~O!R+_O!S'tX~O!S+aO~O]&QOk&QOx&RO'[$bO'e(gO~O!X+bO!Y+bO~P!>[Ox$tO!Q+dO!T$uO'Z$`O!O&lX!R&lX~O_+hO!W+kO!X+gO!Y+gO!r+oO!s+mO!t+nO!u+lO!x+pO'[$bO'e(gO'm+eO~O!S+jO~P!?]OS+uO!T&cO!o+tO~O!{+{O!R'pa!c'pa_'pa'U'pa~O!]!wO~P!@gO!R&sO!c'oa~Ox$tO!Q,OO!T$uO#U,QO#V,OO'Z$`O!R&nX!c&nX~O_#Oi!R#Oi'U#Oi!O#Oi!c#Oin#Oi!T#Oi%Q#Oi!]#Oi~P!)fO#W!za!R!za!c!za!{!za!T!za_!za'U!za!O!za~P!#rO#W'cXP'cXZ'cX_'cXj'cXv'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX'U'cX'd'cX!c'cX!O'cX!T'cXn'cX%Q'cX!]'cX~P!'TO!R,ZO'_'kX~P!#rO'_,]O~O!R,^O!c'lX~P!)fO!c,aO~O!O,bO~OP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zi_#Zij#Zi!R#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O#[#Zi~P!EtO#[#PO~P!EtOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO'dQOZ#Zi_#Zi!R#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~Oj#Zi~P!H`Oj#RO~P!H`OP#^Oj#ROu!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO'dQO_#Zi!R#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P!JzOZ#dO!a#TO#a#TO#b#TO#c#TO~P!JzOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO'dQO_#Zi!R#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'u#Zi~P!MrO'u!}O~P!MrOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO'dQO'u!}O_#Zi!R#Zi#i#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'v#Zi~P#!^O'v#OO~P#!^OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO'dQO'u!}O'v#OO~O_#Zi!R#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P#$xOP[XZ[Xj[Xu[Xv[Xx[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X!R[X!S[X~O#m[X~P#']OP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO#j9gO'dQO'n#[O'u!}O'v#OO~O#m,dO~P#)gOP'gXZ'gXj'gXu'gXv'gXx'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX!R'gX~O!{9kO#o9kO#c'gX#m'gX!S'gX~P#+bO_&qa!R&qa'U&qa!c&qan&qa!O&qa!T&qa%Q&qa!]&qa~P!)fOP#ZiZ#Zi_#Zij#Ziv#Zi!R#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'd#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P!#rO_#ni!R#ni'U#ni!O#ni!c#nin#ni!T#ni%Q#ni!]#ni~P!)fO#z,fO~O#z,gO~O!]'kO!{,hO!T$OX#w$OX#z$OX$R$OX~O!Q,iO~O!T'nO#w,kO#z'mO$R,lO~O!R9hO!S'fX~P#)gO!S,mO~O$R,oO~OR'|O'S'}O'T,rO~O],uOk,uO!O,vO~O!RdX!]dX!cdX!c$eX'ndX~P!!iO!c,|O~P!#rO!R,}O!]!wO'n&nO!c'{X~O!c-SO~O!O$eX!R$eX!]$lX~P!!iO!R-UO!O'|X~P!#rO!]-WO~O!O-YO~O!Q(_O'Z$`O!c'{P~Oj-^O!]!wO!d$XO'`$cO'n&nO~O!])_O~O!S-dO~P!&XO!X-eO!Y-eO'[$bO'e(gO~Ox-gO'e(gO~O!x-hO~O'Z$zO!R&vX'_&vX~O!R(wO'_'aa~Ou-mOv-mOx-nO'nra'ura'vra!Rra!{ra~O'_ra#mra~P#6fOu(ROx(SO'n$^a'u$^a'v$^a!R$^a!{$^a~O'_$^a#m$^a~P#7[Ou(ROx(SO'n$`a'u$`a'v$`a!R$`a!{$`a~O'_$`a#m$`a~P#7}O]-oO~O#W-pO~O'_$na!R$na#m$na!{$na~P!#rO#W-sO~OS-|O!T&cO!o-{O%Q-zO~O'_-}O~O]#qOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~Oh.PO'Z.OO~P#9tO!])_O!T'^a_'^a'U'^a~O#W.VO~OZ[X!RdX!SdX~O!R.WO!S(TX~O!S.YO~OZ.ZO~O].]O'Z)gO~O!T$kO'Z$`O^'OX!R'OX~O!R)lO^(Sa~O!c.`O~P!)fO].bO~OZ.cO~O^.dO~OS-|O!T&cO!o-{O%Q-zO'`$cO~O!R)xO_(Pa'U(Pa~O!{.jO~OS.mO!T#yO~O'e'SO!S(QP~OS.wO!T.sO!o.vO%Q.uO'`$cO~OZ/RO!R/PO!S(RX~O!S/SO~O^/UO_$[O'U$[O~O]/VO~O]/WO'Z(yO~O#c/XO%r/YO~P0zO!{#eO#c/XO%r/YO~O_/ZO~P){O_/]O~O%{/aOP%yiQ%yiX%yi]%yi_%yib%yic%yih%yij%yik%yil%yiq%yis%yix%yi{%yi|%yi}%yi!T%yi!_%yi!d%yi!g%yi!h%yi!i%yi!j%yi!k%yi!n%yi#d%yi#t%yi#x%yi%P%yi%R%yi%T%yi%U%yi%X%yi%Z%yi%^%yi%_%yi%a%yi%n%yi%t%yi%v%yi%x%yi%z%yi%}%yi&T%yi&X%yi&Z%yi&]%yi&_%yi&a%yi'Q%yi'Z%yi'd%yi'm%yi'z%yi!S%yi`%yi&Q%yi~O`/gO!S/eO&Q/fO~P`O!TSO!d/jO~O!R#bOn$]a~O!O&gi!R&gi~P!)fO!R%yO!O'hi~O!R&_O!O'ri~O!O/nO~O!R!Va!S!Va~P#)gO]&QOk&QO!Q/tO'e(gO!R&hX!S&hX~P@aO!R+[O!S'ia~O]&YOk&YO!Q)wO'e'SO!R&mX!S&mX~O!R+_O!S'ta~O!O'si!R'si~P!)fO_$[O!]!wO!d$XO!j0OO!{/|O'U$[O'`$cO'n&nO~O!S0RO~P!?]O!X0SO!Y0SO'[$bO'e(gO'm+eO~O!W0TO~P#GyO!TSO!W0TO!u0VO!x0WO~P#GyO!W0TO!s0YO!t0YO!u0VO!x0WO~P#GyO!T&cO~O!T&cO~P!#rO!R'pi!c'pi_'pi'U'pi~P!)fO!{0cO!R'pi!c'pi_'pi'U'pi~O!R&sO!c'oi~Ox$tO!T$uO#V0eO'Z$`O~O#WraPraZra_rajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra'Ura'dra!cra!Ora!Tranra%Qra!]ra~P#6fO#W$^aP$^aZ$^a_$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a'U$^a'd$^a!c$^a!O$^a!T$^an$^a%Q$^a!]$^a~P#7[O#W$`aP$`aZ$`a_$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a'U$`a'd$`a!c$`a!O$`a!T$`an$`a%Q$`a!]$`a~P#7}O#W$naP$naZ$na_$naj$nav$na!R$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na'U$na'd$na!c$na!O$na!T$na!{$nan$na%Q$na!]$na~P!#rO_#Oq!R#Oq'U#Oq!O#Oq!c#Oqn#Oq!T#Oq%Q#Oq!]#Oq~P!)fO!R&iX'_&iX~PJdO!R,ZO'_'ka~O!Q0mO!R&jX!c&jX~P){O!R,^O!c'la~O!R,^O!c'la~P!)fO#m!fa!S!fa~PCcO#m!^a!R!^a!S!^a~P#)gO!T1QO#x^O$P1RO~O!S1VO~On1WO~P!#rO_$Yq!R$Yq'U$Yq!O$Yq!c$Yqn$Yq!T$Yq%Q$Yq!]$Yq~P!)fO!O1XO~O],uOk,uO~Ou(ROx(SO'v(WO'n$xi'u$xi!R$xi!{$xi~O'_$xi#m$xi~P$(jOu(ROx(SO'n$zi'u$zi'v$zi!R$zi!{$zi~O'_$zi#m$zi~P$)]O#m1YO~P!#rO!Q1[O'Z$`O!R&rX!c&rX~O!R,}O!c'{a~O!R,}O!]!wO!c'{a~O!R,}O!]!wO'n&nO!c'{a~O'_$gi!R$gi#m$gi!{$gi~P!#rO!Q1cO'Z(bO!O&tX!R&tX~P!$aO!R-UO!O'|a~O!R-UO!O'|a~P!#rO!]!wO~O!]!wO#c1mO~Oj1qO!]!wO'n&nO~O!R'bi'_'bi~P!#rO!{1tO!R'bi'_'bi~P!#rO!c1wO~O_$Zq!R$Zq'U$Zq!O$Zq!c$Zqn$Zq!T$Zq%Q$Zq!]$Zq~P!)fO!R1{O!T'}X~P!#rO!T&cO%Q2OO~O!T&cO%Q2OO~P!#rO!T$eX$u[X_$eX'U$eX~P!!iO$u2SOugXxgX!TgX'ngX'ugX'vgX_gX'UgX~O$u2SO~O]2YO%R2ZO'Z)gO!R&}X!S&}X~O!R.WO!S(Ta~OZ2_O~O^2`O~O]2cO~OS2eO!T&cO!o2dO%Q2OO~O_$[O'U$[O~P!#rO!T#yO~P!#rO!R2jO!{2lO!S(QX~O!S2mO~Ox(kO!W2vO!X2oO!Y2oO!r2uO!s2tO!t2tO!x2sO'[$bO'e(gO'm+eO~O!S2rO~P$1nOS2}O!T.sO!o2|O%Q2{O~OS2}O!T.sO!o2|O%Q2{O'`$cO~O'Z(yO!R&|X!S&|X~O!R/PO!S(Ra~O]3XO'e3WO~O]3YO~O^3[O~O!c3_O~P){O_3aO~O_3aO~P){O#c3cO%r3dO~PE{O`/gO!S3hO&Q/fO~P`O!]3jO~O&V3kOP&SqQ&SqX&Sq]&Sq_&Sqb&Sqc&Sqh&Sqj&Sqk&Sql&Sqq&Sqs&Sqx&Sq{&Sq|&Sq}&Sq!T&Sq!_&Sq!d&Sq!g&Sq!h&Sq!i&Sq!j&Sq!k&Sq!n&Sq#d&Sq#t&Sq#x&Sq%P&Sq%R&Sq%T&Sq%U&Sq%X&Sq%Z&Sq%^&Sq%_&Sq%a&Sq%n&Sq%t&Sq%v&Sq%x&Sq%z&Sq%}&Sq&T&Sq&X&Sq&Z&Sq&]&Sq&_&Sq&a&Sq'Q&Sq'Z&Sq'd&Sq'm&Sq'z&Sq!S&Sq%{&Sq`&Sq&Q&Sq~O!R#Ti!S#Ti~P#)gO!{3mO!R#Ti!S#Ti~O!R!Vi!S!Vi~P#)gO_$[O!{3tO'U$[O~O_$[O!]!wO!{3tO'U$[O~O!X3xO!Y3xO'[$bO'e(gO'm+eO~O_$[O!]!wO!d$XO!j3yO!{3tO'U$[O'`$cO'n&nO~O!W3zO~P$:ZO!W3zO!u3}O!x4OO~P$:ZO_$[O!]!wO!j3yO!{3tO'U$[O'n&nO~O!R'pq!c'pq_'pq'U'pq~P!)fO!R&sO!c'oq~O#W$xiP$xiZ$xi_$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi'U$xi'd$xi!c$xi!O$xi!T$xin$xi%Q$xi!]$xi~P$(jO#W$ziP$ziZ$zi_$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi'U$zi'd$zi!c$zi!O$zi!T$zin$zi%Q$zi!]$zi~P$)]O#W$giP$giZ$gi_$gij$giv$gi!R$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi'U$gi'd$gi!c$gi!O$gi!T$gi!{$gin$gi%Q$gi!]$gi~P!#rO!R&ia'_&ia~P!#rO!R&ja!c&ja~P!)fO!R,^O!c'li~O#m#Oi!R#Oi!S#Oi~P#)gOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zij#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~O#[#Zi~P$CqO#[9]O~P$CqOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O'dQOZ#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~Oj#Zi~P$EyOj9_O~P$EyOP#^Oj9_Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O'dQO#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P$HROZ9jO!a9aO#a9aO#b9aO#c9aO~P$HROP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO'dQO#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'v#Zi!R#Zi!S#Zi~O'u#Zi~P$JgO'u!}O~P$JgOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO'dQO'u!}O#i#Zi#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~O'v#Zi~P$LoO'v#OO~P$LoOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO'dQO'u!}O'v#OO~O#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~P$NwO_#ky!R#ky'U#ky!O#ky!c#kyn#ky!T#ky%Q#ky!]#ky~P!)fOP#ZiZ#Zij#Ziv#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'd#Zi!R#Zi!S#Zi~P!#rO!b!yOP'cXZ'cXj'cXu'cXv'cXx'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX#m'cX'd'cX'n'cX'u'cX'v'cX!R'cX!S'cX~O#m#ni!R#ni!S#ni~P#)gO!S4`O~O!R&qa!S&qa~P#)gO!]!wO'n&nO!R&ra!c&ra~O!R,}O!c'{i~O!R,}O!]!wO!c'{i~O!O&ta!R&ta~P!#rO!]4gO~O!R-UO!O'|i~P!#rO!R-UO!O'|i~O!O4mO~O!]!wO#c4sO~Oj4tO!]!wO'n&nO~O!O4vO~O'_$iq!R$iq#m$iq!{$iq~P!#rO_$Zy!R$Zy'U$Zy!O$Zy!c$Zyn$Zy!T$Zy%Q$Zy!]$Zy~P!)fO!R1{O!T'}a~O!T&cO%Q4{O~O!T&cO%Q4{O~P!#rO_#Oy!R#Oy'U#Oy!O#Oy!c#Oyn#Oy!T#Oy%Q#Oy!]#Oy~P!)fOZ5OO~O]5QO'Z)gO~O!R.WO!S(Ti~O]5TO~O^5UO~O'e'SO!R&yX!S&yX~O!R2jO!S(Qa~O!S5cO~P$1nOx-gO'e(gO'm+eO~O!W5fO!X5eO!Y5eO!x0WO'[$bO'e(gO'm+eO~O!s5gO!t5gO~P%-iO!X5eO!Y5eO'[$bO'e(gO'm+eO~O!T.sO~O!T.sO%Q5iO~O!T.sO%Q5iO~P!#rOS5nO!T.sO!o5mO%Q5iO~OZ5sO!R&|a!S&|a~O!R/PO!S(Ri~O]5vO~O!c5wO~O!c5xO~O!c5yO~O!c5yO~P){O_5{O~O!]6OO~O!c6QO~O!R'si!S'si~P#)gO_$[O'U$[O~P!)fO_$[O!{6VO'U$[O~O_$[O!]!wO!{6VO'U$[O~O!X6[O!Y6[O'[$bO'e(gO'm+eO~O_$[O!]!wO!j6]O!{6VO'U$[O'n&nO~O!d$XO'`$cO~P%2TO!W6^O~P%1rO!R'py!c'py_'py'U'py~P!)fO#W$iqP$iqZ$iq_$iqj$iqv$iq!R$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq'U$iq'd$iq!c$iq!O$iq!T$iq!{$iqn$iq%Q$iq!]$iq~P!#rO!R&ji!c&ji~P!)fO#m#Oq!R#Oq!S#Oq~P#)gOu-mOv-mOx-nOPraZrajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra#mra'dra'nra'ura'vra!Rra!Sra~Ou(ROx(SOP$^aZ$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a#m$^a'd$^a'n$^a'u$^a'v$^a!R$^a!S$^a~Ou(ROx(SOP$`aZ$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a#m$`a'd$`a'n$`a'u$`a'v$`a!R$`a!S$`a~OP$naZ$naj$nav$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na#m$na'd$na!R$na!S$na~P!#rO#m$Yq!R$Yq!S$Yq~P#)gO#m$Zq!R$Zq!S$Zq~P#)gO!S6hO~O'_$|y!R$|y#m$|y!{$|y~P!#rO!]!wO!R&ri!c&ri~O!]!wO'n&nO!R&ri!c&ri~O!R,}O!c'{q~O!O&ti!R&ti~P!#rO!R-UO!O'|q~O!O6oO~P!#rO!O6oO~O!R'by'_'by~P!#rO!R&wa!T&wa~P!#rO!T$tq_$tq'U$tq~P!#rOZ6wO~O!R.WO!S(Tq~O]6zO~O!T&cO%Q6{O~O!T&cO%Q6{O~P!#rO!{6|O!R&ya!S&ya~O!R2jO!S(Qi~P#)gO!X7SO!Y7SO'[$bO'e(gO'm+eO~O!W7UO!x4OO~P%ArO!T.sO%Q7XO~O!T.sO%Q7XO~P!#rO]7`O'e7_O~O!R/PO!S(Rq~O!c7bO~O!c7bO~P){O!c7dO~O!c7eO~O!R#Ty!S#Ty~P#)gO_$[O!{7kO'U$[O~O_$[O!]!wO!{7kO'U$[O~O!X7nO!Y7nO'[$bO'e(gO'm+eO~O_$[O!]!wO!j7oO!{7kO'U$[O'n&nO~O#W$|yP$|yZ$|y_$|yj$|yv$|y!R$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y'U$|y'd$|y!c$|y!O$|y!T$|y!{$|yn$|y%Q$|y!]$|y~P!#rO#m#ky!R#ky!S#ky~P#)gOP$giZ$gij$giv$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi#m$gi'd$gi!R$gi!S$gi~P!#rOu(ROx(SO'v(WOP$xiZ$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi#m$xi'd$xi'n$xi'u$xi!R$xi!S$xi~Ou(ROx(SOP$ziZ$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi#m$zi'd$zi'n$zi'u$zi'v$zi!R$zi!S$zi~O#m$Zy!R$Zy!S$Zy~P#)gO#m#Oy!R#Oy!S#Oy~P#)gO!]!wO!R&rq!c&rq~O!R,}O!c'{y~O!O&tq!R&tq~P!#rO!O7uO~P!#rO!R.WO!S(Ty~O!R2jO!S(Qq~O!X8RO!Y8RO'[$bO'e(gO'm+eO~O!T.sO%Q8UO~O!T.sO%Q8UO~P!#rO!c8XO~O&V8YOP&S!ZQ&S!ZX&S!Z]&S!Z_&S!Zb&S!Zc&S!Zh&S!Zj&S!Zk&S!Zl&S!Zq&S!Zs&S!Zx&S!Z{&S!Z|&S!Z}&S!Z!T&S!Z!_&S!Z!d&S!Z!g&S!Z!h&S!Z!i&S!Z!j&S!Z!k&S!Z!n&S!Z#d&S!Z#t&S!Z#x&S!Z%P&S!Z%R&S!Z%T&S!Z%U&S!Z%X&S!Z%Z&S!Z%^&S!Z%_&S!Z%a&S!Z%n&S!Z%t&S!Z%v&S!Z%x&S!Z%z&S!Z%}&S!Z&T&S!Z&X&S!Z&Z&S!Z&]&S!Z&_&S!Z&a&S!Z'Q&S!Z'Z&S!Z'd&S!Z'm&S!Z'z&S!Z!S&S!Z%{&S!Z`&S!Z&Q&S!Z~O_$[O!{8_O'U$[O~O_$[O!]!wO!{8_O'U$[O~OP$iqZ$iqj$iqv$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq#m$iq'd$iq!R$iq!S$iq~P!#rO!R&yq!S&yq~P#)gO_$[O!{8tO'U$[O~OP$|yZ$|yj$|yv$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y#m$|y'd$|y!R$|y!S$|y~P!#rOn'fX~P.jOn[X!O[X!c[X%r[X!T[X%Q[X!][X~P$zO!]dX!c[X!cdX'ndX~P;aOP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!TSO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!R9hO!S$]a~O]#qOh$OOj#rOk#qOl#qOq$POs9mOx#xO!T#yO!_:pO!d#vO#V9sO#t$TO$_9oO$a9qO$d$UO'Z&zO'd#sO~O#d'iO~P&-UO!S[X!SdX~P;aO#W9[O~O!]!wO#W9[O~O!{9kO~O#c9aO~O!{9tO!R'sX!S'sX~O!{9kO!R'qX!S'qX~O#W9uO~O'_9wO~P!#rO#W9|O~O#W9}O~O!]!wO#W:OO~O!]!wO#W9uO~O#m:PO~P#)gO#W:QO~O#W:RO~O#W:SO~O#W:TO~O#m:UO~P!#rO#m:VO~P!#rO#x~!b!r!t!u#U#V'z$_$a$d$u%P%Q%R%X%Z%^%_%a%c~UT#x'z#]}'W'X#z'W'Z'e~",
    goto: "#Ed(XPPPPPPPP(YP(jP*^PPPP-uPP.[3n5b5uP5uPPP5uP7c5uP5uP7gPP7lP8Q<cPPPP<gPPPP<g?XPPP?_AjP<gPDTPPPPE{<gPPPPPGt<gPPJuKrPPPPKvM`PMhNiPKr<g<g!#p!&k!+^!+^!.mPPP!.t!1j<gPPPPPPPPPP!4aP!5rPP<g!7PP<gP<g<g<g<gP<g!9dPP!<]P!?Q!?Y!?^!?^P!<YP!?b!?bP!BVP!BZ<g<g!Ba!ET5uP5uP5u5uP!FW5u5u!HO5u!JQ5u!Kr5u5u!L`!NY!NY!N^!NY!NfP!NYP5u# b5u#!l5u5u-uPPP##yPP#$c#$cP#$cP#$x#$cPP#%OP#$uP#$u#%bMd#$u#&P#&V#&Y(Y#&](YP#&d#&d#&dP(YP(YP(YP(YPP(YP#&j#&mP#&m(YPPP(YP(YP(YP(YP(YP(Y(Y#&q#&{#'R#'X#'g#'m#'s#'}#(T#(d#(j#(x#)O#)U#)d#)y#+]#+k#+q#+w#+}#,T#,_#,e#,k#,u#-X#-_PPPPPPPP#-ePP#.X#2VPP#3m#3t#3|PP#8Y#:m#@i#@l#@o#@z#@}PP#AQ#AU#As#Bj#Bn#CSPP#CW#C^#CbP#Ce#Ci#Cl#D[#Dr#Dw#Dz#D}#ET#EW#E[#E`mhOSj}!n$Z%b%e%f%h*m*r/a/dQ$hmQ$opQ%YyS&U!b+[Q&j!jS(j#y(oQ)e$iQ)r$qQ*^%SQ+b&]S+g&c+iQ+y&kQ-e(qQ/O*_Y0S+k+l+m+n+oS2o.s2qU3x0T0V0YU5e2t2u2vS6[3z3}S7S5f5gQ7n6^R8R7U$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ(z$QQ)j$kQ*`%VQ*g%_Q,T9lQ.Q)_Q.])kQ/W*eQ2Y.WQ3U/PQ4X9mR5Q2ZpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dR*b%Z&WVOSTjkn}!S!W!k!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%y&R&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:m:n[!cRU!]!`%w&VQ$alQ$gmS$lp$qv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ%OwQ&g!iQ&i!jS(^#v(hS)d$h$iQ)h$kQ)u$sQ*X%QQ*]%SS+x&j&kQ-R(_Q.U)eQ.[)kQ.^)lQ.a)pQ.y*YS.}*^*_Q0a+yQ1Z,}Q2X.WQ2].ZQ2b.cQ3T/OQ4d1[Q5P2ZQ5S2_Q6v5OR7x6w!Y$em!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`Q)]$aQ)}${Q*Q$|Q*[%SQ.e)uQ.x*XU.|*]*^*_Q3O.yS3S.}/OQ5`2nQ5r3TS7Q5a5dS8P7R7TQ8j8QR8y8kW#|a$c(w:kS${t%XQ$|uQ$}vR){$y$V#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rT'}#s(OV({$Q9l9mU&Y!b$u+_Q'T!{Q)o$nQ.n*RQ1u-mR5[2j&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n$]#aZ!_!o$_%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,e,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dT!XQ!Y&_cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ&W!bR/u+[Y&Q!b&U&]+[+bS(i#y(oS+f&c+iS-_(j(qQ-`(kQ-f(rQ.p*TU0P+g+k+lU0U+m+n+oS0Z+p2sQ1p-eQ1r-gQ1s-hS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%j!QS&w!v9[Q)b$fQ*V%OQ*W%PQ+v&hS,X&|9uS-r)S:OQ.S)cQ.r*UQ/h*tQ/i*uQ/q+VQ0X+mQ0_+wS1z-s:SQ2T.TS2W.V:TQ3n/sQ3q/zQ4Q0`Q4}2UQ6P3kQ6S3pQ6W3vQ6`4RQ7f6QQ7i6XQ8[7jQ8o8YQ8q8^R8|8s$W#`Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dU(t#z&{1OT)W$_,e$W#_Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dQ'e#`S)V$_,eR-t)W&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ%e{Q%f|Q%h!OQ%i!PR/`*pQ&d!iQ)X$aQ+s&gS-y)])uS0[+q+rW1}-v-w-x.eS4P0]0^U4z2P2Q2RU6t4y5W5XQ7w6uR8f7zT+h&c+iS+f&c+iU0P+g+k+lU0U+m+n+oS0Z+p2sS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RS+h&c+iT2p.s2qS&q!q/^Q-Q(^Q-](iS0O+f2nQ1`-RS1j-^-fU3y0U0Z5dQ4c1ZS4q1q1sU6]3{3|7TQ6j4dQ6s4tR7o6_Q!xXS&p!q/^Q)T$YQ)`$dQ)f$jQ+|&qQ-P(^Q-[(iQ-a(lQ.R)aQ.z*ZS/}+f2nS1_-Q-RS1i-]-fQ1l-`Q1o-bQ3Q.{W3u0O0U0Z5dQ4b1ZQ4f1`S4k1j1sQ4r1rQ5p3RW6Z3y3{3|7TS6i4c4dQ6n4mQ6q4qQ7O5_Q7]5qS7m6]6_Q7q6jQ7s6oQ7v6sQ7}7PQ8W7^Q8a7oQ8d7uQ8h8OQ8w8iQ9P8xQ9T9QQ:^:XQ:g:bR:h:c$rWORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tS!xn!k!j:W#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:^:m$rXORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ$Yb!Y$dm!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`S$jn!kQ)a$eQ*Z%SW.{*[*]*^*_U3R.|.}/OQ5_2nS5q3S3TU7P5`5a5dQ7^5rU8O7Q7R7TS8i8P8QS8x8j8kQ9Q8y!j:X#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ:b:lR:c:m$f]OSTjk}!S!W!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tY!hRU!]!`%wv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ*h%_!h:Y#]#k'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:]&VS&Z!b$uR/w+_$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR*g%_$roORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ'T!{!k:Z#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n!h#VZ!_$_%v%|&x'P'^'_'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W!R9c'c't+Y,e/o/r0p0x0y0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!d#XZ!_$_%v%|&x'P'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W}9e'c't+Y,e/o/r0p0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!`#]Z!_$_%v%|&x'P'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9Wl(Y#t&})R,{-T-i-j0j1x4a4u:_:i:jx:n'c't+Y,e/o/r0p1P1U3o4W4]4^5^6R6b6f6g7{:d!`:q&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ:r0}4[6c7p8b&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#l`#mR1R,h&e_ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#g^#nT'm#i'qT#h^#nT'o#i'q&e`ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nT#l`#mQ#o`R'x#m$rbORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!k:l#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n#RdOSUj}!S!W!n!|#k$Z%Z%^%_%b%d%e%f%h%l&R&e'v)Z*i*m*r+t,i-n-{.v/X/Y/Z/]/a/d/f1Q2d2|3a3c3d5m5{t#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:UQ)P$UQ,t(Rc1O9j9o9q9s9y9{9}:R:Vt#wa!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:rS(l#y(oQ)Q$VQ-b(m!|:`!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Ub:a9j9o9q9s9y9{9}:R:VQ:e:oR:f:pt#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Uc1O9j9o9q9s9y9{9}:R:VlfOSj}!n$Z%b%e%f%h*m*r/a/dQ(d#xQ*y%oQ*z%qR1b-U$U#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rQ*O$|Q.l*QQ2h.kR5Z2iT(n#y(oS(n#y(oT2p.s2qQ)`$dQ-a(lQ.R)aQ.z*ZQ3Q.{Q5p3RQ7O5_Q7]5qQ7}7PQ8W7^Q8h8OQ8w8iQ9P8xR9T9Ql(V#t&})R,{-T-i-j0j1x4a4u:_:i:j!`9x&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ9y0}4[6c7p8bn(X#t&})R,y,{-T-i-j0j1x4a4u:_:i:j!b9z&y'h(](c+r,W,p-X-u-x.i.k0^0g0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7Z]9{0}4[6c6d7p8bpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ%UxR*i%_peOSjy}!n$Z%X%b%e%f%h*m*r/a/dR%UxQ*S$}R.h){qeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ.t*XS2z.x.yW5h2w2x2y3OU7W5j5k5lU8S7V7Y7ZQ8l8TR8z8mQ%]yR*c%XR3X/RR7`5sS$lp$qR.^)lQ%bzR*m%cR*s%iT/b*r/dQjOQ!nST$^j!nQ(O#sR,q(OQ!YQR%t!YQ!^RU%z!^%{+QQ%{!_R+Q%|Q+]&WR/v+]Q,[&}R0k,[Q,_'PS0n,_0oR0o,`Q+i&cR0Q+iS!eR$tU&`!e&a+RQ&a!fR+R%}Q+`&ZR/x+`Q&t!sQ+}&rU,R&t+}0fR0f,SQ'q#iR,j'qQ#m`R'w#mQ#cZU'g#c*|9iQ*|9WR9i'tQ-O(^W1]-O1^4e6kU1^-P-Q-RS4e1_1`R6k4f#q(T#t&y&}'h(](c(|(})R+r,U,V,W,p,y,z,{-T-X-i-j-u-x.i.k0^0g0h0i0j0}1a1e1x2R2g2i2y4U4Y4Z4[4a4h4n4u4w4|5X5l6a6c6d6e6l6r7Z7p8b:_:i:jQ-V(cU1d-V1f4iQ1f-XR4i1eQ(o#yR-c(oQ(x#}R-l(xQ1|-uR4x1|Q)y$wR.g)yQ2k.nS5]2k6}R6}5^Q*U%OR.q*UQ2q.sR5b2qQ/Q*`S3V/Q5tR5t3XQ.X)hW2[.X2^5R6xQ2^.[Q5R2]R6x5SQ)m$lR._)mQ/d*rR3g/dWiOSj!nQ%g}Q)U$ZQ*l%bQ*n%eQ*o%fQ*q%hQ/_*mS/b*r/dR3f/aQ$]gQ%k!RQ%n!TQ%p!UQ%r!VQ)t$rQ)z$xQ*b%]Q*w%mS/T*c*fQ/k*vQ/l*yQ/m*zS/{+f2nQ1g-ZQ1h-[Q1n-aQ2a.bQ2f.iQ3P.zQ3Z/VQ3e/`Y3s/}0O0U0Z5dQ4j1iQ4l1kQ4o1oQ5V2cQ5Y2gQ5o3QQ5u3Y[6T3r3u3y3{3|7TQ6m4kQ6p4pQ6y5TQ7[5pQ7a5vW7g6U6Z6]6_Q7r6nQ7t6qQ7y6zQ7|7OQ8V7]U8Z7h7m7oQ8c7sQ8e7vQ8g7}Q8n8WS8p8]8aQ8u8dQ8v8hQ8{8rQ9O8wQ9R8}Q9S9PR9U9TQ$fmQ&h!jU)c$g$h$iQ+V&TU+w&i&j&kQ-Z(iS.T)d)eQ/s+XQ/z+fS0`+x+yQ1k-_Q2U.UQ3p/yS3v0P0UQ4R0aQ4p1pS6X3w3|Q7j6YQ8^7lR8s8`S#ua:kR)^$cU#}a$c:kR-k(wQ#taS&y!w)_Q&}!yQ'h#dQ(]#vQ(c#xQ(|$RQ(}$SQ)R$WQ+r&fQ,U9nQ,V9pQ,W9rQ,p'|Q,y(VQ,z(XQ,{(YQ-T(aQ-X(eQ-i(uQ-j(vd-u)Y-z.u2O2{4{5i6{7X8UQ-x)[Q.i)|Q.k*PQ0^+uQ0g9xQ0h9zQ0i9|Q0j,ZQ0}9jQ1a-UQ1e-WQ1x-pQ2R-|Q2g.jQ2i.mQ2y.wQ4U:QQ4Y9oQ4Z9qQ4[9sQ4a1YQ4h1cQ4n1mQ4u1tQ4w1{Q4|2SQ5X2eQ5l2}Q6a:UQ6c9}Q6d9yQ6e9{Q6l4gQ6r4sQ7Z5nQ7p:RQ8b:VQ:_:kQ:i:qR:j:rlgOSj}!n$Z%b%e%f%h*m*r/a/dS!pU%dQ%m!SQ%s!WQ'U!|Q'u#kS*f%Z%^Q*j%_Q*v%lQ+S&RQ+q&eQ,n'vQ-w)ZQ/[*iQ0]+tQ1T,iQ1v-nQ2Q-{Q2x.vQ3]/XQ3^/YQ3`/ZQ3b/]Q3i/fQ4_1QQ5W2dQ5k2|Q5z3aQ5|3cQ5}3dQ7Y5mR7c5{!vZOSUj}!S!n!|$Z%Z%^%_%b%d%e%f%h%l&R&e)Z*i*m*r+t-n-{.v/X/Y/Z/]/a/d/f2d2|3a3c3d5m5{Q!_RQ!oTQ$_kS%v!]%yQ%|!`Q&x!vQ'P!zQ'V#PQ'W#QQ'X#RQ'Y#SQ'Z#TQ'[#UQ']#VQ'^#WQ'_#XQ'`#YQ'a#ZQ'c#]Q'f#bQ'j#eW't#k'v,i1QQ)n$mS*}%w+PS+Y&V/tQ+c&^Q+z&oQ,Y&|Q,`'QQ,c9VQ,e9XQ,s(QQ-q)SQ/o+TQ/r+WQ0b+{Q0l,^Q0p9[Q0q9]Q0r9^Q0s9_Q0t9`Q0u9aQ0v9bQ0w9cQ0x9dQ0y9eQ0z9fQ0{9gQ0|,dQ1P9kQ1U9hQ1y-sQ2V.VQ3o9tQ3r/|Q4S0cQ4V0mQ4W9uQ4]9wQ4^:OQ5^2lQ6R3mQ6U3tQ6b:PQ6f:SQ6g:TQ7h6VQ7{6|Q8]7kQ8r8_Q8}8tQ9W!WR:d:nR!aRR&X!bS&T!b+[S+X&U&]R/y+bR'O!yR'R!zT!tU$XS!sU$XU$wrs*kS&r!r!uQ,P&sQ,S&vQ.f)xS0d,O,QR4T0e`!dR!]!`$t%w&_)v+dh!qUrs!r!u$X&s&v)x,O,Q0eQ/^*kQ/p+UQ3l/jT:[&V)wT!gR$tS!fR$tS%x!]&_S%}!`)vS+O%w+dT+Z&V)wT&[!b$uQ#i^R'z#nT'p#i'qR1S,hT(`#v(hR(f#xQ-v)YQ2P-zQ2w.uQ4y2OQ5j2{Q6u4{Q7V5iQ7z6{Q8T7XR8m8UlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%[yR*b%XV$xrs*kR.o*RR*a%VQ$ppR)s$qR)i$kT%`z%cT%az%cT/c*r/d",
    nodeNames: "⚠ ArithOp ArithOp InterpolationStart extends LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression PrivatePropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
    maxTerm: 330,
    context: trackNewline,
    nodeProps: [
        [
            NodeProp.closedBy,
            3,
            "InterpolationEnd",
            40,
            "]",
            51,
            "}",
            66,
            ")",
            132,
            "JSXSelfCloseEndTag JSXEndTag",
            146,
            "JSXEndTag"
        ],
        [
            NodeProp.group,
            -26,
            8,
            15,
            17,
            58,
            184,
            188,
            191,
            192,
            194,
            197,
            200,
            211,
            213,
            219,
            221,
            223,
            225,
            228,
            234,
            238,
            240,
            242,
            244,
            246,
            248,
            249,
            "Statement",
            -30,
            12,
            13,
            24,
            27,
            28,
            41,
            43,
            44,
            45,
            47,
            52,
            60,
            68,
            74,
            75,
            91,
            92,
            101,
            103,
            119,
            122,
            124,
            125,
            126,
            127,
            129,
            130,
            148,
            149,
            151,
            "Expression",
            -22,
            23,
            25,
            29,
            32,
            34,
            152,
            154,
            156,
            157,
            159,
            160,
            161,
            163,
            164,
            165,
            167,
            168,
            169,
            178,
            180,
            182,
            183,
            "Type",
            -3,
            79,
            85,
            90,
            "ClassItem"
        ],
        [
            NodeProp.openedBy,
            30,
            "InterpolationStart",
            46,
            "[",
            50,
            "{",
            65,
            "(",
            131,
            "JSXStartTag",
            141,
            "JSXStartTag JSXStartCloseTag"
        ]
    ],
    skippedNodes: [
        0,
        5,
        6
    ],
    repeatNodeCount: 28,
    tokenData: "!C}~R!`OX%TXY%cYZ'RZ[%c[]%T]^'R^p%Tpq%cqr'crs(kst0htu2`uv4pvw5ewx6cxy<yyz=Zz{=k{|>k|}?O}!O>k!O!P?`!P!QCl!Q!R!0[!R![!1q![!]!7s!]!^!8V!^!_!8g!_!`!9d!`!a!:[!a!b!<R!b!c%T!c!}2`!}#O!=d#O#P%T#P#Q!=t#Q#R!>U#R#S2`#S#T!>i#T#o2`#o#p!>y#p#q!?O#q#r!?f#r#s!?x#s$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$I|2`$I|$I}!Bq$I}$JO!Bq$JO$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`W%YR$UWO!^%T!_#o%T#p~%T,T%jg$UW'W+{OX%TXY%cYZ%TZ[%c[p%Tpq%cq!^%T!_#o%T#p$f%T$f$g%c$g#BY%T#BY#BZ%c#BZ$IS%T$IS$I_%c$I_$JT%T$JT$JU%c$JU$KV%T$KV$KW%c$KW&FU%T&FU&FV%c&FV?HT%T?HT?HU%c?HU~%T,T'YR$UW'X+{O!^%T!_#o%T#p~%T$T'jS$UW!j#{O!^%T!_!`'v!`#o%T#p~%T$O'}S#e#v$UWO!^%T!_!`(Z!`#o%T#p~%T$O(bR#e#v$UWO!^%T!_#o%T#p~%T'u(rZ$UW]!ROY(kYZ)eZr(krs*rs!^(k!^!_+U!_#O(k#O#P-b#P#o(k#o#p+U#p~(k&r)jV$UWOr)ers*Ps!^)e!^!_*a!_#o)e#o#p*a#p~)e&r*WR$P&j$UWO!^%T!_#o%T#p~%T&j*dROr*ars*ms~*a&j*rO$P&j'u*{R$P&j$UW]!RO!^%T!_#o%T#p~%T'm+ZV]!ROY+UYZ*aZr+Urs+ps#O+U#O#P+w#P~+U'm+wO$P&j]!R'm+zROr+Urs,Ts~+U'm,[U$P&j]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R,sU]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R-[O]!R!R-_PO~,n'u-gV$UWOr(krs-|s!^(k!^!_+U!_#o(k#o#p+U#p~(k'u.VZ$P&j$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/PZ$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/yR$UW]!RO!^%T!_#o%T#p~%T!Z0XT$UWO!^.x!^!_,n!_#o.x#o#p,n#p~.xy0mZ$UWOt%Ttu1`u!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`y1g]$UW'mqOt%Ttu1`u!Q%T!Q![1`![!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`&i2k_$UW#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`[3q_$UW#zSOt%Ttu3ju}%T}!O3j!O!Q%T!Q![3j![!^%T!_!c%T!c!}3j!}#R%T#R#S3j#S#T%T#T#o3j#p$g%T$g~3j$O4wS#^#v$UWO!^%T!_!`5T!`#o%T#p~%T$O5[R$UW#o#vO!^%T!_#o%T#p~%T%r5lU'v%j$UWOv%Tvw6Ow!^%T!_!`5T!`#o%T#p~%T$O6VS$UW#i#vO!^%T!_!`5T!`#o%T#p~%T'u6jZ$UW]!ROY6cYZ7]Zw6cwx*rx!^6c!^!_8T!_#O6c#O#P:T#P#o6c#o#p8T#p~6c&r7bV$UWOw7]wx*Px!^7]!^!_7w!_#o7]#o#p7w#p~7]&j7zROw7wwx*mx~7w'm8YV]!ROY8TYZ7wZw8Twx+px#O8T#O#P8o#P~8T'm8rROw8Twx8{x~8T'm9SU$P&j]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R9kU]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R:QPO~9f'u:YV$UWOw6cwx:ox!^6c!^!_8T!_#o6c#o#p8T#p~6c'u:xZ$P&j$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z;rZ$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z<jT$UWO!^;k!^!_9f!_#o;k#o#p9f#p~;k%V=QR!d$}$UWO!^%T!_#o%T#p~%TZ=bR!cR$UWO!^%T!_#o%T#p~%T%R=tU'[!R#_#v$UWOz%Tz{>W{!^%T!_!`5T!`#o%T#p~%T$O>_S#[#v$UWO!^%T!_!`5T!`#o%T#p~%T$u>rSj$m$UWO!^%T!_!`5T!`#o%T#p~%T&i?VR!R&a$UWO!^%T!_#o%T#p~%T&i?gVu%n$UWO!O%T!O!P?|!P!Q%T!Q![@r![!^%T!_#o%T#p~%Ty@RT$UWO!O%T!O!P@b!P!^%T!_#o%T#p~%Ty@iR!Qq$UWO!^%T!_#o%T#p~%Ty@yZ$UWkqO!Q%T!Q![@r![!^%T!_!g%T!g!hAl!h#R%T#R#S@r#S#X%T#X#YAl#Y#o%T#p~%TyAqZ$UWO{%T{|Bd|}%T}!OBd!O!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyBiV$UWO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyCVV$UWkqO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T,TCs`$UW#]#vOYDuYZ%TZzDuz{Jl{!PDu!P!Q!-e!Q!^Du!^!_Fx!_!`!.^!`!a!/]!a!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXD|[$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXEy_$UW}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%TPF}V}POYFxZ!PFx!P!QGd!Q!}Fx!}#OG{#O#PHh#P~FxPGiU}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGdPHOTOYG{Z#OG{#O#PH_#P#QFx#Q~G{PHbQOYG{Z~G{PHkQOYFxZ~FxXHvY$UWOYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~HqXIkV$UWOYHqYZ%TZ!^Hq!^!_G{!_#oHq#o#pG{#p~HqXJVV$UWOYDuYZ%TZ!^Du!^!_Fx!_#oDu#o#pFx#p~Du,TJs^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q!,R!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,TKtV$UWOzKoz{LZ{!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TL`X$UWOzKoz{LZ{!PKo!P!QL{!Q!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TMSR$UWU+{O!^%T!_#o%T#p~%T+{M`ROzM]z{Mi{~M]+{MlTOzM]z{Mi{!PM]!P!QM{!Q~M]+{NQOU+{,TNX^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q! T!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,T! ^_$UWU+{}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%T+{!!bY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!&x!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#VY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!#u!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#|UU+{}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGd+{!$cWOY!$`YZM]Zz!$`z{!${{#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%OYOY!$`YZM]Zz!$`z{!${{!P!$`!P!Q!%n!Q#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%sTU+{OYG{Z#OG{#O#PH_#P#QFx#Q~G{+{!&VTOY!$`YZM]Zz!$`z{!${{~!$`+{!&iTOY!!]YZM]Zz!!]z{!#Q{~!!]+{!&}_}POzM]z{Mi{#ZM]#Z#[!&x#[#]M]#]#^!&x#^#aM]#a#b!&x#b#gM]#g#h!&x#h#iM]#i#j!&x#j#mM]#m#n!&x#n~M],T!(R[$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!(|^$UWOY!'|YZKoZz!'|z{!(w{!P!'|!P!Q!)x!Q!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!*PY$UWU+{OYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~Hq,T!*tX$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#o!'|#o#p!$`#p~!'|,T!+fX$UWOYJlYZKoZzJlz{NQ{!^Jl!^!_!!]!_#oJl#o#p!!]#p~Jl,T!,Yc$UW}POzKoz{LZ{!^Ko!^!_M]!_#ZKo#Z#[!,R#[#]Ko#]#^!,R#^#aKo#a#b!,R#b#gKo#g#h!,R#h#iKo#i#j!,R#j#mKo#m#n!,R#n#oKo#o#pM]#p~Ko,T!-lV$UWT+{OY!-eYZ%TZ!^!-e!^!_!.R!_#o!-e#o#p!.R#p~!-e+{!.WQT+{OY!.RZ~!.R$P!.g[$UW#o#v}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Du]!/f[#wS$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Duy!0cd$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#U%T#U#V!3X#V#X%T#X#YAl#Y#b%T#b#c!2w#c#d!4m#d#l%T#l#m!5{#m#o%T#p~%Ty!1x_$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#X%T#X#YAl#Y#b%T#b#c!2w#c#o%T#p~%Ty!3OR$UWkqO!^%T!_#o%T#p~%Ty!3^W$UWO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#o%T#p~%Ty!3}Y$UWkqO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#b%T#b#c!2w#c#o%T#p~%Ty!4rV$UWO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#o%T#p~%Ty!5`X$UWkqO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#b%T#b#c!2w#c#o%T#p~%Ty!6QZ$UWO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#o%T#p~%Ty!6z]$UWkqO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#b%T#b#c!2w#c#o%T#p~%T%w!7|R!]V$UW#m%hO!^%T!_#o%T#p~%T!P!8^R_w$UWO!^%T!_#o%T#p~%T+c!8rR'`d!a%Y#x&s'zP!P!Q!8{!^!_!9Q!_!`!9_W!9QO$WW#v!9VP#`#v!_!`!9Y#v!9_O#o#v#v!9dO#a#v%w!9kT!{%o$UWO!^%T!_!`'v!`!a!9z!a#o%T#p~%T$P!:RR#W#w$UWO!^%T!_#o%T#p~%T%w!:gT'_!s#a#v$RS$UWO!^%T!_!`!:v!`!a!;W!a#o%T#p~%T$O!:}R#a#v$UWO!^%T!_#o%T#p~%T$O!;_T#`#v$UWO!^%T!_!`5T!`!a!;n!a#o%T#p~%T$O!;uS#`#v$UWO!^%T!_!`5T!`#o%T#p~%T%w!<YV'n%o$UWO!O%T!O!P!<o!P!^%T!_!a%T!a!b!=P!b#o%T#p~%T$`!<vRv$W$UWO!^%T!_#o%T#p~%T$O!=WS$UW#j#vO!^%T!_!`5T!`#o%T#p~%T&e!=kRx&]$UWO!^%T!_#o%T#p~%TZ!={R!OR$UWO!^%T!_#o%T#p~%T$O!>]S#g#v$UWO!^%T!_!`5T!`#o%T#p~%T$P!>pR$UW'd#wO!^%T!_#o%T#p~%T~!?OO!T~%r!?VT'u%j$UWO!^%T!_!`5T!`#o%T#p#q!=P#q~%T$u!?oR!S$knQ$UWO!^%T!_#o%T#p~%TX!@PR!kP$UWO!^%T!_#o%T#p~%T,T!@gr$UW'W+{#zS'Z%k'epOX%TXY%cYZ%TZ[%c[p%Tpq%cqt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`,T!CO_$UW'X+{#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`",
    tokenizers: [
        noSemicolon,
        incdecToken,
        template,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        insertSemicolon
    ],
    topRules: {
        "Script": [
            0,
            7
        ]
    },
    dialects: {
        jsx: 11335,
        ts: 11337
    },
    dynamicPrecedences: {
        "149": 1,
        "176": 1
    },
    specialized: [
        {
            term: 287,
            get: (value, stack)=>tsExtends(value, stack) << 1
        },
        {
            term: 287,
            get: (value)=>spec_identifier1[value] || -1
        },
        {
            term: 297,
            get: (value)=>spec_word[value] || -1
        },
        {
            term: 63,
            get: (value)=>spec_LessThan[value] || -1
        }
    ],
    tokenPrec: 11358
});
const snippets = [
    snippetCompletion("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }),
    snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }),
    snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }),
    snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "block",
        type: "keyword"
    }),
    snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }),
    snippetCompletion("import {${names}} from \"${module}\"\n${}", {
        label: "import",
        detail: "named",
        type: "keyword"
    }),
    snippetCompletion("import ${name} from \"${module}\"\n${}", {
        label: "import",
        detail: "default",
        type: "keyword"
    })
];
const javascriptLanguage = LRLanguage.define({
    parser: parser3.configure({
        props: [
            indentNodeProp.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch\b|finally\b)/
                }),
                LabeledStatement: flatIndent,
                SwitchBody: (context)=>{
                    let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                Block: delimitedIndent({
                    closing: "}"
                }),
                ArrowFunction: (cx)=>cx.baseIndent + cx.unit
                ,
                "TemplateString BlockComment": ()=>-1
                ,
                "Statement Property": continuedIndent({
                    except: /^{/
                }),
                JSXElement (context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                JSXEscape (context) {
                    let closed = /\s*\}/.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "JSXOpenTag JSXSelfClosingTag" (context) {
                    return context.column(context.node.from) + context.unit;
                }
            }),
            foldNodeProp.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside,
                BlockComment (tree) {
                    return {
                        from: tree.from + 2,
                        to: tree.to - 2
                    };
                }
            }),
            styleTags({
                "get set async static": tags.modifier,
                "for while do if else switch try catch finally return throw break continue default case": tags.controlKeyword,
                "in of await yield void typeof delete instanceof": tags.operatorKeyword,
                "let var const function class extends": tags.definitionKeyword,
                "import export from": tags.moduleKeyword,
                "with debugger as new": tags.keyword,
                TemplateString: tags.special(tags.string),
                Super: tags.atom,
                BooleanLiteral: tags.bool,
                this: tags.self,
                null: tags.null,
                Star: tags.modifier,
                VariableName: tags.variableName,
                "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
                VariableDefinition: tags.definition(tags.variableName),
                Label: tags.labelName,
                PropertyName: tags.propertyName,
                PrivatePropertyName: tags.special(tags.propertyName),
                "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
                "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
                "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
                PropertyDefinition: tags.definition(tags.propertyName),
                PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
                UpdateOp: tags.updateOperator,
                LineComment: tags.lineComment,
                BlockComment: tags.blockComment,
                Number: tags.number,
                String: tags.string,
                ArithOp: tags.arithmeticOperator,
                LogicOp: tags.logicOperator,
                BitOp: tags.bitwiseOperator,
                CompareOp: tags.compareOperator,
                RegExp: tags.regexp,
                Equals: tags.definitionOperator,
                "Arrow : Spread": tags.punctuation,
                "( )": tags.paren,
                "[ ]": tags.squareBracket,
                "{ }": tags.brace,
                "InterpolationStart InterpolationEnd": tags.special(tags.brace),
                ".": tags.derefOperator,
                ", ;": tags.separator,
                TypeName: tags.typeName,
                TypeDefinition: tags.definition(tags.typeName),
                "type enum interface implements namespace module declare": tags.definitionKeyword,
                "abstract global Privacy readonly override": tags.modifier,
                "is keyof unique infer": tags.operatorKeyword,
                JSXAttributeValue: tags.attributeValue,
                JSXText: tags.content,
                "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
                "JSXIdentifier JSXNameSpacedName": tags.tagName,
                "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName
            })
        ]
    }),
    languageData: {
        closeBrackets: {
            brackets: [
                "(",
                "[",
                "{",
                "'",
                '"',
                "`"
            ]
        },
        commentTokens: {
            line: "//",
            block: {
                open: "/*",
                close: "*/"
            }
        },
        indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
        wordChars: "$"
    }
});
const typescriptLanguage = javascriptLanguage.configure({
    dialect: "ts"
});
const jsxLanguage = javascriptLanguage.configure({
    dialect: "jsx"
});
const tsxLanguage = javascriptLanguage.configure({
    dialect: "jsx ts"
});
function javascript(config36 = {}) {
    let lang = config36.jsx ? config36.typescript ? tsxLanguage : jsxLanguage : config36.typescript ? typescriptLanguage : javascriptLanguage;
    return new LanguageSupport(lang, javascriptLanguage.data.of({
        autocomplete: ifNotIn([
            "LineComment",
            "BlockComment",
            "String"
        ], completeFromList(snippets))
    }));
}
const Targets = [
    "_blank",
    "_self",
    "_top",
    "_parent"
];
const Charsets = [
    "ascii",
    "utf-8",
    "utf-16",
    "latin1",
    "latin1"
];
const Methods = [
    "get",
    "post",
    "put",
    "delete"
];
const Encs = [
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
];
const Bool = [
    "true",
    "false"
];
const S = {};
const Tags = {
    a: {
        attrs: {
            href: null,
            ping: null,
            type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    acronym: S,
    address: S,
    applet: S,
    area: {
        attrs: {
            alt: null,
            coords: null,
            href: null,
            target: null,
            ping: null,
            media: null,
            hreflang: null,
            type: null,
            shape: [
                "default",
                "rect",
                "circle",
                "poly"
            ]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null,
            mediagroup: null,
            crossorigin: [
                "anonymous",
                "use-credentials"
            ],
            preload: [
                "none",
                "metadata",
                "auto"
            ],
            autoplay: [
                "autoplay"
            ],
            loop: [
                "loop"
            ],
            controls: [
                "controls"
            ]
        }
    },
    b: S,
    base: {
        attrs: {
            href: null,
            target: Targets
        }
    },
    basefont: S,
    bdi: S,
    bdo: S,
    big: S,
    blockquote: {
        attrs: {
            cite: null
        }
    },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null,
            formaction: null,
            name: null,
            value: null,
            autofocus: [
                "autofocus"
            ],
            disabled: [
                "autofocus"
            ],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: [
                "novalidate"
            ],
            formtarget: Targets,
            type: [
                "submit",
                "reset",
                "button"
            ]
        }
    },
    canvas: {
        attrs: {
            width: null,
            height: null
        }
    },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: {
        attrs: {
            span: null
        }
    },
    colgroup: {
        attrs: {
            span: null
        }
    },
    command: {
        attrs: {
            type: [
                "command",
                "checkbox",
                "radio"
            ],
            label: null,
            icon: null,
            radiogroup: null,
            command: null,
            title: null,
            disabled: [
                "disabled"
            ],
            checked: [
                "checked"
            ]
        }
    },
    data: {
        attrs: {
            value: null
        }
    },
    datagrid: {
        attrs: {
            disabled: [
                "disabled"
            ],
            multiple: [
                "multiple"
            ]
        }
    },
    datalist: {
        attrs: {
            data: null
        }
    },
    dd: S,
    del: {
        attrs: {
            cite: null,
            datetime: null
        }
    },
    details: {
        attrs: {
            open: [
                "open"
            ]
        }
    },
    dfn: S,
    dir: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: {
        attrs: {
            src: null,
            type: null,
            width: null,
            height: null
        }
    },
    eventsource: {
        attrs: {
            src: null
        }
    },
    fieldset: {
        attrs: {
            disabled: [
                "disabled"
            ],
            form: null,
            name: null
        }
    },
    figcaption: S,
    figure: S,
    font: S,
    footer: S,
    form: {
        attrs: {
            action: null,
            name: null,
            "accept-charset": Charsets,
            autocomplete: [
                "on",
                "off"
            ],
            enctype: Encs,
            method: Methods,
            novalidate: [
                "novalidate"
            ],
            target: Targets
        }
    },
    frame: S,
    frameset: S,
    h1: S,
    h2: S,
    h3: S,
    h4: S,
    h5: S,
    h6: S,
    head: {
        children: [
            "title",
            "base",
            "link",
            "style",
            "meta",
            "script",
            "noscript",
            "command"
        ]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: {
            manifest: null
        }
    },
    i: S,
    iframe: {
        attrs: {
            src: null,
            srcdoc: null,
            name: null,
            width: null,
            height: null,
            sandbox: [
                "allow-top-navigation",
                "allow-same-origin",
                "allow-forms",
                "allow-scripts"
            ],
            seamless: [
                "seamless"
            ]
        }
    },
    img: {
        attrs: {
            alt: null,
            src: null,
            ismap: null,
            usemap: null,
            width: null,
            height: null,
            crossorigin: [
                "anonymous",
                "use-credentials"
            ]
        }
    },
    input: {
        attrs: {
            alt: null,
            dirname: null,
            form: null,
            formaction: null,
            height: null,
            list: null,
            max: null,
            maxlength: null,
            min: null,
            name: null,
            pattern: null,
            placeholder: null,
            size: null,
            src: null,
            step: null,
            value: null,
            width: null,
            accept: [
                "audio/*",
                "video/*",
                "image/*"
            ],
            autocomplete: [
                "on",
                "off"
            ],
            autofocus: [
                "autofocus"
            ],
            checked: [
                "checked"
            ],
            disabled: [
                "disabled"
            ],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: [
                "novalidate"
            ],
            formtarget: Targets,
            multiple: [
                "multiple"
            ],
            readonly: [
                "readonly"
            ],
            required: [
                "required"
            ],
            type: [
                "hidden",
                "text",
                "search",
                "tel",
                "url",
                "email",
                "password",
                "datetime",
                "date",
                "month",
                "week",
                "time",
                "datetime-local",
                "number",
                "range",
                "color",
                "checkbox",
                "radio",
                "file",
                "submit",
                "image",
                "reset",
                "button"
            ]
        }
    },
    ins: {
        attrs: {
            cite: null,
            datetime: null
        }
    },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null,
            form: null,
            name: null,
            autofocus: [
                "autofocus"
            ],
            disabled: [
                "disabled"
            ],
            keytype: [
                "RSA"
            ]
        }
    },
    label: {
        attrs: {
            for: null,
            form: null
        }
    },
    legend: S,
    li: {
        attrs: {
            value: null
        }
    },
    link: {
        attrs: {
            href: null,
            type: null,
            hreflang: null,
            media: null,
            sizes: [
                "all",
                "16x16",
                "16x16 32x32",
                "16x16 32x32 64x64"
            ]
        }
    },
    map: {
        attrs: {
            name: null
        }
    },
    mark: S,
    menu: {
        attrs: {
            label: null,
            type: [
                "list",
                "context",
                "toolbar"
            ]
        }
    },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: [
                "viewport",
                "application-name",
                "author",
                "description",
                "generator",
                "keywords"
            ],
            "http-equiv": [
                "content-language",
                "content-type",
                "default-style",
                "refresh"
            ]
        }
    },
    meter: {
        attrs: {
            value: null,
            min: null,
            low: null,
            high: null,
            max: null,
            optimum: null
        }
    },
    nav: S,
    noframes: S,
    noscript: S,
    object: {
        attrs: {
            data: null,
            type: null,
            name: null,
            usemap: null,
            form: null,
            width: null,
            height: null,
            typemustmatch: [
                "typemustmatch"
            ]
        }
    },
    ol: {
        attrs: {
            reversed: [
                "reversed"
            ],
            start: null,
            type: [
                "1",
                "a",
                "A",
                "i",
                "I"
            ]
        },
        children: [
            "li",
            "script",
            "template",
            "ul",
            "ol"
        ]
    },
    optgroup: {
        attrs: {
            disabled: [
                "disabled"
            ],
            label: null
        }
    },
    option: {
        attrs: {
            disabled: [
                "disabled"
            ],
            label: null,
            selected: [
                "selected"
            ],
            value: null
        }
    },
    output: {
        attrs: {
            for: null,
            form: null,
            name: null
        }
    },
    p: S,
    param: {
        attrs: {
            name: null,
            value: null
        }
    },
    pre: S,
    progress: {
        attrs: {
            value: null,
            max: null
        }
    },
    q: {
        attrs: {
            cite: null
        }
    },
    rp: S,
    rt: S,
    ruby: S,
    s: S,
    samp: S,
    script: {
        attrs: {
            type: [
                "text/javascript"
            ],
            src: null,
            async: [
                "async"
            ],
            defer: [
                "defer"
            ],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null,
            name: null,
            size: null,
            autofocus: [
                "autofocus"
            ],
            disabled: [
                "disabled"
            ],
            multiple: [
                "multiple"
            ]
        }
    },
    slot: {
        attrs: {
            name: null
        }
    },
    small: S,
    source: {
        attrs: {
            src: null,
            type: null,
            media: null
        }
    },
    span: S,
    strike: S,
    strong: S,
    style: {
        attrs: {
            type: [
                "text/css"
            ],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: {
        attrs: {
            colspan: null,
            rowspan: null,
            headers: null
        }
    },
    template: S,
    textarea: {
        attrs: {
            dirname: null,
            form: null,
            maxlength: null,
            name: null,
            placeholder: null,
            rows: null,
            cols: null,
            autofocus: [
                "autofocus"
            ],
            disabled: [
                "disabled"
            ],
            readonly: [
                "readonly"
            ],
            required: [
                "required"
            ],
            wrap: [
                "soft",
                "hard"
            ]
        }
    },
    tfoot: S,
    th: {
        attrs: {
            colspan: null,
            rowspan: null,
            headers: null,
            scope: [
                "row",
                "col",
                "rowgroup",
                "colgroup"
            ]
        }
    },
    thead: S,
    time: {
        attrs: {
            datetime: null
        }
    },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null,
            label: null,
            default: null,
            kind: [
                "subtitles",
                "captions",
                "descriptions",
                "chapters",
                "metadata"
            ],
            srclang: null
        }
    },
    tt: S,
    u: S,
    ul: {
        children: [
            "li",
            "script",
            "template",
            "ul",
            "ol"
        ]
    },
    var: S,
    video: {
        attrs: {
            src: null,
            poster: null,
            width: null,
            height: null,
            crossorigin: [
                "anonymous",
                "use-credentials"
            ],
            preload: [
                "auto",
                "metadata",
                "none"
            ],
            autoplay: [
                "autoplay"
            ],
            mediagroup: [
                "movie"
            ],
            muted: [
                "muted"
            ],
            controls: [
                "controls"
            ]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: [
        "ltr",
        "rtl",
        "auto"
    ],
    draggable: [
        "true",
        "false",
        "auto"
    ],
    dropzone: [
        "copy",
        "move",
        "link",
        "string:",
        "file:"
    ],
    hidden: [
        "hidden"
    ],
    id: null,
    inert: [
        "inert"
    ],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: [
        "itemscope"
    ],
    itemtype: null,
    lang: [
        "ar",
        "bn",
        "de",
        "en-GB",
        "en-US",
        "es",
        "fr",
        "hi",
        "id",
        "ja",
        "pa",
        "pt",
        "ru",
        "tr",
        "zh"
    ],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: [
        "yes",
        "no"
    ],
    onclick: null,
    rel: [
        "stylesheet",
        "alternate",
        "author",
        "bookmark",
        "help",
        "license",
        "next",
        "nofollow",
        "noreferrer",
        "prefetch",
        "prev",
        "search",
        "tag"
    ],
    role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": [
        "inline",
        "list",
        "both",
        "none"
    ],
    "aria-busy": Bool,
    "aria-checked": [
        "true",
        "false",
        "mixed",
        "undefined"
    ],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": [
        "true",
        "false",
        "undefined"
    ],
    "aria-flowto": null,
    "aria-grabbed": [
        "true",
        "false",
        "undefined"
    ],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": [
        "true",
        "false",
        "grammar",
        "spelling"
    ],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": [
        "off",
        "polite",
        "assertive"
    ],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": [
        "true",
        "false",
        "mixed",
        "undefined"
    ],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": [
        "true",
        "false",
        "undefined"
    ],
    "aria-setsize": null,
    "aria-sort": [
        "ascending",
        "descending",
        "none",
        "other"
    ],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
const AllTags = Object.keys(Tags);
const GlobalAttrNames = Object.keys(GlobalAttrs);
function elementName(doc43, tree, max = doc43.length) {
    if (!tree) return "";
    let tag = tree.firstChild;
    let name74 = tag && tag.getChild("TagName");
    return name74 ? doc43.sliceString(name74.from, Math.min(name74.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for(let cur29 = tree.parent; cur29; cur29 = cur29.parent)if (cur29.name == "Element") {
        if (skip) skip = false;
        else return cur29;
    }
    return null;
}
function allowedChildren(doc44, tree) {
    let parentInfo = Tags[elementName(doc44, findParentElement(tree, true))];
    return parentInfo?.children || AllTags;
}
function openTags(doc45, tree) {
    let open = [];
    for(let parent = tree; parent = findParentElement(parent);){
        let tagName = elementName(doc45, parent);
        if (tagName && parent.lastChild.name == "CloseTag") break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to)) open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]+$/;
function completeTag(state215, tree, from, to) {
    let end = /\s*>/.test(state215.sliceDoc(to, to + 5)) ? "" : ">";
    return {
        from,
        to,
        options: allowedChildren(state215.doc, tree).map((tagName)=>({
                label: tagName,
                type: "type"
            })
        ).concat(openTags(state215.doc, tree).map((tag, i312)=>({
                label: "/" + tag,
                apply: "/" + tag + end,
                type: "type",
                boost: 99 - i312
            })
        )),
        span: /^\/?[:\-\.\w\u00b7-\uffff]*$/
    };
}
function completeCloseTag(state216, tree, from, to) {
    let end = /\s*>/.test(state216.sliceDoc(to, to + 5)) ? "" : ">";
    return {
        from,
        to,
        options: openTags(state216.doc, tree).map((tag, i313)=>({
                label: tag,
                apply: tag + end,
                type: "type",
                boost: 99 - i313
            })
        ),
        span: identifier
    };
}
function completeStartTag(state217, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state217.doc, tree))options.push({
        label: "<" + tagName,
        type: "type"
    });
    for (let open of openTags(state217.doc, tree))options.push({
        label: "</" + open + ">",
        type: "type",
        boost: 99 - level++
    });
    return {
        from: pos,
        to: pos,
        options,
        span: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
    };
}
function completeAttrName(state218, tree, from, to) {
    let elt16 = findParentElement(tree), info = elt16 ? Tags[elementName(state218.doc, elt16)] : null;
    let names = info && info.attrs ? Object.keys(info.attrs).concat(GlobalAttrNames) : GlobalAttrNames;
    return {
        from,
        to,
        options: names.map((attrName)=>({
                label: attrName,
                type: "property"
            })
        ),
        span: identifier
    };
}
function completeAttrValue(state219, tree, from, to) {
    let nameNode = tree.parent?.getChild("AttributeName");
    let options = [], span14 = undefined;
    if (nameNode) {
        let attrName = state219.sliceDoc(nameNode.from, nameNode.to);
        let attrs = GlobalAttrs[attrName];
        if (!attrs) {
            let elt17 = findParentElement(tree), info = elt17 ? Tags[elementName(state219.doc, elt17)] : null;
            attrs = info?.attrs && info.attrs[attrName];
        }
        if (attrs) {
            let base31 = state219.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base31)) {
                span14 = base31[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state219.sliceDoc(to, to + 1) == base31[0] ? "" : base31[0];
                base31 = base31.slice(1);
                from++;
            } else {
                span14 = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)options.push({
                label: value,
                apply: quoteStart + value + quoteEnd,
                type: "constant"
            });
        }
    }
    return {
        from,
        to,
        options,
        span: span14
    };
}
function htmlCompletionSource(context) {
    let { state: state220 , pos  } = context, around = syntaxTree(state220).resolveInner(pos), tree = around.resolve(pos, -1);
    for(let scan = pos, before; around == tree && (before = tree.childBefore(scan));){
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to) break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state220, tree, tree.from, pos) : completeTag(state220, tree, tree.from, pos);
    } else if (tree.name == "StartTag") {
        return completeTag(state220, tree, pos, pos);
    } else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state220, tree, pos, pos);
    } else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state220, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    } else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state220, tree, tree.name == "Is" ? pos : tree.from, pos);
    } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state220, tree, pos);
    } else {
        return null;
    }
}
const htmlLanguage = LRLanguage.define({
    parser: parser1.configure({
        props: [
            indentNodeProp.add({
                Element (context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length) return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag" (context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document (context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to) return context.continue();
                    let endElt = null, close;
                    for(let cur30 = context.node;;){
                        let last = cur30.lastChild;
                        if (!last || last.name != "Element" || last.to != cur30.to) break;
                        endElt = cur30 = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag"))) return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            foldNodeProp.add({
                Element (node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag") return null;
                    return {
                        from: first.to,
                        to: last.name == "CloseTag" ? last.from : node.to
                    };
                }
            }),
            styleTags({
                "Text RawText": tags.content,
                "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": tags.angleBracket,
                TagName: tags.tagName,
                "MismatchedCloseTag/TagName": [
                    tags.tagName,
                    tags.invalid
                ],
                AttributeName: tags.attributeName,
                "AttributeValue UnquotedAttributeValue": tags.attributeValue,
                Is: tags.definitionOperator,
                "EntityReference CharacterReference": tags.character,
                Comment: tags.blockComment,
                ProcessingInst: tags.processingInstruction,
                DoctypeDecl: tags.documentMeta
            })
        ],
        wrap: configureNesting([
            {
                tag: "script",
                attrs (attrs) {
                    return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
                },
                parser: javascriptLanguage.parser
            },
            {
                tag: "style",
                attrs (attrs) {
                    return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
                },
                parser: cssLanguage.parser
            }
        ])
    }),
    languageData: {
        commentTokens: {
            block: {
                open: "<!--",
                close: "-->"
            }
        },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
const htmlCompletion = htmlLanguage.data.of({
    autocomplete: htmlCompletionSource
});
function html(config37 = {}) {
    let lang = htmlLanguage;
    if (config37.matchClosingTags === false) lang = lang.configure({
        dialect: "noMatch"
    });
    return new LanguageSupport(lang, [
        htmlCompletion,
        config37.autoCloseTags !== false ? autoCloseTags : [],
        javascript().support,
        css().support
    ]);
}
const autoCloseTags = EditorView.inputHandler.of((view, from, to, text)=>{
    if (view.composing || view.state.readOnly || from != to || text != ">" && text != "/" || !htmlLanguage.isActiveAt(view.state, from, -1)) return false;
    let { state: state221  } = view;
    let changes = state221.changeByRange((range)=>{
        let { head  } = range, around = syntaxTree(state221).resolveInner(head, -1), name75;
        if (around.name == "TagName" || around.name == "StartTag") around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (around.parent?.lastChild?.name != "CloseTag" && (name75 = elementName(state221.doc, around.parent, head))) return {
                range: EditorSelection.cursor(head + 1),
                changes: {
                    from: head,
                    insert: `></${name75}>`
                }
            };
        } else if (text == "/" && around.name == "OpenTag") {
            let empty3 = around.parent, base32 = empty3?.parent;
            if (empty3.from == head - 1 && base32.lastChild?.name != "CloseTag" && (name75 = elementName(state221.doc, base32, head))) {
                let insert11 = `/${name75}>`;
                return {
                    range: EditorSelection.cursor(head + insert11.length),
                    changes: {
                        from: head,
                        insert: insert11
                    }
                };
            }
        }
        return {
            range
        };
    });
    if (changes.changes.empty) return false;
    view.dispatch(changes, {
        userEvent: "input.type",
        scrollIntoView: true
    });
    return true;
});
const data = defineLanguageFacet({
    block: {
        open: "<!--",
        close: "-->"
    }
});
const commonmark = parser.configure({
    props: [
        styleTags({
            "Blockquote/...": tags.quote,
            HorizontalRule: tags.contentSeparator,
            "ATXHeading1/... SetextHeading1/...": tags.heading1,
            "ATXHeading2/... SetextHeading2/...": tags.heading2,
            "ATXHeading3/...": tags.heading3,
            "ATXHeading4/...": tags.heading4,
            "ATXHeading5/...": tags.heading5,
            "ATXHeading6/...": tags.heading6,
            "Comment CommentBlock": tags.comment,
            Escape: tags.escape,
            Entity: tags.character,
            "Emphasis/...": tags.emphasis,
            "StrongEmphasis/...": tags.strong,
            "Link/... Image/...": tags.link,
            "OrderedList/... BulletList/...": tags.list,
            "BlockQuote/...": tags.quote,
            "InlineCode CodeText": tags.monospace,
            URL: tags.url,
            "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
            "CodeInfo LinkLabel": tags.labelName,
            LinkTitle: tags.string,
            Paragraph: tags.content
        }),
        foldNodeProp.add((type)=>{
            if (!type.is("Block") || type.is("Document")) return undefined;
            return (tree, state222)=>({
                    from: state222.doc.lineAt(tree.from).to,
                    to: tree.to
                })
            ;
        }),
        indentNodeProp.add({
            Document: ()=>null
        }),
        languageDataProp.add({
            Document: data
        })
    ]
});
function mkLang(parser24) {
    return new Language(data, parser24, parser24.nodeSet.types.find((t1)=>t1.name == "Document"
    ));
}
const commonmarkLanguage = mkLang(commonmark);
const extended = commonmark.configure([
    GFM,
    Subscript,
    Superscript,
    Emoji,
    {
        props: [
            styleTags({
                "TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark": tags.processingInstruction,
                "TableHeader/...": tags.heading,
                "Strikethrough/...": tags.strikethrough,
                TaskMarker: tags.atom,
                Task: tags.list,
                Emoji: tags.character,
                "Subscript Superscript": tags.special(tags.content),
                TableCell: tags.content
            })
        ]
    }
]);
const markdownLanguage = mkLang(extended);
function getCodeParser(languages, defaultLanguage) {
    return (info)=>{
        let found = info && LanguageDescription.matchLanguageName(languages, info, true);
        if (!found) return defaultLanguage ? defaultLanguage.parser : null;
        if (found.support) return found.support.language.parser;
        return ParseContext.getSkippingParser(found.load());
    };
}
function nodeStart1(node, doc46) {
    return doc46.sliceString(node.from, node.from + 50);
}
class Context {
    node;
    from;
    to;
    spaceBefore;
    spaceAfter;
    type;
    item;
    constructor(node, from, to, spaceBefore, spaceAfter, type, item){
        this.node = node;
        this.from = from;
        this.to = to;
        this.spaceBefore = spaceBefore;
        this.spaceAfter = spaceAfter;
        this.type = type;
        this.item = item;
    }
    blank(trailing = true) {
        let result = this.spaceBefore;
        if (this.node.name == "Blockquote") result += ">";
        else for(let i314 = this.to - this.from - result.length - this.spaceAfter.length; i314 > 0; i314--)result += " ";
        return result + (trailing ? this.spaceAfter : "");
    }
    marker(doc47, add8) {
        let number6 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc47)[2] + add8) : "";
        return this.spaceBefore + number6 + this.type + this.spaceAfter;
    }
}
function getContext(node, line, doc48) {
    let nodes = [];
    for(let cur31 = node; cur31 && cur31.name != "Document"; cur31 = cur31.parent){
        if (cur31.name == "ListItem" || cur31.name == "Blockquote") nodes.push(cur31);
    }
    let context = [], pos = 0;
    for(let i315 = nodes.length - 1; i315 >= 0; i315--){
        let node = nodes[i315], match, start = pos;
        if (node.name == "Blockquote" && (match = /^[ \t]*>( ?)/.exec(line.slice(pos)))) {
            pos += match[0].length;
            context.push(new Context(node, start, pos, "", match[1], ">", null));
        } else if (node.name == "ListItem" && node.parent.name == "OrderedList" && (match = /^([ \t]*)\d+([.)])([ \t]*)/.exec(nodeStart1(node, doc48)))) {
            let after = match[3], len = match[0].length;
            if (after.length >= 4) {
                after = after.slice(0, after.length - 4);
                len -= 4;
            }
            pos += len;
            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));
        } else if (node.name == "ListItem" && node.parent.name == "BulletList" && (match = /^([ \t]*)([-+*])([ \t]+)/.exec(nodeStart1(node, doc48)))) {
            let after = match[3], len = match[0].length;
            if (after.length > 4) {
                after = after.slice(0, after.length - 4);
                len -= 4;
            }
            pos += len;
            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));
        }
    }
    return context;
}
function itemNumber(item, doc49) {
    return /^(\s*)(\d+)(?=[.)])/.exec(doc49.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc50, changes, offset = 0) {
    for(let prev = -1, node = after;;){
        if (node.name == "ListItem") {
            let m = itemNumber(node, doc50);
            let number7 = +m[2];
            if (prev >= 0) {
                if (number7 != prev + 1) return;
                changes.push({
                    from: node.from + m[1].length,
                    to: node.from + m[0].length,
                    insert: String(prev + 2 + offset)
                });
            }
            prev = number7;
        }
        let next = node.nextSibling;
        if (!next) break;
        node = next;
    }
}
const insertNewlineContinueMarkup = ({ state: state223 , dispatch  })=>{
    let tree = syntaxTree(state223), { doc: doc51  } = state223;
    let dont = null, changes1 = state223.changeByRange((range)=>{
        if (!range.empty || !markdownLanguage.isActiveAt(state223, range.from)) return dont = {
            range
        };
        let pos = range.from, line = doc51.lineAt(pos);
        let context = getContext(tree.resolveInner(pos, -1), line.text, doc51);
        while(context.length && context[context.length - 1].from > pos - line.from)context.pop();
        if (!context.length) return dont = {
            range
        };
        let inner = context[context.length - 1];
        if (inner.to - inner.spaceAfter.length > pos - line.from) return dont = {
            range
        };
        let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
        if (inner.item && emptyLine) {
            if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\s>]/.test(doc51.lineAt(line.from - 1).text)) {
                let next = context.length > 1 ? context[context.length - 2] : null;
                let delTo, insert12 = "";
                if (next && next.item) {
                    delTo = line.from + next.from;
                    insert12 = next.marker(doc51, 1);
                } else {
                    delTo = line.from + (next ? next.to : 0);
                }
                let changes = [
                    {
                        from: delTo,
                        to: pos,
                        insert: insert12
                    }
                ];
                if (inner.node.name == "OrderedList") renumberList(inner.item, doc51, changes, -2);
                if (next && next.node.name == "OrderedList") renumberList(next.item, doc51, changes);
                return {
                    range: EditorSelection.cursor(delTo + insert12.length),
                    changes
                };
            } else {
                let insert13 = "";
                for(let i316 = 0, e = context.length - 2; i316 <= e; i316++)insert13 += context[i316].blank(i316 < e);
                insert13 += state223.lineBreak;
                return {
                    range: EditorSelection.cursor(pos + insert13.length),
                    changes: {
                        from: line.from,
                        insert: insert13
                    }
                };
            }
        }
        if (inner.node.name == "Blockquote" && emptyLine && line.from) {
            let prevLine = doc51.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
            if (quoted && quoted.index == inner.from) {
                let changes = state223.changes([
                    {
                        from: prevLine.from + quoted.index,
                        to: prevLine.to
                    },
                    {
                        from: line.from + inner.from,
                        to: line.to
                    }
                ]);
                return {
                    range: range.map(changes),
                    changes
                };
            }
        }
        let changes = [];
        if (inner.node.name == "OrderedList") renumberList(inner.item, doc51, changes);
        let insert14 = state223.lineBreak;
        let continued = inner.item && inner.item.from < line.from;
        if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
            for(let i317 = 0, e = context.length - 1; i317 <= e; i317++)insert14 += i317 == e && !continued ? context[i317].marker(doc51, 1) : context[i317].blank();
        }
        let from = pos;
        while(from > line.from && /\s/.test(line.text.charAt(from - line.from - 1)))from--;
        changes.push({
            from,
            to: pos,
            insert: insert14
        });
        return {
            range: EditorSelection.cursor(from + insert14.length),
            changes
        };
    });
    if (dont) return false;
    dispatch(state223.update(changes1, {
        scrollIntoView: true,
        userEvent: "input"
    }));
    return true;
};
function isMark(node) {
    return node.name == "QuoteMark" || node.name == "ListMark";
}
function contextNodeForDelete(tree, pos) {
    let node = tree.resolveInner(pos, -1), scan = pos;
    if (isMark(node)) {
        scan = node.from;
        node = node.parent;
    }
    for(let prev; prev = node.childBefore(scan);){
        if (isMark(prev)) {
            scan = prev.from;
        } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
            node = prev.lastChild;
            scan = node.to;
        } else {
            break;
        }
    }
    return node;
}
const deleteMarkupBackward = ({ state: state224 , dispatch  })=>{
    let tree = syntaxTree(state224);
    let dont = null, changes = state224.changeByRange((range)=>{
        let pos = range.from, { doc: doc52  } = state224;
        if (range.empty && markdownLanguage.isActiveAt(state224, range.from)) {
            let line = doc52.lineAt(pos);
            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc52);
            if (context.length) {
                let inner = context[context.length - 1];
                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
                if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from))) return {
                    range: EditorSelection.cursor(line.from + spaceEnd),
                    changes: {
                        from: line.from + spaceEnd,
                        to: pos
                    }
                };
                if (pos - line.from == spaceEnd) {
                    let start = line.from + inner.from;
                    if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to))) return {
                        range,
                        changes: {
                            from: start,
                            to: line.from + inner.to,
                            insert: inner.blank()
                        }
                    };
                    if (start < pos) return {
                        range: EditorSelection.cursor(start),
                        changes: {
                            from: start,
                            to: pos
                        }
                    };
                }
            }
        }
        return dont = {
            range
        };
    });
    if (dont) return false;
    dispatch(state224.update(changes, {
        scrollIntoView: true,
        userEvent: "delete"
    }));
    return true;
};
const markdownKeymap = [
    {
        key: "Enter",
        run: insertNewlineContinueMarkup
    },
    {
        key: "Backspace",
        run: deleteMarkupBackward
    }
];
const htmlNoMatch = html({
    matchClosingTags: false
});
function markdown(config38 = {}) {
    let { codeLanguages , defaultCodeLanguage , addKeymap =true , base: { parser: parser25  } = commonmarkLanguage  } = config38;
    if (!(parser25 instanceof MarkdownParser)) throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
    let extensions = config38.extensions ? [
        config38.extensions
    ] : [];
    let support = [
        htmlNoMatch.support
    ], defaultCode;
    if (defaultCodeLanguage instanceof LanguageSupport) {
        support.push(defaultCodeLanguage.support);
        defaultCode = defaultCodeLanguage.language;
    } else if (defaultCodeLanguage) {
        defaultCode = defaultCodeLanguage;
    }
    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : undefined;
    extensions.push(parseCode({
        codeParser,
        htmlParser: htmlNoMatch.language.parser
    }));
    if (addKeymap) support.push(Prec.high(keymap.of(markdownKeymap)));
    return new LanguageSupport(mkLang(parser25.configure(extensions)), support);
}
const state1 = EditorState.create({
    doc: 'console.log("Hello world")',
    extensions: [
        basicSetup,
        markdown(), 
    ]
});
window.view = new EditorView({
    state: state1,
    parent: document.querySelector("#editor")
});
